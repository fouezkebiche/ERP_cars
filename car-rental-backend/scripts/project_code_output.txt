

// [Folder] scripts


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\scripts\extract_code.js
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Fix __dirname in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Go up one level to the project root
const sourceFolder = path.resolve(__dirname, '..');
const outputFile = path.join(__dirname, 'project_code_output.txt');

// File types you want to extract
const extensions = [
  '.js', '.jsx', '.ts', '.tsx',
  '.json', '.html', '.css', '.scss',
];

// Folders to skip (important for MERN apps)
const skipFolders = new Set([
  'node_modules',
  '.git',
  '.next',
  'dist',
  'build',
  '.cache',
  'coverage',
  '.vscode',
  'uploads',
]);

// Files to skip
const skipFiles = new Set([
  'package-lock.json',
  'yarn.lock',
  '.env',
  '.DS_Store',
]);

function concatenateFiles(folderPath, depth = 0) {
  const files = fs.readdirSync(folderPath);
  let fileContent = '';
  let folderContent = '';

  for (const file of files) {
    const filePath = path.join(folderPath, file);
    const stats = fs.statSync(filePath);

    if (stats.isDirectory()) {
      if (skipFolders.has(file)) continue;

      const subContent = concatenateFiles(filePath, depth + 1);
      if (subContent?.trim()) {
        folderContent += `\n\n// ${'  '.repeat(depth)}[Folder] ${file}\n${subContent}\n`;
      }
    } else {
      if (skipFiles.has(file)) continue;

      for (const ext of extensions) {
        if (file.endsWith(ext)) {
          const fileData = fs.readFileSync(filePath, 'utf-8');
          fileContent += `\n\n// ${filePath}\n${fileData}`;
          break;
        }
      }
    }
  }

  return folderContent + fileContent;
}

// Clear output
fs.writeFileSync(outputFile, '', 'utf-8');
const allContent = concatenateFiles(sourceFolder);
fs.appendFileSync(outputFile, allContent, 'utf-8');

console.log(`âœ… Code extracted to: ${outputFile}`);


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\scripts\generate-demo.js
const { sequelize, Company, User, Vehicle, Customer, Contract, Payment, VehicleCost, Employee } = require('../src/models');

async function generateDemoData() {
  try {
    console.log('ðŸŒ± Starting database seed...');

    // Sync database (create tables)
    await sequelize.sync({ force: true });
    console.log('âœ… Database synced');

    // ============================================
    // 1. CREATE COMPANIES
    // ============================================
    const companies = await Company.bulkCreate([
      {
        name: 'Elite Rentals',
        email: 'admin@eliterentals.com',
        phone: '+213 555 1111',
        address: '123 Business Street, Algiers',
        tax_id: 'TAX-ELITE-001',
        subscription_plan: 'professional',
        subscription_status: 'active',
        subscription_start_date: new Date('2024-01-01'),
        subscription_end_date: new Date('2025-12-31'),
        monthly_recurring_revenue: 15000,
      },
      {
        name: 'Speed Motors',
        email: 'admin@speedmotors.com',
        phone: '+213 555 2222',
        address: '456 Car Avenue, Oran',
        tax_id: 'TAX-SPEED-002',
        subscription_plan: 'basic',
        subscription_status: 'active',
        subscription_start_date: new Date('2024-06-01'),
        subscription_end_date: new Date('2025-05-31'),
        monthly_recurring_revenue: 5000,
      },
    ]);
    console.log(`âœ… Created ${companies.length} companies`);

    // ============================================
    // 2. CREATE USERS (One at a time for hooks to work)
    // ============================================
    const user1 = await User.create({
      company_id: companies[0].id,
      full_name: 'Ahmed Manager',
      email: 'ahmed@eliterentals.com',
      password: 'password123',
      role: 'owner',
      is_active: true,
    });

    const user2 = await User.create({
      company_id: companies[0].id,
      full_name: 'Sarah Staff',
      email: 'sarah@eliterentals.com',
      password: 'password123',
      role: 'staff',
      is_active: true,
    });

    const user3 = await User.create({
      company_id: companies[1].id,
      full_name: 'Karim Owner',
      email: 'karim@speedmotors.com',
      password: 'password123',
      role: 'owner',
      is_active: true,
    });

    const users = [user1, user2, user3];
    console.log(`âœ… Created ${users.length} users`);

    // ============================================
    // 3. CREATE CUSTOMERS
    // ============================================
    const customers = await Customer.bulkCreate([
      {
        company_id: companies[0].id,
        customer_type: 'individual',
        full_name: 'Mohamed Ali',
        email: 'mohamed@email.com',
        phone: '+213 666 1111',
        address: '789 Customer Street, Algiers',
        drivers_license_number: 'DL-123456',
        license_expiry_date: '2027-06-15',
        total_rentals: 0,
        lifetime_value: 0,
      },
      {
        company_id: companies[0].id,
        customer_type: 'individual',
        full_name: 'Fatima Saadi',
        email: 'fatima@email.com',
        phone: '+213 666 2222',
        address: '321 Residential Area, Algiers',
        drivers_license_number: 'DL-789012',
        license_expiry_date: '2026-12-20',
        total_rentals: 0,
        lifetime_value: 0,
      },
      {
        company_id: companies[0].id,
        customer_type: 'corporate',
        full_name: 'Ali Bouteflika',
        company_name: 'Tech Solutions Algeria',
        email: 'ali@techsolutions.dz',
        phone: '+213 666 3333',
        address: 'Business Park, Algiers',
        drivers_license_number: 'DL-345678',
        license_expiry_date: '2028-03-10',
        total_rentals: 0,
        lifetime_value: 0,
      },
    ]);
    console.log(`âœ… Created ${customers.length} customers`);

    // ============================================
    // 4. CREATE VEHICLES
    // ============================================
    const vehicles = await Vehicle.bulkCreate([
      {
        company_id: companies[0].id,
        brand: 'Toyota',
        model: 'Corolla',
        year: 2023,
        registration_number: 'ABC-123-45',
        color: 'White',
        transmission: 'automatic',
        fuel_type: 'petrol',
        seats: 5,
        daily_rate: 25000,
        status: 'available',
        mileage: 15000,
        purchase_price: 3500000,
        purchase_date: '2023-01-15',
        features: { gps: true, ac: true, bluetooth: true },
      },
      {
        company_id: companies[0].id,
        brand: 'Hyundai',
        model: 'i30',
        year: 2023,
        registration_number: 'DEF-456-78',
        color: 'Silver',
        transmission: 'manual',
        fuel_type: 'diesel',
        seats: 5,
        daily_rate: 21000,
        status: 'rented',
        mileage: 22000,
        purchase_price: 2800000,
        purchase_date: '2023-03-20',
        features: { ac: true, bluetooth: true },
      },
      {
        company_id: companies[0].id,
        brand: 'BMW',
        model: '320',
        year: 2022,
        registration_number: 'GHI-789-01',
        color: 'Black',
        transmission: 'automatic',
        fuel_type: 'petrol',
        seats: 5,
        daily_rate: 35000,
        status: 'available',
        mileage: 35000,
        purchase_price: 6500000,
        purchase_date: '2022-06-10',
        features: { gps: true, ac: true, bluetooth: true, leather_seats: true },
      },
      {
        company_id: companies[1].id,
        brand: 'Renault',
        model: 'Clio',
        year: 2024,
        registration_number: 'JKL-101-11',
        color: 'Red',
        transmission: 'manual',
        fuel_type: 'petrol',
        seats: 5,
        daily_rate: 18000,
        status: 'available',
        mileage: 5000,
        purchase_price: 2200000,
        purchase_date: '2024-01-01',
        features: { ac: true },
      },
    ]);
    console.log(`âœ… Created ${vehicles.length} vehicles`);

    // ============================================
    // 5. CREATE CONTRACTS
    // ============================================
    const contracts = await Contract.bulkCreate([
      {
        contract_number: 'RENT-2025-0001',
        company_id: companies[0].id,
        customer_id: customers[0].id,
        vehicle_id: vehicles[0].id,
        created_by: users[0].id,
        start_date: new Date('2025-01-01'),
        end_date: new Date('2025-01-08'),
        actual_return_date: new Date('2025-01-08'),
        daily_rate: 25000,
        total_days: 7,
        base_amount: 175000,
        additional_charges: 15000,
        discount_amount: 0,
        tax_amount: 36100,
        total_amount: 226100,
        start_mileage: 15000,
        end_mileage: 15800,
        mileage_limit: 1000,
        status: 'completed',
        extras: { gps: true, insurance: 'full' },
        deposit_amount: 50000,
        deposit_returned: true,
      },
      {
        contract_number: 'RENT-2025-0002',
        company_id: companies[0].id,
        customer_id: customers[1].id,
        vehicle_id: vehicles[1].id,
        created_by: users[0].id,
        start_date: new Date('2025-01-10'),
        end_date: new Date('2025-01-17'),
        daily_rate: 21000,
        total_days: 7,
        base_amount: 147000,
        additional_charges: 5000,
        discount_amount: 0,
        tax_amount: 28880,
        total_amount: 180880,
        start_mileage: 22000,
        mileage_limit: 800,
        status: 'active',
        extras: { insurance: 'basic' },
        deposit_amount: 30000,
        deposit_returned: false,
      },
      {
        contract_number: 'RENT-2024-0150',
        company_id: companies[0].id,
        customer_id: customers[2].id,
        vehicle_id: vehicles[2].id,
        created_by: users[0].id,
        start_date: new Date('2024-12-20'),
        end_date: new Date('2024-12-27'),
        actual_return_date: new Date('2024-12-27'),
        daily_rate: 35000,
        total_days: 7,
        base_amount: 245000,
        additional_charges: 20000,
        discount_amount: 10000,
        tax_amount: 48450,
        total_amount: 303450,
        start_mileage: 34000,
        end_mileage: 34650,
        mileage_limit: 1000,
        status: 'completed',
        extras: { gps: true, insurance: 'premium' },
        deposit_amount: 60000,
        deposit_returned: true,
      },
    ]);
    console.log(`âœ… Created ${contracts.length} contracts`);

    // ============================================
    // 6. CREATE PAYMENTS
    // ============================================
    const payments = await Payment.bulkCreate([
      {
        company_id: companies[0].id,
        contract_id: contracts[0].id,
        customer_id: customers[0].id,
        amount: 226100,
        payment_method: 'card',
        payment_date: new Date('2025-01-08'),
        status: 'completed',
      },
      {
        company_id: companies[0].id,
        contract_id: contracts[1].id,
        customer_id: customers[1].id,
        amount: 90000,
        payment_method: 'cash',
        payment_date: new Date('2025-01-10'),
        status: 'completed',
      },
      {
        company_id: companies[0].id,
        contract_id: contracts[2].id,
        customer_id: customers[2].id,
        amount: 303450,
        payment_method: 'bank_transfer',
        payment_date: new Date('2024-12-27'),
        status: 'completed',
      },
    ]);
    console.log(`âœ… Created ${payments.length} payments`);

    // ============================================
    // 7. CREATE VEHICLE COSTS
    // ============================================
    const vehicleCosts = await VehicleCost.bulkCreate([
      {
        vehicle_id: vehicles[0].id,
        cost_type: 'maintenance',
        amount: 20000,
        incurred_date: new Date('2024-11-15'),
        description: 'Oil change + filters',
      },
      {
        vehicle_id: vehicles[1].id,
        cost_type: 'insurance',
        amount: 50000,
        incurred_date: new Date('2024-12-01'),
        description: 'Annual insurance premium',
      },
      {
        vehicle_id: vehicles[2].id,
        cost_type: 'repair',
        amount: 80000,
        incurred_date: new Date('2025-01-05'),
        description: 'Brake replacement',
      },
    ]);
    console.log(`âœ… Created ${vehicleCosts.length} vehicle costs`);

    // ============================================
    // 8. CREATE EMPLOYEES
    // ============================================
    const employees = await Employee.bulkCreate([
      {
        company_id: companies[0].id,
        full_name: 'Nadia Receptionist',
        email: 'nadia@eliterentals.com',
        phone: '+213 777 1111',
        position: 'Receptionist',
        salary: 60000,
        hire_date: new Date('2023-05-01'),
      },
      {
        company_id: companies[0].id,
        full_name: 'Youssef Mechanic',
        email: 'youssef@eliterentals.com',
        phone: '+213 777 2222',
        position: 'Mechanic',
        salary: 80000,
        hire_date: new Date('2023-07-15'),
      },
      {
        company_id: companies[1].id,
        full_name: 'Samir Sales',
        email: 'samir@speedmotors.com',
        phone: '+213 777 3333',
        position: 'Sales Manager',
        salary: 120000,
        hire_date: new Date('2024-02-01'),
      },
    ]);
    console.log(`âœ… Created ${employees.length} employees`);

    console.log('\nðŸŽ‰ Demo data generation completed successfully!');
    console.log('\nðŸ“Š Summary:');
    console.log(`   - Companies: ${companies.length}`);
    console.log(`   - Users: ${users.length}`);
    console.log(`   - Customers: ${customers.length}`);
    console.log(`   - Vehicles: ${vehicles.length}`);
    console.log(`   - Contracts: ${contracts.length}`);
    console.log(`   - Payments: ${payments.length}`);
    console.log(`   - Vehicle Costs: ${vehicleCosts.length}`);
    console.log(`   - Employees: ${employees.length}`);
    console.log('\nâœ… You can now start the server with: npm start');
    
    process.exit(0);
  } catch (error) {
    console.error('âŒ Error generating demo data:', error);
    process.exit(1);
  }
}

generateDemoData();

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\scripts\migrate.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\scripts\seed.js



// [Folder] src


//   [Folder] config


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\config\constants.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\config\database.js
const { Sequelize } = require('sequelize');
require('dotenv').config();

const sequelize = new Sequelize(
  process.env.DB_NAME,
  process.env.DB_USER,
  process.env.DB_PASSWORD,
  {
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    logging: process.env.NODE_ENV === 'development' ? console.log : false,
    pool: {
      max: 10,
      min: 0,
      acquire: 30000,
      idle: 10000,
    },
    define: {
      timestamps: true,
      underscored: false,
      createdAt: 'created_at',
      updatedAt: 'updated_at',
    },
  }
);

// Test connection
const testConnection = async () => {
  try {
    await sequelize.authenticate();
    console.log('âœ… Database connection established successfully.');
  } catch (error) {
    console.error('âŒ Unable to connect to database:', error);
    process.exit(1);
  }
};

module.exports = { sequelize, testConnection };

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\config\env.js



//   [Folder] controllers


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\controllers\admin.controller.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\controllers\analytics.controller.js
// src/controllers/analytics.controller.js
const analyticsService = require('../services/analytics.service');
const { sendSuccess, sendError } = require('../utils/response.util');
const { query, validationResult } = require('express-validator');

/**
 * Helper: Parse date range from query params with defaults
 */
const parseDateRange = (req) => {
  const { start_date, end_date, period = 'month' } = req.query;
  
  let startDate, endDate;
  
  if (start_date && end_date) {
    startDate = new Date(start_date);
    endDate = new Date(end_date);
  } else {
    // Default based on period
    endDate = new Date();
    startDate = new Date();
    
    switch (period) {
      case 'today':
        startDate.setHours(0, 0, 0, 0);
        break;
      case 'week':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case 'month':
        startDate.setMonth(startDate.getMonth() - 1);
        break;
      case 'quarter':
        startDate.setMonth(startDate.getMonth() - 3);
        break;
      case 'year':
        startDate.setFullYear(startDate.getFullYear() - 1);
        break;
      default:
        startDate.setMonth(startDate.getMonth() - 1);
    }
  }
  
  return { startDate, endDate };
};

// ============================================
// GET /api/analytics/dashboard - Dashboard KPIs
// ============================================
const getDashboard = [
  query('period').optional().isIn(['today', 'week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const companyId = req.companyId;

      console.log(`ðŸ“Š Fetching dashboard for company ${companyId} from ${startDate} to ${endDate}`);

      const dashboardData = await analyticsService.getDashboardKPIs(
        companyId,
        startDate,
        endDate
      );

      sendSuccess(res, {
        message: 'Dashboard KPIs fetched successfully',
        data: dashboardData,
      });
    } catch (error) {
      console.error('ðŸ’¥ Get dashboard error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch dashboard data',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/revenue - Revenue Analytics
// ============================================
const getRevenue = [
  query('period').optional().isIn(['today', 'week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  query('compare').optional().isBoolean(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const { compare = 'false' } = req.query;
      const companyId = req.companyId;

      console.log(`ðŸ’° Fetching revenue for company ${companyId}`);

      let revenueData;
      
      if (compare === 'true') {
        // Get revenue with comparison to previous period
        revenueData = await analyticsService.getRevenueComparison(
          companyId,
          startDate,
          endDate
        );
      } else {
        // Get revenue for current period only
        revenueData = await analyticsService.calculateRevenue(
          companyId,
          startDate,
          endDate
        );
      }

      sendSuccess(res, {
        message: 'Revenue analytics fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          ...revenueData,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get revenue error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch revenue analytics',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/vehicles - Vehicle Performance
// ============================================
const getVehiclePerformance = [
  query('period').optional().isIn(['today', 'week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  query('metric').optional().isIn(['utilization', 'revenue', 'profit']),
  query('limit').optional().isInt({ min: 1, max: 100 }),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const { metric = 'utilization', limit = 10 } = req.query;
      const companyId = req.companyId;

      console.log(`ðŸš— Fetching vehicle performance for company ${companyId}`);

      let vehicleData;

      switch (metric) {
        case 'profit':
          // Get profit/loss analysis
          vehicleData = await analyticsService.calculateVehicleProfitLoss(
            companyId,
            startDate,
            endDate
          );
          vehicleData = vehicleData.slice(0, parseInt(limit));
          break;
          
        case 'revenue':
          // Get top revenue generators
          const utilization = await analyticsService.calculateVehicleUtilization(
            companyId,
            startDate,
            endDate
          );
          vehicleData = utilization
            .sort((a, b) => b.total_revenue - a.total_revenue)
            .slice(0, parseInt(limit));
          break;
          
        case 'utilization':
        default:
          // Get top utilized vehicles
          vehicleData = await analyticsService.getTopPerformingVehicles(
            companyId,
            startDate,
            endDate,
            parseInt(limit)
          );
          break;
      }

      // Calculate fleet summary
      const allVehicles = await analyticsService.calculateVehicleUtilization(
        companyId,
        startDate,
        endDate
      );

      const fleetSummary = {
        total_vehicles: allVehicles.length,
        average_utilization: allVehicles.reduce((sum, v) => sum + v.utilization_rate, 0) / allVehicles.length,
        total_revenue: allVehicles.reduce((sum, v) => sum + v.total_revenue, 0),
        total_rentals: allVehicles.reduce((sum, v) => sum + v.rental_count, 0),
      };

      sendSuccess(res, {
        message: 'Vehicle performance analytics fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          metric: metric,
          fleet_summary: fleetSummary,
          vehicles: vehicleData,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get vehicle performance error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch vehicle performance',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/vehicles/utilization - Detailed Utilization
// ============================================
const getVehicleUtilization = [
  query('period').optional().isIn(['today', 'week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  query('vehicle_id').optional().isUUID(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const { vehicle_id } = req.query;
      const companyId = req.companyId;

      console.log(`ðŸ“Š Fetching utilization for company ${companyId}`);

      const utilization = await analyticsService.calculateVehicleUtilization(
        companyId,
        startDate,
        endDate
      );

      // Filter by vehicle if specified
      const filteredData = vehicle_id
        ? utilization.filter(v => v.vehicle_id === vehicle_id)
        : utilization;

      sendSuccess(res, {
        message: 'Vehicle utilization fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          vehicles: filteredData,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get vehicle utilization error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch vehicle utilization',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/vehicles/profit-loss - P&L Analysis
// ============================================
const getVehicleProfitLoss = [
  query('period').optional().isIn(['month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const companyId = req.companyId;

      console.log(`ðŸ’µ Fetching P&L for company ${companyId}`);

      const profitLoss = await analyticsService.calculateVehicleProfitLoss(
        companyId,
        startDate,
        endDate
      );

      // Calculate totals
      const totals = {
        total_revenue: profitLoss.reduce((sum, v) => sum + v.total_revenue, 0),
        total_costs: profitLoss.reduce((sum, v) => sum + v.total_costs, 0),
        total_profit: profitLoss.reduce((sum, v) => sum + v.profit, 0),
      };

      totals.profit_margin = totals.total_revenue > 0
        ? (totals.total_profit / totals.total_revenue) * 100
        : 0;

      sendSuccess(res, {
        message: 'Vehicle profit/loss analytics fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          totals,
          vehicles: profitLoss,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get vehicle P&L error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch vehicle profit/loss',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/customers - Customer Analytics
// ============================================
const getCustomerAnalytics = [
  query('period').optional().isIn(['week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const companyId = req.companyId;

      console.log(`ðŸ‘¥ Fetching customer analytics for company ${companyId}`);

      // Get segmentation and retention in parallel
      const [segmentation, retention] = await Promise.all([
        analyticsService.segmentCustomers(companyId),
        analyticsService.getCustomerRetention(companyId, startDate, endDate),
      ]);

      sendSuccess(res, {
        message: 'Customer analytics fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          segmentation,
          retention,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get customer analytics error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch customer analytics',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/customers/segmentation - Customer Segments
// ============================================
const getCustomerSegmentation = async (req, res) => {
  try {
    const companyId = req.companyId;

    console.log(`ðŸŽ¯ Fetching customer segmentation for company ${companyId}`);

    const segmentation = await analyticsService.segmentCustomers(companyId);

    sendSuccess(res, {
      message: 'Customer segmentation fetched successfully',
      data: segmentation,
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customer segmentation error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch customer segmentation',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/analytics/customers/retention - Retention Metrics
// ============================================
const getCustomerRetention = [
  query('period').optional().isIn(['week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const companyId = req.companyId;

      console.log(`ðŸ”„ Fetching customer retention for company ${companyId}`);

      const retention = await analyticsService.getCustomerRetention(
        companyId,
        startDate,
        endDate
      );

      sendSuccess(res, {
        message: 'Customer retention metrics fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          ...retention,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get customer retention error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch customer retention',
        details: error.message,
      });
    }
  },
];

module.exports = {
  getDashboard,
  getRevenue,
  getVehiclePerformance,
  getVehicleUtilization,
  getVehicleProfitLoss,
  getCustomerAnalytics,
  getCustomerSegmentation,
  getCustomerRetention,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\controllers\auth.controller.js
// src/controllers/auth.controller.js
const { User, Company } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { hashPassword, comparePassword } = require('../utils/bcrypt.util');
const { generateTokens, verifyRefreshToken } = require('../utils/jwt.util');
const { body, validationResult } = require('express-validator'); // For input validation

// In-memory blacklist for refresh tokens (dev only; use Redis in prod)
const tokenBlacklist = new Set();

// POST /api/auth/register - Create new user
const register = [
  // Validators
  body('full_name').notEmpty().withMessage('Full name is required'),
  body('email').isEmail().withMessage('Valid email required').normalizeEmail(),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 chars'),
  body('company_id').isUUID().withMessage('Valid company ID required'),
  body('role').optional().isIn(['owner', 'admin', 'manager', 'staff', 'viewer']).withMessage('Invalid role'),

  async (req, res) => {
    try {
      // Check validation
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { full_name, email, password, company_id, role = 'staff' } = req.body;

      // Check if company exists
      const company = await Company.findByPk(company_id);
      if (!company) {
        return sendError(res, { statusCode: 404, message: 'Company not found' });
      }

      // Check if user already exists
      const existingUser = await User.findOne({ where: { email } });
      if (existingUser) {
        return sendError(res, { statusCode: 409, message: 'Email already registered' });
      }

      // Hash password and create user
      const passwordHash = await hashPassword(password);
      const user = await User.create({
        full_name,
        email,
        password_hash: passwordHash, // Bypasses model hook for explicit hashing
        company_id,
        role,
        is_active: true,
      });
      console.log('ðŸ‘¤ New user registered for company:', company_id, 'as', role);

      // Don't return password in response
      const { password_hash, ...userData } = user.toJSON();

      sendSuccess(res, {
        statusCode: 201,
        message: 'User registered successfully',
        data: { user: userData },
      });
    } catch (error) {
      sendError(res, { statusCode: 500, message: 'Registration failed', details: error.message });
    }
  },
];

// POST /api/auth/login - Login & get tokens
const login = [
  // Validators (same)
  body('email').isEmail().withMessage('Valid email required').normalizeEmail(),
  body('password').notEmpty().withMessage('Password required'),

  async (req, res) => {
    try {
      console.log('ðŸ”‘ Login attempt for email:', req.body.email); // Log 1: Incoming request

      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        console.log('âŒ Login validation errors:', errors.array()); // Log validation fails
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { email, password } = req.body;

      // Find user
      const user = await User.findOne({ where: { email } });
      console.log('ðŸ” User found?', !!user); // Log 2: User exists?
      if (!user || !user.is_active) {
        console.log('ðŸš« Invalid credentials for:', email);
        return sendError(res, { statusCode: 401, message: 'Invalid credentials' });
      }

      // Compare password
      const isMatch = await comparePassword(password, user.password_hash);
      console.log('ðŸ”’ Password match?', isMatch); // Log 3: Password correct?
      if (!isMatch) {
        console.log('ðŸš« Password mismatch for:', email);
        return sendError(res, { statusCode: 401, message: 'Invalid credentials' });
      }

      // Generate tokens
      const tokens = generateTokens(user);

      // Update last login
      await user.update({ last_login_at: new Date() });

      const { password_hash, ...userData } = user.toJSON();

      console.log('âœ… Login success for:', email); // Log 4: All good
      sendSuccess(res, {
        message: 'Login successful',
        data: { user: userData, ...tokens },
      });
    } catch (error) {
      console.error('ðŸ’¥ Login error:', error); // Log 5: Any crash
      sendError(res, { statusCode: 500, message: 'Login failed', details: error.message });
    }
  },
];

// GET /api/auth/me - Get current user (protected)
const getMe = async (req, res) => {
  try {
    // req.user from middleware, but fetch fresh from DB for full details
    const user = await User.findByPk(req.user.id, {
      attributes: { exclude: ['password_hash'] }, // Hide sensitive fields
    });

    if (!user) {
      return sendError(res, { statusCode: 404, message: 'User not found' });
    }

    sendSuccess(res, { message: 'User profile fetched', data: { user: user.toJSON() } });
  } catch (error) {
    sendError(res, { statusCode: 500, message: 'Failed to fetch profile', details: error.message });
  }
};

// POST /api/auth/logout - Blacklist refresh token
const logout = async (req, res) => {
  try {
    const authHeader = req.headers['authorization'];
    const refreshToken = req.body.refresh_token || (authHeader && authHeader.split(' ')[1]); // Accept in body or header

    if (!refreshToken) {
      return sendError(res, { statusCode: 400, message: 'Refresh token required' });
    }

    // Blacklist it
    tokenBlacklist.add(refreshToken);

    sendSuccess(res, { message: 'Logged out successfully' });
  } catch (error) {
    sendError(res, { statusCode: 500, message: 'Logout failed', details: error.message });
  }
};

// POST /api/auth/refresh - Get new access token
const refresh = [
  body('refresh_token').notEmpty().withMessage('Refresh token required'),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { refresh_token } = req.body;

      // Check blacklist
      if (tokenBlacklist.has(refresh_token)) {
        return sendError(res, { statusCode: 401, message: 'Token has been revoked' });
      }

      // Verify refresh token
      const decoded = verifyRefreshToken(refresh_token);
      const user = await User.findByPk(decoded.id);

      if (!user || !user.is_active) {
        return sendError(res, { statusCode: 401, message: 'User inactive or not found' });
      }

      // Generate new access token (keep same refresh)
      const { accessToken } = generateTokens(user);

      sendSuccess(res, {
        message: 'Token refreshed',
        data: { accessToken },
      });
    } catch (error) {
      sendError(res, { statusCode: 401, message: error.message || 'Invalid refresh token' });
    }
  },
];

module.exports = {
  register,
  login,
  getMe,
  logout,
  refresh,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\controllers\company.controller.js
const { Company } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');

// POST /api/companies - Create new company (public for signup)
const createCompany = [
  // Validators
  body('name').notEmpty().withMessage('Company name required'),
  body('email').isEmail().withMessage('Valid email required').normalizeEmail(),
  body('phone').optional().isMobilePhone('ar-DZ'), // Algerian format
  body('subscription_plan').optional().isIn(['basic', 'professional', 'enterprise']),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { name, email, phone, subscription_plan = 'basic', subscription_status = 'trial' } = req.body;

      // Check if company with email exists
      const existing = await Company.findOne({ where: { email } });
      if (existing) {
        return sendError(res, { statusCode: 409, message: 'Company with this email already exists' });
      }

      const company = await Company.create({
        name,
        email,
        phone,
        subscription_plan,
        subscription_status,
        subscription_start_date: new Date(),
        trial_ends_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days trial
      });

      // Convert to plain object
      const companyJson = company.toJSON();
      
      // DEBUG: Log everything
      console.log('ðŸ¢ DEBUG - Raw company.toJSON():', companyJson);
      console.log('ðŸ¢ DEBUG - company.id:', company.id);
      console.log('ðŸ¢ DEBUG - companyJson.id:', companyJson.id);

      // Remove sensitive fields but keep ID intact
      const { settings, ...safeCompany } = companyJson;

      console.log('ðŸ¢ DEBUG - safeCompany.id:', safeCompany.id);
      console.log('ðŸ¢ DEBUG - About to send response with company:', safeCompany);

      console.log('ðŸ¢ New company created:', name, 'with ID:', company.id);
      
      sendSuccess(res, {
        statusCode: 201,
        message: 'Company created successfully',
        data: { company: safeCompany },
      });
    } catch (error) {
      console.error('ðŸ’¥ Company creation error:', error);
      sendError(res, { statusCode: 500, message: 'Failed to create company', details: error.message });
    }
  },
];

// GET /api/company/profile - Get company details (protected)
const getProfile = async (req, res) => {
  try {
    const { company_id } = req.user; // From authenticated user
    console.log('ðŸ¢ Fetching profile for company_id:', company_id);

    const company = await Company.findByPk(company_id, {
      attributes: { exclude: ['settings'] }, // Hide settings for security; fetch separately if needed
    });

    if (!company) {
      console.log('ðŸš« Company not found:', company_id);
      return sendError(res, { statusCode: 404, message: 'Company not found' });
    }

    // Convert to plain object and exclude settings
    const { settings, ...safeCompany } = company.toJSON();
    console.log('ðŸ¢ Profile fetched for:', safeCompany.name);

    sendSuccess(res, {
      message: 'Company profile fetched successfully',
      data: { company: safeCompany },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get company profile error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to fetch company profile', details: error.message });
  }
};

// PUT /api/company/profile - Update company info (protected)
const updateProfile = [
  // Validators for updatable fields
  body('name').optional().notEmpty().withMessage('Company name required'),
  body('email').optional().isEmail().withMessage('Valid email required').normalizeEmail(),
  body('phone').optional().isLength({ min: 10, max: 15 }).withMessage('Phone must be 10-15 digits'),
  body('address').optional().isLength({ max: 500 }).withMessage('Address too long'),
  body('tax_id').optional().isLength({ max: 100 }).withMessage('Tax ID too long'),
  // Fix: Allow falsy (empty) values for optional URL
  body('logo_url').optional({ checkFalsy: true }).isURL().withMessage('Valid URL required'),
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { company_id } = req.user;
      const updateData = req.body; // Only validated fields will be present
      console.log('ðŸ¢ Updating profile for company_id:', company_id, 'with:', updateData);

      // If email is provided and changed, check uniqueness
      if (updateData.email) {
        const existingCompany = await Company.findOne({ where: { email: updateData.email } });
        if (existingCompany && existingCompany.id !== company_id) {
          return sendError(res, { statusCode: 409, message: 'Email already in use by another company' });
        }
      }

      // Update company
      const [updatedRows, [company]] = await Company.update(updateData, {
        where: { id: company_id },
        returning: true, // Sequelize option to return updated record
      });

      if (updatedRows === 0) {
        return sendError(res, { statusCode: 404, message: 'Company not found' });
      }

      // Exclude settings from response
      const { settings, ...safeCompany } = company.toJSON();
      console.log('ðŸ¢ Profile updated for:', safeCompany.name);

      sendSuccess(res, {
        message: 'Company profile updated successfully',
        data: { company: safeCompany },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update company profile error:', error);
      sendError(res, { statusCode: 500, message: 'Failed to update company profile', details: error.message });
    }
  },
];

// PUT /api/company/settings - Update company settings (protected)
const updateSettings = [
  // Validator for settings (must be object)
  body('settings').optional().isObject().withMessage('Settings must be a valid JSON object'),
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { company_id } = req.user;
      const { settings } = req.body;
      console.log('ðŸ¢ Updating settings for company_id:', company_id, 'with:', settings);

      // Fetch existing company to merge settings (or overwrite if preferred)
      const company = await Company.findByPk(company_id);
      if (!company) {
        return sendError(res, { statusCode: 404, message: 'Company not found' });
      }

      // Merge with existing (add this if you want to preserve unset fields; else just set new)
      const newSettings = { ...company.settings, ...settings };

      // Update only settings
      await company.update({ settings: newSettings });
      // Reload to get fresh instance
      await company.reload();

      // Return updated company without full settings in response (or include if needed)
      const { settings: _, ...safeCompany } = company.toJSON(); // Hide settings
      console.log('ðŸ”§ Settings updated for:', safeCompany.name);

      sendSuccess(res, {
        message: 'Company settings updated successfully',
        data: { company: safeCompany },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update company settings error:', error);
      sendError(res, { statusCode: 500, message: 'Failed to update company settings', details: error.message });
    }
  },
];

module.exports = {
  createCompany,
  getProfile,
  updateProfile,
  updateSettings,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\controllers\contract.controller.js
// src/controllers/contract.controller.js
const { Contract, Customer, Vehicle, User, Payment, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');

// ============================================
// HELPER: Generate contract number (atomic with uniqueness check)
// ============================================
const generateContractNumber = async (companyId, transaction) => {
  const year = new Date().getFullYear();
  const yearPrefix = `RENT-${year}-`;

  // Find the highest existing number for this year/company
  const maxContract = await Contract.findOne({
    where: {
      company_id: companyId,
      contract_number: { [Op.like]: `${yearPrefix}%` },
    },
    order: [['contract_number', 'DESC']], // Sort by contract_number DESC for max
    transaction, // Use transaction for isolation
  });

  let nextNumber = 1;
  if (maxContract) {
    nextNumber = parseInt(maxContract.contract_number.split('-')[2]) + 1;
  }

  // Loop to ensure uniqueness (handles races/stale data)
  let contractNumber;
  do {
    contractNumber = `${yearPrefix}${String(nextNumber).padStart(4, '0')}`;
    const exists = await Contract.findOne({
      where: {
        company_id: companyId,
        contract_number: contractNumber,
      },
      transaction, // Use transaction
    });
    if (!exists) break;
    nextNumber++;
  } while (true);

  return contractNumber;
};

// ============================================
// HELPER: Calculate contract totals
// ============================================
const calculateContractTotals = (data) => {
  // Parse strings to numbers safely (fixes the concat bug)
  const dailyRate = parseFloat(data.daily_rate) || 0;
  const additionalCharges = parseFloat(data.additional_charges || 0);
  const discountAmount = parseFloat(data.discount_amount || 0);

  const startDate = new Date(data.start_date);
  const endDate = new Date(data.end_date);
  const totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;
  
  if (totalDays <= 0) {
    throw new Error('Invalid date range: end date must be after start date');
  }

  const baseAmount = dailyRate * totalDays;
  const subtotal = baseAmount + additionalCharges - discountAmount;
  const taxAmount = subtotal * 0.19; // 19% tax
  const totalAmount = subtotal + taxAmount;

  return {
    total_days: totalDays,
    base_amount: baseAmount,
    tax_amount: taxAmount,
    total_amount: totalAmount,
  };
};

// ============================================
// GET /api/contracts - List all contracts
// ============================================
const getAllContracts = async (req, res) => {
  try {
    const {
      status,
      customer_id,
      vehicle_id,
      start_date,
      end_date,
      search,
      page = 1,
      limit = 20,
      sort_by = 'created_at',
      sort_order = 'DESC',
    } = req.query;

    // Build filter with tenant isolation
    const whereClause = applyTenantFilter(req);

    // Apply filters
    if (status) whereClause.status = status;
    if (customer_id) whereClause.customer_id = customer_id;
    if (vehicle_id) whereClause.vehicle_id = vehicle_id;

    // Date range filter
    if (start_date || end_date) {
      whereClause.start_date = {};
      if (start_date) whereClause.start_date[Op.gte] = start_date;
      if (end_date) whereClause.start_date[Op.lte] = end_date;
    }

    // Search by contract number
    if (search) {
      whereClause.contract_number = { [Op.iLike]: `%${search}%` };
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch contracts with relations
    const { count, rows: contracts } = await Contract.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: Customer,
          as: 'customer',
          attributes: ['id', 'full_name', 'email', 'phone', 'customer_type'],
        },
        {
          model: Vehicle,
          as: 'vehicle',
          attributes: ['id', 'brand', 'model', 'year', 'registration_number', 'status'],
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'full_name', 'email'],
        },
      ],
      limit: parseInt(limit),
      offset: offset,
      order: [[sort_by, sort_order.toUpperCase()]],
    });

    console.log(`ðŸ“‹ Fetched ${contracts.length} contracts for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Contracts fetched successfully',
      data: { contracts },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get contracts error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch contracts',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/contracts/:id - Get single contract
// ============================================
const getContractById = async (req, res) => {
  try {
    const { id } = req.params;

    const contract = await Contract.findOne({
      where: applyTenantFilter(req, { id }),
      include: [
        {
          model: Customer,
          as: 'customer',
        },
        {
          model: Vehicle,
          as: 'vehicle',
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'full_name', 'email'],
        },
        {
          model: Payment,
          as: 'payments',
        },
      ],
    });

    if (!contract) {
      return sendError(res, {
        statusCode: 404,
        message: 'Contract not found',
      });
    }

    console.log(`ðŸ“„ Contract fetched: ${contract.contract_number}`);

    sendSuccess(res, {
      message: 'Contract fetched successfully',
      data: { contract },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get contract error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch contract',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/contracts - Create new contract
// ============================================
const createContract = [
  // Validators
  body('customer_id').isUUID().withMessage('Valid customer ID required'),
  body('vehicle_id').isUUID().withMessage('Valid vehicle ID required'),
  body('start_date').isISO8601().withMessage('Valid start date required'),
  body('end_date').isISO8601().withMessage('Valid end date required'),
  body('daily_rate').isFloat({ min: 0 }).withMessage('Valid daily rate required'),
  body('deposit_amount').optional().isFloat({ min: 0 }),
  body('additional_charges').optional().isFloat({ min: 0 }),
  body('discount_amount').optional().isFloat({ min: 0 }),
  body('mileage_limit').optional().isInt({ min: 0 }),
  body('extras').optional().isObject(),
  body('notes').optional().trim(),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { customer_id, vehicle_id, start_date, end_date } = req.body;

      // Validate dates
      if (new Date(end_date) <= new Date(start_date)) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'End date must be after start date',
        });
      }

      // Check customer exists and is not blacklisted
      const customer = await Customer.findOne({
        where: applyTenantFilter(req, { id: customer_id }),
      });

      if (!customer) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Customer not found' });
      }

      if (customer.is_blacklisted) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 403,
          message: 'Cannot create contract for blacklisted customer',
        });
      }

      // Check vehicle exists and is available
      const vehicle = await Vehicle.findOne({
        where: applyTenantFilter(req, { id: vehicle_id }),
      });

      if (!vehicle) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Vehicle not found' });
      }

      if (vehicle.status !== 'available') {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: `Vehicle is not available (current status: ${vehicle.status})`,
        });
      }

      // Check for conflicting contracts
      const conflictingContract = await Contract.findOne({
        where: {
          vehicle_id,
          status: 'active',
          [Op.or]: [
            { start_date: { [Op.between]: [start_date, end_date] } },
            { end_date: { [Op.between]: [start_date, end_date] } },
            {
              [Op.and]: [
                { start_date: { [Op.lte]: start_date } },
                { end_date: { [Op.gte]: end_date } },
              ],
            },
          ],
        },
      });

      if (conflictingContract) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: 'Vehicle already has an active contract in this date range',
        });
      }

      // Generate contract number (pass transaction)
      const contractNumber = await generateContractNumber(req.companyId, transaction);

      // Calculate totals
      const totals = calculateContractTotals(req.body);

      // Create contract
      const contractData = applyTenantData(req, {
        ...req.body,
        contract_number: contractNumber,
        created_by: req.user.id,
        status: 'active',
        start_mileage: vehicle.mileage,
        ...totals,
      });

      const contract = await Contract.create(contractData, { transaction });

      // Update vehicle status
      await vehicle.update({ status: 'rented' }, { transaction });

      // Update customer stats
      await customer.update(
        {
          total_rentals: customer.total_rentals + 1,
          lifetime_value: parseFloat(customer.lifetime_value) + totals.total_amount,
        },
        { transaction }
      );

      await transaction.commit();

      // Fetch contract with relations
      const fullContract = await Contract.findByPk(contract.id, {
        include: [
          { model: Customer, as: 'customer' },
          { model: Vehicle, as: 'vehicle' },
          { model: User, as: 'creator', attributes: ['id', 'full_name'] },
        ],
      });

      console.log(`ðŸ“„ New contract created: ${contractNumber}`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Contract created successfully',
        data: { contract: fullContract },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Create contract error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to create contract',
        details: error.message,
      });
    }
  },
];

// ============================================
// PUT /api/contracts/:id - Update contract
// ============================================
const updateContract = [
  body('end_date').optional().isISO8601(),
  body('additional_charges').optional().isFloat({ min: 0 }),
  body('discount_amount').optional().isFloat({ min: 0 }),
  body('notes').optional().trim(),
  body('extras').optional().isObject(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;

      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id }),
      });

      if (!contract) {
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }

      // Only allow updates for active or draft contracts
      if (!['active', 'draft'].includes(contract.status)) {
        return sendError(res, {
          statusCode: 409,
          message: `Cannot update ${contract.status} contract`,
        });
      }

      // If updating end_date or charges, recalculate totals
      if (req.body.end_date || req.body.additional_charges !== undefined || req.body.discount_amount !== undefined) {
        const updateData = {
          start_date: contract.start_date,
          end_date: req.body.end_date || contract.end_date,
          daily_rate: contract.daily_rate,
          additional_charges: req.body.additional_charges ?? contract.additional_charges,
          discount_amount: req.body.discount_amount ?? contract.discount_amount,
        };

        const totals = calculateContractTotals(updateData);
        Object.assign(req.body, totals);
      }

      await contract.update(req.body);

      console.log(`ðŸ”„ Contract updated: ${contract.contract_number}`);

      sendSuccess(res, {
        message: 'Contract updated successfully',
        data: { contract },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update contract error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to update contract',
        details: error.message,
      });
    }
  },
];

// ============================================
// POST /api/contracts/:id/complete - Complete rental
// ============================================
const completeContract = [
  body('actual_return_date').isISO8601().withMessage('Valid return date required'),
  body('end_mileage').isInt({ min: 0 }).withMessage('Valid end mileage required'),
  body('additional_charges').optional().isFloat({ min: 0 }),
  body('notes').optional().trim(),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;
      const { actual_return_date, end_mileage, additional_charges, notes } = req.body;

      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id }),
        include: [{ model: Vehicle, as: 'vehicle' }],
      });

      if (!contract) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }

      if (contract.status !== 'active') {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: `Cannot complete ${contract.status} contract`,
        });
      }

      // Calculate mileage charges if exceeded
      const mileageDriven = end_mileage - contract.start_mileage;
      let mileageCharges = 0;

      if (contract.mileage_limit && mileageDriven > contract.mileage_limit) {
        const excessMileage = mileageDriven - contract.mileage_limit;
        const chargePerKm = contract.mileage_charge_per_km || 5; // Default 5 DZD per km
        mileageCharges = excessMileage * chargePerKm;
      }

      const totalAdditionalCharges = (additional_charges || 0) + mileageCharges;

      // Recalculate total if additional charges
      let updateData = {
        status: 'completed',
        actual_return_date,
        end_mileage,
        deposit_returned: true,
      };

      if (totalAdditionalCharges > 0) {
        updateData.additional_charges = parseFloat(contract.additional_charges) + totalAdditionalCharges;
        
        const totals = calculateContractTotals({
          start_date: contract.start_date,
          end_date: contract.end_date,
          daily_rate: contract.daily_rate,
          additional_charges: updateData.additional_charges,
          discount_amount: contract.discount_amount,
        });

        updateData = { ...updateData, ...totals };
      }

      if (notes) updateData.notes = notes;

      await contract.update(updateData, { transaction });

      // Update vehicle status and mileage
      await contract.vehicle.update(
        {
          status: 'available',
          mileage: end_mileage,
        },
        { transaction }
      );

      await transaction.commit();

      console.log(`âœ… Contract completed: ${contract.contract_number}`);

      sendSuccess(res, {
        message: 'Contract completed successfully',
        data: { contract },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Complete contract error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to complete contract',
        details: error.message,
      });
    }
  },
];

// ============================================
// POST /api/contracts/:id/cancel - Cancel contract
// ============================================
const cancelContract = [
  body('reason').optional().trim(),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const { id } = req.params;
      const { reason } = req.body;

      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id }),
        include: [
          { model: Vehicle, as: 'vehicle' },
          { model: Customer, as: 'customer' },
        ],
      });

      if (!contract) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }

      if (contract.status !== 'active') {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: `Cannot cancel ${contract.status} contract`,
        });
      }

      // Update contract
      await contract.update(
        {
          status: 'cancelled',
          notes: reason ? `${contract.notes || ''}\nCancellation reason: ${reason}` : contract.notes,
        },
        { transaction }
      );

      // Return vehicle to available
      await contract.vehicle.update({ status: 'available' }, { transaction });

      // Update customer stats (decrement)
      await contract.customer.update(
        {
          total_rentals: Math.max(0, contract.customer.total_rentals - 1),
          lifetime_value: Math.max(0, parseFloat(contract.customer.lifetime_value) - parseFloat(contract.total_amount)),
        },
        { transaction }
      );

      await transaction.commit();

      console.log(`âŒ Contract cancelled: ${contract.contract_number}`);

      sendSuccess(res, {
        message: 'Contract cancelled successfully',
        data: { contract },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Cancel contract error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to cancel contract',
        details: error.message,
      });
    }
  },
];

// ============================================
// POST /api/contracts/:id/extend - Extend rental
// ============================================
const extendContract = [
  body('new_end_date').isISO8601().withMessage('Valid new end date required'),
  body('notes').optional().trim(),
  async (req, res) => {
    const transaction = await sequelize.transaction(); // Add for safety
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }
      const { id } = req.params;
      const { new_end_date, notes } = req.body;
      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id }),
        include: [{ model: Vehicle, as: 'vehicle' }], // Load vehicle for ID
      });
      if (!contract) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }
      if (contract.status !== 'active') {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: `Cannot extend ${contract.status} contract`,
        });
      }
      // Validate new end date is after current end date
      if (new Date(new_end_date) <= new Date(contract.end_date)) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'New end date must be after current end date',
        });
      }
      // Check for conflicts (inside transaction)
      const conflictingContract = await Contract.findOne({
        where: {
          vehicle_id: contract.vehicle_id,
          status: 'active',
          id: { [Op.ne]: contract.id },
          start_date: { [Op.lte]: new_end_date },
          end_date: { [Op.gte]: new Date(contract.end_date) },
        },
        transaction,
      });
      if (conflictingContract) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: 'Cannot extend: vehicle has another booking during the extended period',
        });
      }
      // Recalculate totals (now safe with parsing)
      const totals = calculateContractTotals({
        start_date: contract.start_date,
        end_date: new_end_date,
        daily_rate: contract.daily_rate,
        additional_charges: contract.additional_charges,
        discount_amount: contract.discount_amount,
      });
      await contract.update({
        end_date: new_end_date,
        // status: 'extended',  // Removed: Keep as 'active'
        ...totals,
        notes: notes ? `${contract.notes || ''}\nExtended to ${new_end_date}: ${notes}` : contract.notes, // Clearer note
      }, { transaction });
      await transaction.commit();
      console.log(`ðŸ“… Contract extended: ${contract.contract_number}`);
      sendSuccess(res, {
        message: 'Contract extended successfully',
        data: { contract },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Extend contract error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to extend contract',
        details: error.message,
      });
    }
  },
];
// ============================================
// GET /api/contracts/stats - Get contract statistics
// ============================================
const getContractStats = async (req, res) => {
  try {
    const companyFilter = { company_id: req.companyId };
    // Total contracts
    const totalContracts = await Contract.count({ where: companyFilter });
    // By status
    const active = await Contract.count({ where: { ...companyFilter, status: 'active' } });
    const completed = await Contract.count({ where: { ...companyFilter, status: 'completed' } });
    const cancelled = await Contract.count({ where: { ...companyFilter, status: 'cancelled' } });
    // Revenue
    const revenueResult = await Contract.findOne({
      where: companyFilter,
      attributes: [
        [sequelize.fn('SUM', sequelize.col('total_amount')), 'total_revenue'],
      ],
      raw: true,
    });
    // Recent contracts (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const recentContracts = await Contract.count({
      where: {
        ...companyFilter,
        created_at: { [Op.gte]: thirtyDaysAgo },
      },
    });
    const stats = {
      total_contracts: totalContracts,
      by_status: { active, completed, cancelled }, // Removed extended
      total_revenue: parseFloat(revenueResult?.total_revenue || 0),
      recent_contracts_30d: recentContracts,
    };
    sendSuccess(res, {
      message: 'Contract statistics fetched successfully',
      data: { stats },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get contract stats error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch contract statistics',
      details: error.message,
    });
  }
};

module.exports = {
  getAllContracts,
  getContractById,
  createContract,
  updateContract,
  completeContract,
  cancelContract,
  extendContract,
  getContractStats,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\controllers\customer.controller.js
// src/controllers/customer.controller.js
const { Customer, Contract, Payment, Vehicle, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');

// ============================================
// GET /api/customers - List all customers (with filters & search)
// ============================================
const getAllCustomers = async (req, res) => {
  try {
    const {
      customer_type,
      is_blacklisted,
      search,
      page = 1,
      limit = 20,
      sort_by = 'created_at',
      sort_order = 'DESC',
    } = req.query;

    // Build filter object with tenant isolation
    const whereClause = applyTenantFilter(req);

    // Apply customer type filter
    if (customer_type) {
      whereClause.customer_type = customer_type;
    }

    // Apply blacklist filter
    if (is_blacklisted !== undefined) {
      whereClause.is_blacklisted = is_blacklisted === 'true';
    }

    // Apply search (name, email, phone, license)
    if (search) {
      whereClause[Op.or] = [
        { full_name: { [Op.iLike]: `%${search}%` } },
        { email: { [Op.iLike]: `%${search}%` } },
        { phone: { [Op.iLike]: `%${search}%` } },
        { drivers_license_number: { [Op.iLike]: `%${search}%` } },
        { company_name: { [Op.iLike]: `%${search}%` } },
      ];
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch customers
    const { count, rows: customers } = await Customer.findAndCountAll({
      where: whereClause,
      limit: parseInt(limit),
      offset: offset,
      order: [[sort_by, sort_order.toUpperCase()]],
      attributes: {
        exclude: ['id_card_photo_url', 'license_photo_url'], // Don't send photo URLs in list
      },
    });

    console.log(`ðŸ“‹ Fetched ${customers.length} customers for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Customers fetched successfully',
      data: { customers },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customers error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch customers',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/customers/:id - Get single customer with full details
// ============================================
const getCustomerById = async (req, res) => {
  try {
    const { id } = req.params;

    const customer = await Customer.findOne({
      where: applyTenantFilter(req, { id }),
    });

    if (!customer) {
      return sendError(res, {
        statusCode: 404,
        message: 'Customer not found',
      });
    }

    console.log(`ðŸ‘¤ Customer fetched: ${customer.full_name}`);

    sendSuccess(res, {
      message: 'Customer fetched successfully',
      data: { customer },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customer error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch customer',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/customers/:id/history - Get customer rental history
// ============================================
const getCustomerHistory = async (req, res) => {
  try {
    const { id: customer_id } = req.params;
    const { status, start_date, end_date, page = 1, limit = 10 } = req.query;

    // Check if customer exists and belongs to company
    const customer = await Customer.findOne({
      where: applyTenantFilter(req, { id: customer_id }),
    });

    if (!customer) {
      return sendError(res, {
        statusCode: 404,
        message: 'Customer not found',
      });
    }

    // Build filter for contracts
    const whereClause = {
      customer_id,
      company_id: req.companyId, // Ensure tenant isolation
    };

    if (status) {
      whereClause.status = status;
    }

    if (start_date || end_date) {
      whereClause.start_date = {};
      if (start_date) whereClause.start_date[Op.gte] = start_date;
      if (end_date) whereClause.start_date[Op.lte] = end_date;
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch contracts with vehicle and payment details
    const { count, rows: contracts } = await Contract.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: Vehicle,
          as: 'vehicle',
          attributes: ['id', 'brand', 'model', 'year', 'registration_number'],
        },
        {
          model: Payment,
          as: 'payments',
          attributes: ['id', 'amount', 'payment_method', 'payment_date', 'status'],
        },
      ],
      limit: parseInt(limit),
      offset: offset,
      order: [['start_date', 'DESC']],
    });

    // Calculate statistics
    const stats = {
      total_contracts: count,
      total_spent: contracts.reduce((sum, c) => sum + parseFloat(c.total_amount || 0), 0),
      completed_contracts: contracts.filter(c => c.status === 'completed').length,
      active_contracts: contracts.filter(c => c.status === 'active').length,
    };

    console.log(`ðŸ“œ Fetched ${contracts.length} contracts for customer ${customer_id}`);

    sendSuccess(res, {
      message: 'Customer rental history fetched successfully',
      data: { 
        customer: {
          id: customer.id,
          full_name: customer.full_name,
          email: customer.email,
          phone: customer.phone,
        },
        contracts,
        stats,
      },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customer history error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch customer history',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/customers - Create new customer
// ============================================
const createCustomer = [
  // Validators
  body('customer_type').isIn(['individual', 'corporate']).withMessage('Valid customer type required'),
  body('full_name').notEmpty().withMessage('Full name is required').trim(),
  body('company_name').optional().trim(),
  body('email').optional().isEmail().withMessage('Valid email required').normalizeEmail(),
  body('phone').notEmpty().withMessage('Phone is required').trim(),
  body('address').optional().trim(),
  body('city').optional().trim(),
  body('date_of_birth').optional().isISO8601().withMessage('Valid date required'),
  body('id_card_number').optional().trim(),
  body('drivers_license_number').optional().trim(),
  body('license_expiry_date').optional().isISO8601().withMessage('Valid date required'),
  body('emergency_contact_name').optional().trim(),
  body('emergency_contact_phone').optional().trim(),
  body('notes').optional().trim(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      // Check if license number already exists (if provided)
      if (req.body.drivers_license_number) {
        const existingCustomer = await Customer.findOne({
          where: { drivers_license_number: req.body.drivers_license_number },
        });

        if (existingCustomer) {
          return sendError(res, {
            statusCode: 409,
            message: 'Customer with this license number already exists',
          });
        }
      }

      // Apply tenant data (adds company_id automatically)
      const customerData = applyTenantData(req, req.body);

      const customer = await Customer.create(customerData);

      console.log(`ðŸ‘¤ New customer created: ${customer.full_name} (${customer.customer_type})`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Customer created successfully',
        data: { customer },
      });
    } catch (error) {
      console.error('ðŸ’¥ Create customer error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to create customer',
        details: error.message,
      });
    }
  },
];

// ============================================
// PUT /api/customers/:id - Update customer
// ============================================
const updateCustomer = [
  // Validators (all optional for update)
  body('customer_type').optional().isIn(['individual', 'corporate']),
  body('full_name').optional().notEmpty().trim(),
  body('company_name').optional().trim(),
  body('email').optional().isEmail().normalizeEmail(),
  body('phone').optional().notEmpty().trim(),
  body('address').optional().trim(),
  body('city').optional().trim(),
  body('date_of_birth').optional().isISO8601(),
  body('drivers_license_number').optional().trim(),
  body('license_expiry_date').optional().isISO8601(),
  body('is_blacklisted').optional().isBoolean(),
  body('notes').optional().trim(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;

      // Check if customer exists and belongs to company
      const customer = await Customer.findOne({
        where: applyTenantFilter(req, { id }),
      });

      if (!customer) {
        return sendError(res, {
          statusCode: 404,
          message: 'Customer not found',
        });
      }

      // If license number is being updated, check uniqueness
      if (req.body.drivers_license_number && req.body.drivers_license_number !== customer.drivers_license_number) {
        const existingCustomer = await Customer.findOne({
          where: { drivers_license_number: req.body.drivers_license_number },
        });

        if (existingCustomer) {
          return sendError(res, {
            statusCode: 409,
            message: 'Customer with this license number already exists',
          });
        }
      }

      // Update customer
      await customer.update(req.body);

      console.log(`ðŸ”„ Customer updated: ${customer.full_name}`);

      sendSuccess(res, {
        message: 'Customer updated successfully',
        data: { customer },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update customer error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to update customer',
        details: error.message,
      });
    }
  },
];

// ============================================
// DELETE /api/customers/:id - Delete customer
// ============================================
const deleteCustomer = async (req, res) => {
  try {
    const { id } = req.params;

    // Check if customer exists and belongs to company
    const customer = await Customer.findOne({
      where: applyTenantFilter(req, { id }),
    });

    if (!customer) {
      return sendError(res, {
        statusCode: 404,
        message: 'Customer not found',
      });
    }

    // Check if customer has active contracts
    const activeContracts = await Contract.count({
      where: {
        customer_id: id,
        status: 'active',
      },
    });

    if (activeContracts > 0) {
      return sendError(res, {
        statusCode: 409,
        message: 'Cannot delete customer with active contracts',
      });
    }

    // Instead of hard delete, you could soft-delete by setting a flag
    // For now, we'll do a hard delete but you can modify this
    await customer.destroy();

    console.log(`ðŸ—‘ï¸ Customer deleted: ${customer.full_name}`);

    sendSuccess(res, {
      message: 'Customer deleted successfully',
      data: { id },
    });
  } catch (error) {
    console.error('ðŸ’¥ Delete customer error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to delete customer',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/customers/stats - Get customer statistics
// ============================================
const getCustomerStats = async (req, res) => {
  try {
    const companyFilter = { company_id: req.companyId };

    // Get total customers
    const totalCustomers = await Customer.count({ where: companyFilter });

    // Get customers by type
    const individual = await Customer.count({ 
      where: { ...companyFilter, customer_type: 'individual' } 
    });
    const corporate = await Customer.count({ 
      where: { ...companyFilter, customer_type: 'corporate' } 
    });

    // Get blacklisted customers
    const blacklisted = await Customer.count({ 
      where: { ...companyFilter, is_blacklisted: true } 
    });

    // Get top customers by lifetime value
    const topCustomers = await Customer.findAll({
      where: companyFilter,
      order: [['lifetime_value', 'DESC']],
      limit: 5,
      attributes: ['id', 'full_name', 'email', 'total_rentals', 'lifetime_value'],
    });

    // Get recent customers (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    const recentCustomers = await Customer.count({
      where: {
        ...companyFilter,
        created_at: { [Op.gte]: thirtyDaysAgo },
      },
    });

    const stats = {
      total_customers: totalCustomers,
      by_type: {
        individual,
        corporate,
      },
      blacklisted,
      recent_customers_30d: recentCustomers,
      top_customers: topCustomers,
    };

    console.log(`ðŸ“Š Customer stats fetched for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Customer statistics fetched successfully',
      data: { stats },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customer stats error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch customer statistics',
      details: error.message,
    });
  }
};

module.exports = {
  getAllCustomers,
  getCustomerById,
  getCustomerHistory,
  createCustomer,
  updateCustomer,
  deleteCustomer,
  getCustomerStats,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\controllers\payment.controller.js
// src/controllers/payment.controller.js
const { Payment, Contract, Customer, Vehicle, User, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');

// ============================================
// GET /api/payments - List all payments
// ============================================
const getAllPayments = async (req, res) => {
  try {
    const {
      contract_id,
      customer_id,
      payment_method,
      status,
      start_date,
      end_date,
      search,
      page = 1,
      limit = 20,
      sort_by = 'payment_date',
      sort_order = 'DESC',
    } = req.query;

    // Build filter with tenant isolation
    const whereClause = applyTenantFilter(req);

    // Apply filters
    if (contract_id) whereClause.contract_id = contract_id;
    if (customer_id) whereClause.customer_id = customer_id;
    if (payment_method) whereClause.payment_method = payment_method;
    if (status) whereClause.status = status;

    // Date range filter
    if (start_date || end_date) {
      whereClause.payment_date = {};
      if (start_date) whereClause.payment_date[Op.gte] = start_date;
      if (end_date) whereClause.payment_date[Op.lte] = end_date;
    }

    // Search by reference number
    if (search) {
      whereClause.reference_number = { [Op.iLike]: `%${search}%` };
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch payments with relations
    const { count, rows: payments } = await Payment.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: Contract,
          as: 'contract',
          attributes: ['id', 'contract_number', 'total_amount', 'status'],
          include: [
            {
              model: Vehicle,
              as: 'vehicle',
              attributes: ['id', 'brand', 'model', 'registration_number'],
            },
          ],
        },
        {
          model: Customer,
          as: 'customer',
          attributes: ['id', 'full_name', 'email', 'phone', 'customer_type'],
        },
        {
          model: User,
          as: 'processor',
          attributes: ['id', 'full_name', 'email'],
        },
      ],
      limit: parseInt(limit),
      offset: offset,
      order: [[sort_by, sort_order.toUpperCase()]],
    });

    console.log(`ðŸ’° Fetched ${payments.length} payments for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Payments fetched successfully',
      data: { payments },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get payments error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch payments',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/payments/:id - Get single payment
// ============================================
const getPaymentById = async (req, res) => {
  try {
    const { id } = req.params;

    const payment = await Payment.findOne({
      where: applyTenantFilter(req, { id }),
      include: [
        {
          model: Contract,
          as: 'contract',
          include: [
            {
              model: Vehicle,
              as: 'vehicle',
              attributes: ['id', 'brand', 'model', 'registration_number', 'year'],
            },
          ],
        },
        {
          model: Customer,
          as: 'customer',
        },
        {
          model: User,
          as: 'processor',
          attributes: ['id', 'full_name', 'email'],
        },
      ],
    });

    if (!payment) {
      return sendError(res, {
        statusCode: 404,
        message: 'Payment not found',
      });
    }

    console.log(`ðŸ’³ Payment fetched: ${payment.reference_number || payment.id}`);

    sendSuccess(res, {
      message: 'Payment fetched successfully',
      data: { payment },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get payment error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch payment',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/payments - Record new payment
// ============================================
const createPayment = [
  // Validators
  body('contract_id').isUUID().withMessage('Valid contract ID required'),
  body('amount').isFloat({ min: 0.01 }).withMessage('Valid amount required (must be positive)'),
  body('payment_method')
    .isIn(['cash', 'card', 'bank_transfer', 'check', 'mobile_payment'])
    .withMessage('Invalid payment method'),
  body('payment_date').optional().isISO8601().withMessage('Valid payment date required'),
  body('reference_number').optional().trim(),
  body('notes').optional().trim(),
  body('status')
    .optional()
    .isIn(['pending', 'completed', 'failed', 'refunded'])
    .withMessage('Invalid status'),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { contract_id, amount, payment_method, payment_date, reference_number, notes, status = 'completed' } = req.body;

      // Check if contract exists and belongs to company
      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id: contract_id }),
        include: [
          {
            model: Customer,
            as: 'customer',
          },
        ],
      });

      if (!contract) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }

      // Validate payment amount doesn't exceed contract total
      const totalPaid = await Payment.sum('amount', {
        where: {
          contract_id,
          status: 'completed',
        },
      });

      const totalPaidAmount = parseFloat(totalPaid || 0);
      const contractTotal = parseFloat(contract.total_amount);
      const newPaymentAmount = parseFloat(amount);

      if (totalPaidAmount + newPaymentAmount > contractTotal) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: `Payment amount exceeds contract balance. Outstanding: ${(contractTotal - totalPaidAmount).toFixed(2)} DZD`,
        });
      }

      // Create payment
      const paymentData = applyTenantData(req, {
        contract_id,
        customer_id: contract.customer_id,
        amount: newPaymentAmount,
        payment_method,
        payment_date: payment_date || new Date(),
        reference_number,
        notes,
        status,
        processed_by: req.user.id,
      });

      const payment = await Payment.create(paymentData, { transaction });

      await transaction.commit();

      // Fetch payment with relations
      const fullPayment = await Payment.findByPk(payment.id, {
        include: [
          { model: Contract, as: 'contract' },
          { model: Customer, as: 'customer' },
          { model: User, as: 'processor', attributes: ['id', 'full_name'] },
        ],
      });

      console.log(`ðŸ’³ New payment recorded: ${newPaymentAmount} DZD for contract ${contract.contract_number}`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Payment recorded successfully',
        data: { payment: fullPayment },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Create payment error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to record payment',
        details: error.message,
      });
    }
  },
];

// ============================================
// PUT /api/payments/:id - Update payment
// ============================================
const updatePayment = [
  body('amount').optional().isFloat({ min: 0.01 }),
  body('payment_method').optional().isIn(['cash', 'card', 'bank_transfer', 'check', 'mobile_payment']),
  body('payment_date').optional().isISO8601(),
  body('reference_number').optional().trim(),
  body('status').optional().isIn(['pending', 'completed', 'failed', 'refunded']),
  body('notes').optional().trim(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;

      const payment = await Payment.findOne({
        where: applyTenantFilter(req, { id }),
      });

      if (!payment) {
        return sendError(res, { statusCode: 404, message: 'Payment not found' });
      }

      // Only allow updates for pending or failed payments
      if (payment.status === 'completed' && req.body.status !== 'refunded') {
        return sendError(res, {
          statusCode: 409,
          message: 'Cannot update completed payment (use refund instead)',
        });
      }

      await payment.update(req.body);

      console.log(`ðŸ”„ Payment updated: ${payment.id}`);

      sendSuccess(res, {
        message: 'Payment updated successfully',
        data: { payment },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update payment error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to update payment',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/payments/outstanding - Get outstanding payments
// ============================================
const getOutstandingPayments = async (req, res) => {
  try {
    const { customer_id, page = 1, limit = 20 } = req.query;

    // Build filter
    const contractWhere = applyTenantFilter(req, {
      status: { [Op.in]: ['active', 'completed'] },
    });

    if (customer_id) {
      contractWhere.customer_id = customer_id;
    }

    // Get all contracts with payments
    const contracts = await Contract.findAll({
      where: contractWhere,
      include: [
        {
          model: Payment,
          as: 'payments',
          where: { status: 'completed' },
          required: false,
        },
        {
          model: Customer,
          as: 'customer',
          attributes: ['id', 'full_name', 'email', 'phone', 'customer_type'],
        },
        {
          model: Vehicle,
          as: 'vehicle',
          attributes: ['id', 'brand', 'model', 'registration_number'],
        },
      ],
    });

    // Calculate outstanding balances
    const outstandingContracts = contracts
      .map((contract) => {
        const totalAmount = parseFloat(contract.total_amount);
        const totalPaid = contract.payments.reduce((sum, p) => sum + parseFloat(p.amount), 0);
        const outstanding = totalAmount - totalPaid;

        return {
          contract_id: contract.id,
          contract_number: contract.contract_number,
          customer: contract.customer,
          vehicle: contract.vehicle,
          total_amount: totalAmount,
          total_paid: totalPaid,
          outstanding_amount: outstanding,
          status: contract.status,
          start_date: contract.start_date,
          end_date: contract.end_date,
        };
      })
      .filter((c) => c.outstanding_amount > 0); // Only contracts with outstanding balance

    // Sort by outstanding amount (highest first)
    outstandingContracts.sort((a, b) => b.outstanding_amount - a.outstanding_amount);

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);
    const paginatedResults = outstandingContracts.slice(offset, offset + parseInt(limit));
    const totalOutstanding = outstandingContracts.reduce((sum, c) => sum + c.outstanding_amount, 0);

    console.log(`ðŸ“Š Found ${outstandingContracts.length} contracts with outstanding payments`);

    sendSuccess(res, {
      message: 'Outstanding payments fetched successfully',
      data: {
        outstanding_contracts: paginatedResults,
        summary: {
          total_contracts: outstandingContracts.length,
          total_outstanding_amount: totalOutstanding,
        },
      },
      meta: {
        pagination: {
          total: outstandingContracts.length,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(outstandingContracts.length / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get outstanding payments error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch outstanding payments',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/contracts/:id/payments - Get payments for contract
// ============================================
const getContractPayments = async (req, res) => {
  try {
    const { id: contract_id } = req.params;

    // Check if contract exists and belongs to company
    const contract = await Contract.findOne({
      where: applyTenantFilter(req, { id: contract_id }),
      include: [
        {
          model: Customer,
          as: 'customer',
          attributes: ['id', 'full_name', 'email', 'phone'],
        },
        {
          model: Vehicle,
          as: 'vehicle',
          attributes: ['id', 'brand', 'model', 'registration_number'],
        },
      ],
    });

    if (!contract) {
      return sendError(res, {
        statusCode: 404,
        message: 'Contract not found',
      });
    }

    // Get all payments for this contract
    const payments = await Payment.findAll({
      where: { contract_id },
      include: [
        {
          model: User,
          as: 'processor',
          attributes: ['id', 'full_name', 'email'],
        },
      ],
      order: [['payment_date', 'DESC']],
    });

    // Calculate payment summary
    const totalPaid = payments
      .filter((p) => p.status === 'completed')
      .reduce((sum, p) => sum + parseFloat(p.amount), 0);

    const totalAmount = parseFloat(contract.total_amount);
    const outstandingAmount = totalAmount - totalPaid;
    const paymentPercentage = ((totalPaid / totalAmount) * 100).toFixed(2);

    const summary = {
      contract_number: contract.contract_number,
      customer: contract.customer,
      vehicle: contract.vehicle,
      total_amount: totalAmount,
      total_paid: totalPaid,
      outstanding_amount: outstandingAmount,
      payment_percentage: parseFloat(paymentPercentage),
      payment_count: payments.length,
      completed_payments: payments.filter((p) => p.status === 'completed').length,
    };

    console.log(`ðŸ’° Fetched ${payments.length} payments for contract ${contract.contract_number}`);

    sendSuccess(res, {
      message: 'Contract payments fetched successfully',
      data: {
        payments,
        summary,
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get contract payments error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch contract payments',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/payments/stats - Get payment statistics
// ============================================
const getPaymentStats = async (req, res) => {
  try {
    const companyFilter = { company_id: req.companyId };

    // Total payments
    const totalPayments = await Payment.count({ where: companyFilter });

    // By status
    const completed = await Payment.count({ where: { ...companyFilter, status: 'completed' } });
    const pending = await Payment.count({ where: { ...companyFilter, status: 'pending' } });
    const failed = await Payment.count({ where: { ...companyFilter, status: 'failed' } });
    const refunded = await Payment.count({ where: { ...companyFilter, status: 'refunded' } });

    // By payment method
    const byMethod = await Payment.findAll({
      where: companyFilter,
      attributes: ['payment_method', [sequelize.fn('COUNT', sequelize.col('id')), 'count']],
      group: ['payment_method'],
      raw: true,
    });

    // Total revenue
    const revenueResult = await Payment.findOne({
      where: { ...companyFilter, status: 'completed' },
      attributes: [[sequelize.fn('SUM', sequelize.col('amount')), 'total_revenue']],
      raw: true,
    });

    // Recent payments (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const recentPayments = await Payment.count({
      where: {
        ...companyFilter,
        payment_date: { [Op.gte]: thirtyDaysAgo },
        status: 'completed',
      },
    });

    const recentRevenue = await Payment.findOne({
      where: {
        ...companyFilter,
        payment_date: { [Op.gte]: thirtyDaysAgo },
        status: 'completed',
      },
      attributes: [[sequelize.fn('SUM', sequelize.col('amount')), 'revenue']],
      raw: true,
    });

    const stats = {
      total_payments: totalPayments,
      by_status: { completed, pending, failed, refunded },
      by_method: byMethod.reduce((acc, item) => {
        acc[item.payment_method] = parseInt(item.count);
        return acc;
      }, {}),
      total_revenue: parseFloat(revenueResult?.total_revenue || 0),
      recent_payments_30d: recentPayments,
      recent_revenue_30d: parseFloat(recentRevenue?.revenue || 0),
    };

    sendSuccess(res, {
      message: 'Payment statistics fetched successfully',
      data: { stats },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get payment stats error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch payment statistics',
      details: error.message,
    });
  }
};

module.exports = {
  getAllPayments,
  getPaymentById,
  createPayment,
  updatePayment,
  getOutstandingPayments,
  getContractPayments,
  getPaymentStats,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\controllers\vehicle.controller.js
// src/controllers/vehicle.controller.js
const { Vehicle, VehicleCost, Contract } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');

// ============================================
// GET /api/vehicles - List all vehicles (with filters)
// ============================================
const getAllVehicles = async (req, res) => {
  try {
    const {
      status,
      brand,
      transmission,
      fuel_type,
      min_rate,
      max_rate,
      search,
      page = 1,
      limit = 10,
      sort_by = 'created_at',
      sort_order = 'DESC',
    } = req.query;

    // Build filter object with tenant isolation
    const whereClause = applyTenantFilter(req);

    // Apply status filter
    if (status) {
      whereClause.status = status;
    }

    // Apply brand filter
    if (brand) {
      whereClause.brand = brand;
    }

    // Apply transmission filter
    if (transmission) {
      whereClause.transmission = transmission;
    }

    // Apply fuel type filter
    if (fuel_type) {
      whereClause.fuel_type = fuel_type;
    }

    // Apply rate range filter
    if (min_rate || max_rate) {
      whereClause.daily_rate = {};
      if (min_rate) whereClause.daily_rate[Op.gte] = parseFloat(min_rate);
      if (max_rate) whereClause.daily_rate[Op.lte] = parseFloat(max_rate);
    }

    // Apply search (brand, model, registration_number)
    if (search) {
      whereClause[Op.or] = [
        { brand: { [Op.iLike]: `%${search}%` } },
        { model: { [Op.iLike]: `%${search}%` } },
        { registration_number: { [Op.iLike]: `%${search}%` } },
      ];
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch vehicles
    const { count, rows: vehicles } = await Vehicle.findAndCountAll({
      where: whereClause,
      limit: parseInt(limit),
      offset: offset,
      order: [[sort_by, sort_order.toUpperCase()]],
    });

    console.log(`ðŸ“‹ Fetched ${vehicles.length} vehicles for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Vehicles fetched successfully',
      data: { vehicles },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get vehicles error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch vehicles',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/vehicles/available - Get available vehicles
// ============================================
const getAvailableVehicles = async (req, res) => {
  try {
    const { start_date, end_date } = req.query;

    // Build filter for available vehicles
    const whereClause = applyTenantFilter(req, { status: 'available' });

    // If dates provided, check for conflicts with existing contracts
    let vehicles;
    if (start_date && end_date) {
      // Find vehicles that don't have active contracts in the date range
      vehicles = await Vehicle.findAll({
        where: whereClause,
        include: [
          {
            model: Contract,
            as: 'contracts',
            where: {
              status: 'active',
              [Op.or]: [
                {
                  start_date: { [Op.between]: [start_date, end_date] },
                },
                {
                  end_date: { [Op.between]: [start_date, end_date] },
                },
                {
                  [Op.and]: [
                    { start_date: { [Op.lte]: start_date } },
                    { end_date: { [Op.gte]: end_date } },
                  ],
                },
              ],
            },
            required: false, // LEFT JOIN - include vehicles with no conflicts
          },
        ],
      });

      // Filter out vehicles with active contracts in date range
      vehicles = vehicles.filter(v => v.contracts.length === 0);
    } else {
      // Just return vehicles with status 'available'
      vehicles = await Vehicle.findAll({ where: whereClause });
    }

    console.log(`âœ… Found ${vehicles.length} available vehicles`);

    sendSuccess(res, {
      message: 'Available vehicles fetched successfully',
      data: { vehicles },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get available vehicles error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch available vehicles',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/vehicles/:id - Get single vehicle
// ============================================
const getVehicleById = async (req, res) => {
  try {
    const { id } = req.params;

    const vehicle = await Vehicle.findOne({
      where: applyTenantFilter(req, { id }),
      include: [
        {
          model: VehicleCost,
          as: 'costs',
          limit: 10,
          order: [['incurred_date', 'DESC']],
        },
        {
          model: Contract,
          as: 'contracts',
          where: { status: 'active' },
          required: false,
        },
      ],
    });

    if (!vehicle) {
      return sendError(res, {
        statusCode: 404,
        message: 'Vehicle not found',
      });
    }

    console.log(`ðŸš— Vehicle fetched: ${vehicle.brand} ${vehicle.model}`);

    sendSuccess(res, {
      message: 'Vehicle fetched successfully',
      data: { vehicle },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get vehicle error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch vehicle',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/vehicles - Create vehicle
// ============================================
const createVehicle = [
  // Validators
  body('brand').notEmpty().withMessage('Brand is required'),
  body('model').notEmpty().withMessage('Model is required'),
  body('year').isInt({ min: 1900, max: new Date().getFullYear() + 1 }).withMessage('Valid year required'),
  body('registration_number').notEmpty().withMessage('Registration number is required'),
  body('color').optional().isString(),
  body('transmission').isIn(['manual', 'automatic']).withMessage('Valid transmission required'),
  body('fuel_type').isIn(['petrol', 'diesel', 'electric', 'hybrid']).withMessage('Valid fuel type required'),
  body('seats').isInt({ min: 1, max: 50 }).withMessage('Valid number of seats required'),
  body('daily_rate').isFloat({ min: 0 }).withMessage('Valid daily rate required'),
  body('status').optional().isIn(['available', 'rented', 'maintenance', 'retired']),
  body('mileage').optional().isInt({ min: 0 }),
  body('purchase_price').optional().isFloat({ min: 0 }),
  body('purchase_date').optional().isISO8601(),
  body('vin').optional().isLength({ min: 17, max: 17 }).withMessage('VIN must be 17 characters'),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      // Check if registration number already exists
      const existingVehicle = await Vehicle.findOne({
        where: { registration_number: req.body.registration_number },
      });

      if (existingVehicle) {
        return sendError(res, {
          statusCode: 409,
          message: 'Vehicle with this registration number already exists',
        });
      }

      // Apply tenant data (adds company_id automatically)
      const vehicleData = applyTenantData(req, req.body);

      const vehicle = await Vehicle.create(vehicleData);

      console.log(`ðŸš— New vehicle created: ${vehicle.brand} ${vehicle.model} (${vehicle.registration_number})`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Vehicle created successfully',
        data: { vehicle },
      });
    } catch (error) {
      console.error('ðŸ’¥ Create vehicle error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to create vehicle',
        details: error.message,
      });
    }
  },
];

// ============================================
// PUT /api/vehicles/:id - Update vehicle
// ============================================
const updateVehicle = [
  // Validators (all optional for update)
  body('brand').optional().notEmpty().withMessage('Brand cannot be empty'),
  body('model').optional().notEmpty().withMessage('Model cannot be empty'),
  body('year').optional().isInt({ min: 1900, max: new Date().getFullYear() + 1 }),
  body('registration_number').optional().notEmpty(),
  body('transmission').optional().isIn(['manual', 'automatic']),
  body('fuel_type').optional().isIn(['petrol', 'diesel', 'electric', 'hybrid']),
  body('seats').optional().isInt({ min: 1, max: 50 }),
  body('daily_rate').optional().isFloat({ min: 0 }),
  body('status').optional().isIn(['available', 'rented', 'maintenance', 'retired']),
  body('mileage').optional().isInt({ min: 0 }),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;

      // Check if vehicle exists and belongs to company
      const vehicle = await Vehicle.findOne({
        where: applyTenantFilter(req, { id }),
      });

      if (!vehicle) {
        return sendError(res, {
          statusCode: 404,
          message: 'Vehicle not found',
        });
      }

      // If registration number is being updated, check uniqueness
      if (req.body.registration_number && req.body.registration_number !== vehicle.registration_number) {
        const existingVehicle = await Vehicle.findOne({
          where: { registration_number: req.body.registration_number },
        });

        if (existingVehicle) {
          return sendError(res, {
            statusCode: 409,
            message: 'Vehicle with this registration number already exists',
          });
        }
      }

      // Update vehicle
      await vehicle.update(req.body);

      console.log(`ðŸ”„ Vehicle updated: ${vehicle.brand} ${vehicle.model}`);

      sendSuccess(res, {
        message: 'Vehicle updated successfully',
        data: { vehicle },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update vehicle error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to update vehicle',
        details: error.message,
      });
    }
  },
];

// ============================================
// DELETE /api/vehicles/:id - Delete vehicle
// ============================================
const deleteVehicle = async (req, res) => {
  try {
    const { id } = req.params;

    // Check if vehicle exists and belongs to company
    const vehicle = await Vehicle.findOne({
      where: applyTenantFilter(req, { id }),
    });

    if (!vehicle) {
      return sendError(res, {
        statusCode: 404,
        message: 'Vehicle not found',
      });
    }

    // Check if vehicle has active contracts
    const activeContracts = await Contract.count({
      where: {
        vehicle_id: id,
        status: 'active',
      },
    });

    if (activeContracts > 0) {
      return sendError(res, {
        statusCode: 409,
        message: 'Cannot delete vehicle with active contracts',
      });
    }

    // Soft delete: update status to 'retired' instead of hard delete
    await vehicle.update({ status: 'retired' });

    console.log(`ðŸ—‘ï¸ Vehicle retired: ${vehicle.brand} ${vehicle.model}`);

    sendSuccess(res, {
      message: 'Vehicle deleted successfully',
      data: { vehicle },
    });
  } catch (error) {
    console.error('ðŸ’¥ Delete vehicle error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to delete vehicle',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/vehicles/:id/costs - Add vehicle cost
// ============================================
const addVehicleCost = [
  body('cost_type')
    .isIn(['fuel', 'maintenance', 'insurance', 'registration', 'cleaning', 'repair', 'other'])
    .withMessage('Valid cost type required'),
  body('amount').isFloat({ min: 0 }).withMessage('Valid amount required'),
  body('incurred_date').isISO8601().withMessage('Valid date required'),
  body('description').optional().isString(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id: vehicle_id } = req.params;

      // Check if vehicle exists and belongs to company
      const vehicle = await Vehicle.findOne({
        where: applyTenantFilter(req, { id: vehicle_id }),
      });

      if (!vehicle) {
        return sendError(res, {
          statusCode: 404,
          message: 'Vehicle not found',
        });
      }

      // Create cost record
      const cost = await VehicleCost.create({
        vehicle_id,
        created_by: req.user.id,
        ...req.body,
      });

      console.log(`ðŸ’° Cost added to vehicle ${vehicle_id}: ${cost.cost_type} - ${cost.amount}`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Vehicle cost added successfully',
        data: { cost },
      });
    } catch (error) {
      console.error('ðŸ’¥ Add vehicle cost error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to add vehicle cost',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/vehicles/:id/costs - Get cost history
// ============================================
const getVehicleCosts = async (req, res) => {
  try {
    const { id: vehicle_id } = req.params;
    const { cost_type, start_date, end_date, page = 1, limit = 20 } = req.query;

    // Check if vehicle exists and belongs to company
    const vehicle = await Vehicle.findOne({
      where: applyTenantFilter(req, { id: vehicle_id }),
    });

    if (!vehicle) {
      return sendError(res, {
        statusCode: 404,
        message: 'Vehicle not found',
      });
    }

    // Build filter
    const whereClause = { vehicle_id };

    if (cost_type) {
      whereClause.cost_type = cost_type;
    }

    if (start_date || end_date) {
      whereClause.incurred_date = {};
      if (start_date) whereClause.incurred_date[Op.gte] = start_date;
      if (end_date) whereClause.incurred_date[Op.lte] = end_date;
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    const { count, rows: costs } = await VehicleCost.findAndCountAll({
      where: whereClause,
      limit: parseInt(limit),
      offset: offset,
      order: [['incurred_date', 'DESC']],
    });

    // Calculate total cost
    const totalCost = costs.reduce((sum, cost) => sum + parseFloat(cost.amount), 0);

    console.log(`ðŸ’° Fetched ${costs.length} costs for vehicle ${vehicle_id}`);

    sendSuccess(res, {
      message: 'Vehicle costs fetched successfully',
      data: { 
        costs,
        total_cost: totalCost,
      },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get vehicle costs error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch vehicle costs',
      details: error.message,
    });
  }
};

module.exports = {
  getAllVehicles,
  getAvailableVehicles,
  getVehicleById,
  createVehicle,
  updateVehicle,
  deleteVehicle,
  addVehicleCost,
  getVehicleCosts,
};


//   [Folder] jobs


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\jobs\analytics.job.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\jobs\notifications.job.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\jobs\subscriptions.job.js



//   [Folder] middleware


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\middleware\auth.middleware.js
// src/middleware/auth.middleware.js
const { verifyAccessToken } = require('../utils/jwt.util');
const { sendError } = require('../utils/response.util');

/**
 * Middleware to authenticate JWT access token
 * Expects: Authorization header as 'Bearer <token>'
 * Sets: req.user = { id, email, role, company_id }
 * Throws: 401 error if invalid/missing
 */
const authenticateToken = (req, res, next) => {
  try {
    // Extract token from Authorization header
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
      return sendError(res, {
        statusCode: 401,
        message: 'Access token required',
        code: 'NO_TOKEN',
      });
    }

    // Verify token
    const decoded = verifyAccessToken(token);
    req.user = decoded; // Attach to req for downstream use
    next();
  } catch (error) {
    return sendError(res, {
      statusCode: 401,
      message: error.message || 'Invalid token',
      code: 'INVALID_TOKEN',
    });
  }
};

/**
 * Optional: Middleware for optional auth (e.g., public routes with user info if logged in)
 */
const authenticateTokenOptional = (req, res, next) => {
  try {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token) {
      const decoded = verifyAccessToken(token);
      req.user = decoded;
    }
    // If no token, req.user remains undefined
    next();
  } catch (error) {
    // Silently ignore invalid tokens; treat as unauthenticated
    next();
  }
};

module.exports = {
  authenticateToken,
  authenticateTokenOptional,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\middleware\error.middleware.js
// src/middleware/error.middleware.js
export const errorHandler = (err, req, res, next) => {
  console.error(err.stack);
  res.status(err.status || 500).json({
    success: false,
    message: err.message || 'Internal Server Error',
  });
};


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\middleware\logging.middleware.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\middleware\permissions.middleware.js
// src/middleware/permissions.middleware.js
const { sendError } = require('../utils/response.util');

/**
 * Middleware factory: Check if user has required role(s)
 * Usage: permissionsMiddleware('admin') or permissionsMiddleware(['admin', 'owner'])
 * Assumes: req.user from auth.middleware.js
 * Throws: 403 if unauthorized
 */
const requireRole = (allowedRoles) => {
  return (req, res, next) => {
    if (!req.user) {
      return sendError(res, {
        statusCode: 401,
        message: 'Authentication required',
        code: 'UNAUTHENTICATED',
      });
    }

    const userRole = req.user.role;
    const rolesArray = Array.isArray(allowedRoles) ? allowedRoles : [allowedRoles];

    if (!rolesArray.includes(userRole)) {
      return sendError(res, {
        statusCode: 403,
        message: `Insufficient permissions. Required: ${rolesArray.join(', ')}`,
        code: 'FORBIDDEN',
      });
    }

    // Optional: Attach allowed roles to req for logging/auditing
    req.allowedRoles = rolesArray;
    next();
  };
};

/**
 * Higher-order: Combine auth + permissions (e.g., requireRole('owner'))
 * Usage: requireAuthAndRole('owner')
 */
const requireAuthAndRole = (allowedRoles) => {
  const auth = require('../middleware/auth.middleware').authenticateToken;
  const perm = requireRole(allowedRoles);
  return [auth, perm];
};

module.exports = {
  requireRole,
  requireAuthAndRole,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\middleware\tenantIsolation.middleware.js
// src/middleware/tenantIsolation.middleware.js
/**
 * Tenant Isolation Middleware
 * Ensures all database queries are scoped to the authenticated user's company
 * This middleware MUST be used after authenticate.middleware.js
 */

const { sendError } = require('../utils/response.util');

/**
 * Injects company_id from JWT into req for easy access
 * Usage: Apply this after authenticate middleware on all protected routes
 */
const injectCompanyId = (req, res, next) => {
  try {
    // req.user comes from authenticate.middleware.js
    if (!req.user || !req.user.company_id) {
      console.error('ðŸš« Tenant isolation failed: No company_id in token');
      return sendError(res, { 
        statusCode: 403, 
        message: 'Access denied: Invalid company context' 
      });
    }

    // Make company_id easily accessible throughout the request
    req.companyId = req.user.company_id;
    
    console.log(`ðŸ¢ Tenant context set: company_id=${req.companyId}, user_id=${req.user.id}`);
    next();
  } catch (error) {
    console.error('ðŸ’¥ Tenant injection error:', error);
    sendError(res, { 
      statusCode: 500, 
      message: 'Failed to set tenant context', 
      details: error.message 
    });
  }
};

/**
 * Validates that a resource belongs to the user's company
 * Usage: validateTenantOwnership('company_id') or validateTenantOwnership('companyId')
 * 
 * @param {string} fieldName - The field name in the resource to check (default: 'company_id')
 * @returns {Function} Express middleware
 */
const validateTenantOwnership = (fieldName = 'company_id') => {
  return (req, res, next) => {
    try {
      const resourceCompanyId = req.body[fieldName] || req.params[fieldName] || req.query[fieldName];
      
      if (!resourceCompanyId) {
        // If no company_id in request, that's OK - it will be injected
        return next();
      }

      // If company_id is provided, it MUST match the authenticated user's company
      if (resourceCompanyId !== req.user.company_id) {
        console.warn(`ðŸš« Tenant violation attempt: user=${req.user.id} tried to access company=${resourceCompanyId}`);
        return sendError(res, { 
          statusCode: 403, 
          message: 'Access denied: Cannot access resources from another company' 
        });
      }

      next();
    } catch (error) {
      console.error('ðŸ’¥ Tenant validation error:', error);
      sendError(res, { 
        statusCode: 500, 
        message: 'Failed to validate tenant ownership', 
        details: error.message 
      });
    }
  };
};

/**
 * Automatically adds company_id to query parameters for Sequelize
 * Usage: Use in controllers before database queries
 * 
 * Example:
 *   const whereClause = applyTenantFilter(req, { status: 'active' });
 *   // Returns: { company_id: 'xxx', status: 'active' }
 */
const applyTenantFilter = (req, additionalFilters = {}) => {
  if (!req.companyId) {
    throw new Error('Tenant context not set - apply injectCompanyId middleware first');
  }
  
  return {
    company_id: req.companyId,
    ...additionalFilters,
  };
};

/**
 * Helper to ensure created resources have company_id
 * Usage: Use in controllers before create operations
 * 
 * Example:
 *   const data = applyTenantData(req, req.body);
 *   await Vehicle.create(data);
 */
const applyTenantData = (req, data = {}) => {
  if (!req.companyId) {
    throw new Error('Tenant context not set - apply injectCompanyId middleware first');
  }
  
  return {
    ...data,
    company_id: req.companyId,
  };
};

/**
 * Middleware to prevent cross-tenant data leaks in bulk operations
 * Validates that all items in req.body.items have matching company_id
 */
const validateBulkTenantOwnership = (req, res, next) => {
  try {
    const items = req.body.items || req.body;
    
    if (!Array.isArray(items)) {
      return next(); // Not a bulk operation
    }

    const invalidItems = items.filter(item => 
      item.company_id && item.company_id !== req.user.company_id
    );

    if (invalidItems.length > 0) {
      console.warn(`ðŸš« Bulk tenant violation: ${invalidItems.length} items don't match company_id`);
      return sendError(res, { 
        statusCode: 403, 
        message: 'Access denied: Cannot perform bulk operations across companies' 
      });
    }

    next();
  } catch (error) {
    console.error('ðŸ’¥ Bulk tenant validation error:', error);
    sendError(res, { 
      statusCode: 500, 
      message: 'Failed to validate bulk tenant ownership', 
      details: error.message 
    });
  }
};

module.exports = {
  injectCompanyId,
  validateTenantOwnership,
  applyTenantFilter,
  applyTenantData,
  validateBulkTenantOwnership,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\middleware\validation.middleware.js
// src/middleware/validation.middleware.js
const { body, param, query, validationResult } = require('express-validator');
const { sendError } = require('../utils/response.util');

/**
 * Middleware to check validation results
 * Use this after validation chains in routes
 */
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return sendError(res, {
      statusCode: 422,
      message: 'Validation failed',
      code: 'VALIDATION_ERROR',
      details: errors.array(),
    });
  }
  next();
};

/**
 * Common validation chains for reuse
 */
const validations = {
  // UUID validation
  uuid: (field = 'id') => 
    param(field).isUUID().withMessage(`${field} must be a valid UUID`),

  // Pagination
  pagination: [
    query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
    query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'),
  ],

  // Date range
  dateRange: [
    query('start_date').optional().isISO8601().withMessage('Valid start date required (ISO 8601)'),
    query('end_date').optional().isISO8601().withMessage('Valid end date required (ISO 8601)'),
  ],

  // Vehicle fields
  vehicle: {
    brand: body('brand').notEmpty().withMessage('Brand is required').trim(),
    model: body('model').notEmpty().withMessage('Model is required').trim(),
    year: body('year')
      .isInt({ min: 1900, max: new Date().getFullYear() + 1 })
      .withMessage('Valid year required'),
    registration: body('registration_number')
      .notEmpty()
      .withMessage('Registration number is required')
      .trim(),
    transmission: body('transmission')
      .isIn(['manual', 'automatic'])
      .withMessage('Transmission must be manual or automatic'),
    fuel_type: body('fuel_type')
      .isIn(['petrol', 'diesel', 'electric', 'hybrid'])
      .withMessage('Valid fuel type required'),
    seats: body('seats')
      .isInt({ min: 1, max: 50 })
      .withMessage('Seats must be between 1 and 50'),
    daily_rate: body('daily_rate')
      .isFloat({ min: 0 })
      .withMessage('Daily rate must be a positive number'),
    status: body('status')
      .optional()
      .isIn(['available', 'rented', 'maintenance', 'retired'])
      .withMessage('Invalid status'),
  },

  // Customer fields
  customer: {
    full_name: body('full_name').notEmpty().withMessage('Full name is required').trim(),
    email: body('email')
      .optional()
      .isEmail()
      .withMessage('Valid email required')
      .normalizeEmail(),
    phone: body('phone')
      .notEmpty()
      .withMessage('Phone is required')
      .matches(/^[+]?[0-9\s-()]+$/)
      .withMessage('Valid phone number required'),
    customer_type: body('customer_type')
      .isIn(['individual', 'corporate'])
      .withMessage('Customer type must be individual or corporate'),
    license: body('drivers_license_number')
      .optional()
      .trim()
      .isLength({ min: 5, max: 50 })
      .withMessage('License number must be 5-50 characters'),
  },

  // Contract fields
  contract: {
    customer_id: body('customer_id').isUUID().withMessage('Valid customer ID required'),
    vehicle_id: body('vehicle_id').isUUID().withMessage('Valid vehicle ID required'),
    start_date: body('start_date').isISO8601().withMessage('Valid start date required'),
    end_date: body('end_date').isISO8601().withMessage('Valid end date required'),
    daily_rate: body('daily_rate')
      .isFloat({ min: 0 })
      .withMessage('Daily rate must be positive'),
  },

  // Payment fields
  payment: {
    amount: body('amount').isFloat({ min: 0 }).withMessage('Amount must be positive'),
    payment_method: body('payment_method')
      .isIn(['cash', 'card', 'bank_transfer', 'check', 'mobile_payment'])
      .withMessage('Invalid payment method'),
    payment_date: body('payment_date')
      .optional()
      .isISO8601()
      .withMessage('Valid payment date required'),
  },
};

/**
 * Validate that end_date is after start_date
 */
const validateDateRange = (req, res, next) => {
  const { start_date, end_date } = req.body;
  
  if (start_date && end_date) {
    const start = new Date(start_date);
    const end = new Date(end_date);
    
    if (end <= start) {
      return sendError(res, {
        statusCode: 422,
        message: 'End date must be after start date',
        code: 'INVALID_DATE_RANGE',
      });
    }
  }
  
  next();
};

/**
 * Sanitize input to prevent XSS
 */
const sanitizeInput = (req, res, next) => {
  // Remove any HTML tags from string inputs
  const sanitize = (obj) => {
    for (let key in obj) {
      if (typeof obj[key] === 'string') {
        obj[key] = obj[key].replace(/<[^>]*>/g, '');
      } else if (typeof obj[key] === 'object' && obj[key] !== null) {
        sanitize(obj[key]);
      }
    }
  };

  if (req.body) sanitize(req.body);
  if (req.query) sanitize(req.query);
  if (req.params) sanitize(req.params);

  next();
};

/**
 * Validate file upload
 */
const validateFileUpload = (allowedTypes = [], maxSize = 5 * 1024 * 1024) => {
  return (req, res, next) => {
    if (!req.file) {
      return next(); // No file, skip validation
    }

    const file = req.file;

    // Check file type
    if (allowedTypes.length > 0 && !allowedTypes.includes(file.mimetype)) {
      return sendError(res, {
        statusCode: 422,
        message: `Invalid file type. Allowed: ${allowedTypes.join(', ')}`,
        code: 'INVALID_FILE_TYPE',
      });
    }

    // Check file size
    if (file.size > maxSize) {
      return sendError(res, {
        statusCode: 422,
        message: `File too large. Maximum size: ${maxSize / (1024 * 1024)}MB`,
        code: 'FILE_TOO_LARGE',
      });
    }

    next();
  };
};

module.exports = {
  handleValidationErrors,
  validations,
  validateDateRange,
  sanitizeInput,
  validateFileUpload,
};


//   [Folder] models


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\models\Company.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Company = sequelize.define('Company', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  name: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING(255),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true,
    },
  },
  phone: {
    type: DataTypes.STRING(50),
  },
  address: {
    type: DataTypes.TEXT,
  },
  tax_id: {
    type: DataTypes.STRING(100),
  },
  logo_url: {
    type: DataTypes.TEXT,
  },
  subscription_plan: {
    type: DataTypes.ENUM('basic', 'professional', 'enterprise'),
    defaultValue: 'basic',
  },
  subscription_status: {
    type: DataTypes.ENUM('active', 'inactive', 'trial', 'suspended'),
    defaultValue: 'trial',
  },
  subscription_start_date: {
    type: DataTypes.DATE,
  },
  subscription_end_date: {
    type: DataTypes.DATE,
  },
  trial_ends_at: {
    type: DataTypes.DATE,
  },
  monthly_recurring_revenue: {
    type: DataTypes.DECIMAL(12, 2),
    defaultValue: 0,
  },
  settings: {
    type: DataTypes.JSONB,
    defaultValue: {},
  },
}, {
  tableName: 'companies',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
});

module.exports = Company;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\models\Contract.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Contract = sequelize.define('Contract', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  contract_number: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  customer_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'customers',
      key: 'id',
    },
    onDelete: 'RESTRICT',
  },
  vehicle_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'vehicles',
      key: 'id',
    },
    onDelete: 'RESTRICT',
  },
  created_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
  start_date: {
    type: DataTypes.DATE,
    allowNull: false,
  },
  end_date: {
    type: DataTypes.DATE,
    allowNull: false,
  },
  actual_return_date: {
    type: DataTypes.DATE,
  },
  daily_rate: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  total_days: {
    type: DataTypes.INTEGER,
    allowNull: false,
  },
  base_amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  additional_charges: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
  },
  discount_amount: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
  },
  tax_amount: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
  },
  total_amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  start_mileage: {
    type: DataTypes.INTEGER,
  },
  end_mileage: {
    type: DataTypes.INTEGER,
  },
  mileage_limit: {
    type: DataTypes.INTEGER,
  },
  mileage_charge_per_km: {
    type: DataTypes.DECIMAL(5, 2),
  },
  status: {
    type: DataTypes.ENUM('draft', 'active', 'completed', 'cancelled', 'extended'),
    defaultValue: 'active',
  },
  extras: {
    type: DataTypes.JSONB,
    defaultValue: {},
  },
  contract_pdf_url: {
    type: DataTypes.TEXT,
  },
  contract_signed_date: {
    type: DataTypes.DATE,
  },
  deposit_amount: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
  },
  deposit_returned: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
  },
  notes: {
    type: DataTypes.TEXT,
  },
}, {
  tableName: 'contracts',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['company_id'] },
    { fields: ['customer_id'] },
    { fields: ['vehicle_id'] },
    { fields: ['status'] },
    { fields: ['start_date', 'end_date'] },
  ],
});

module.exports = Contract;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\models\Customer.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Customer = sequelize.define('Customer', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  customer_type: {
    type: DataTypes.ENUM('individual', 'corporate'),
    defaultValue: 'individual',
  },
  full_name: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  company_name: {
    type: DataTypes.STRING(255),
  },
  email: {
    type: DataTypes.STRING(255),
    validate: {
      isEmail: true,
    },
  },
  phone: {
    type: DataTypes.STRING(50),
    allowNull: false,
  },
  address: {
    type: DataTypes.TEXT,
  },
  city: {
    type: DataTypes.STRING(100),
  },
  date_of_birth: {
    type: DataTypes.DATEONLY,
  },
  id_card_number: {
    type: DataTypes.STRING(50),
  },
  drivers_license_number: {
    type: DataTypes.STRING(50),
    unique: true,
  },
  license_expiry_date: {
    type: DataTypes.DATEONLY,
  },
  id_card_photo_url: {
    type: DataTypes.TEXT,
  },
  license_photo_url: {
    type: DataTypes.TEXT,
  },
  emergency_contact_name: {
    type: DataTypes.STRING(255),
  },
  emergency_contact_phone: {
    type: DataTypes.STRING(50),
  },
  notes: {
    type: DataTypes.TEXT,
  },
  is_blacklisted: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
  },
  total_rentals: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
  lifetime_value: {
    type: DataTypes.DECIMAL(12, 2),
    defaultValue: 0,
  },
}, {
  tableName: 'customers',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    {
      fields: ['company_id'],
    },
    {
      fields: ['phone'],
    },
    {
      fields: ['drivers_license_number'],
    },
  ],
});

module.exports = Customer;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\models\Employee.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Employee = sequelize.define('Employee', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  user_id: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
    onDelete: 'SET NULL',
  },
  full_name: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING(255),
    validate: {
      isEmail: true,
    },
  },
  phone: {
    type: DataTypes.STRING(50),
    allowNull: false,
  },
  position: {
    type: DataTypes.STRING(100),
  },
  department: {
    type: DataTypes.STRING(100),
  },
  salary_type: {
    type: DataTypes.ENUM('hourly', 'monthly', 'commission'),
    defaultValue: 'monthly',
  },
  salary: {
    type: DataTypes.DECIMAL(10, 2),
  },
  commission_rate: {
    type: DataTypes.DECIMAL(5, 2),
  },
  hire_date: {
    type: DataTypes.DATEONLY,
  },
  termination_date: {
    type: DataTypes.DATEONLY,
  },
  status: {
    type: DataTypes.ENUM('active', 'on_leave', 'terminated'),
    defaultValue: 'active',
  },
  id_card_number: {
    type: DataTypes.STRING(50),
  },
  address: {
    type: DataTypes.TEXT,
  },
  emergency_contact_name: {
    type: DataTypes.STRING(255),
  },
  emergency_contact_phone: {
    type: DataTypes.STRING(50),
  },
  notes: {
    type: DataTypes.TEXT,
  },
}, {
  tableName: 'employees',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    {
      fields: ['company_id'],
    },
    {
      fields: ['status'],
    },
  ],
});

module.exports = Employee;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\models\index.js
const { sequelize } = require('../config/database');

// Import all models
const Company = require('./Company');
const User = require('./User');
const Vehicle = require('./Vehicle');
const Customer = require('./Customer');
const Contract = require('./Contract');
const Payment = require('./Payment');
const VehicleCost = require('./VehicleCost');
const Employee = require('./Employee');

// ============================================
// COMPANY RELATIONSHIPS
// ============================================
Company.hasMany(User, { foreignKey: 'company_id', as: 'users' });
User.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Vehicle, { foreignKey: 'company_id', as: 'vehicles' });
Vehicle.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Customer, { foreignKey: 'company_id', as: 'customers' });
Customer.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Contract, { foreignKey: 'company_id', as: 'contracts' });
Contract.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Employee, { foreignKey: 'company_id', as: 'employees' });
Employee.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Payment, { foreignKey: 'company_id', as: 'payments' });
Payment.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

// ============================================
// CONTRACT RELATIONSHIPS
// ============================================
Customer.hasMany(Contract, { foreignKey: 'customer_id', as: 'contracts' });
Contract.belongsTo(Customer, { foreignKey: 'customer_id', as: 'customer' });

Vehicle.hasMany(Contract, { foreignKey: 'vehicle_id', as: 'contracts' });
Contract.belongsTo(Vehicle, { foreignKey: 'vehicle_id', as: 'vehicle' });

User.hasMany(Contract, { foreignKey: 'created_by', as: 'created_contracts' });
Contract.belongsTo(User, { foreignKey: 'created_by', as: 'creator' });

// ============================================
// PAYMENT RELATIONSHIPS
// ============================================
Contract.hasMany(Payment, { foreignKey: 'contract_id', as: 'payments' });
Payment.belongsTo(Contract, { foreignKey: 'contract_id', as: 'contract' });

Customer.hasMany(Payment, { foreignKey: 'customer_id', as: 'payments' });
Payment.belongsTo(Customer, { foreignKey: 'customer_id', as: 'customer' });

User.hasMany(Payment, { foreignKey: 'processed_by', as: 'processed_payments' });
Payment.belongsTo(User, { foreignKey: 'processed_by', as: 'processor' });

// ============================================
// VEHICLE COST RELATIONSHIPS
// ============================================
Vehicle.hasMany(VehicleCost, { foreignKey: 'vehicle_id', as: 'costs' });
VehicleCost.belongsTo(Vehicle, { foreignKey: 'vehicle_id', as: 'vehicle' });

User.hasMany(VehicleCost, { foreignKey: 'created_by', as: 'vehicle_costs' });
VehicleCost.belongsTo(User, { foreignKey: 'created_by', as: 'creator' });

// ============================================
// EMPLOYEE RELATIONSHIPS
// ============================================
User.hasOne(Employee, { foreignKey: 'user_id', as: 'employee_profile' });
Employee.belongsTo(User, { foreignKey: 'user_id', as: 'user' });

module.exports = {
  sequelize,
  Company,
  User,
  Vehicle,
  Customer,
  Contract,
  Payment,
  VehicleCost,
  Employee,
};




// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\models\Payment.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Payment = sequelize.define('Payment', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  contract_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'contracts',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  customer_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'customers',
      key: 'id',
    },
    onDelete: 'RESTRICT',
  },
  amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  payment_method: {
    type: DataTypes.ENUM('cash', 'card', 'bank_transfer', 'check', 'mobile_payment'),
    allowNull: false,
  },
  payment_date: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
  reference_number: {
    type: DataTypes.STRING(100),
  },
  status: {
    type: DataTypes.ENUM('pending', 'completed', 'failed', 'refunded'),
    defaultValue: 'completed',
  },
  notes: {
    type: DataTypes.TEXT,
  },
  receipt_url: {
    type: DataTypes.TEXT,
  },
  processed_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
}, {
  tableName: 'payments',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: false,
  indexes: [
    {
      fields: ['contract_id'],
    },
    {
      fields: ['payment_date'],
    },
    {
      fields: ['company_id'],
    },
  ],
});

module.exports = Payment;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\models\User.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');
const bcrypt = require('bcryptjs');

const User = sequelize.define('User', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  full_name: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING(255),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true,
    },
  },
  password_hash: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  // Virtual field for setting password
  password: {
    type: DataTypes.VIRTUAL,
    set(value) {
      // Store the plain password temporarily
      this.setDataValue('password', value);
      // Hash it and set password_hash
      const hash = bcrypt.hashSync(value, 10);
      this.setDataValue('password_hash', hash);
    },
  },
  phone: {
    type: DataTypes.STRING(50),
  },
  avatar_url: {
    type: DataTypes.TEXT,
  },
  role: {
    type: DataTypes.ENUM('owner', 'admin', 'manager', 'staff', 'viewer'),
    defaultValue: 'staff',
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
  },
  last_login_at: {
    type: DataTypes.DATE,
  },
}, {
  tableName: 'users',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    {
      fields: ['company_id'],
    },
    {
      fields: ['email'],
    },
  ],
  hooks: {
    beforeCreate: async (user) => {
      if (user.password) {
        user.password_hash = await bcrypt.hash(user.password, 10);
      }
    },
    beforeUpdate: async (user) => {
      if (user.password) {
        user.password_hash = await bcrypt.hash(user.password, 10);
      }
    },
  },
});

module.exports = User;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\models\Vehicle.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Vehicle = sequelize.define('Vehicle', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  brand: {
    type: DataTypes.STRING(100),
    allowNull: false,
  },
  model: {
    type: DataTypes.STRING(100),
    allowNull: false,
  },
  year: {
    type: DataTypes.INTEGER,
    allowNull: false,
  },
  registration_number: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true,
  },
  vin: {
    type: DataTypes.STRING(17),
    unique: true,
  },
  color: {
    type: DataTypes.STRING(50),
  },
  transmission: {
    type: DataTypes.ENUM('manual', 'automatic'),
    defaultValue: 'manual',
  },
  fuel_type: {
    type: DataTypes.ENUM('petrol', 'diesel', 'electric', 'hybrid'),
    defaultValue: 'petrol',
  },
  seats: {
    type: DataTypes.INTEGER,
    defaultValue: 5,
  },
  daily_rate: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  status: {
    type: DataTypes.ENUM('available', 'rented', 'maintenance', 'retired'),
    defaultValue: 'available',
  },
  mileage: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
  purchase_price: {
    type: DataTypes.DECIMAL(12, 2),
  },
  purchase_date: {
    type: DataTypes.DATEONLY,
  },
  photos: {
    type: DataTypes.JSONB,
    defaultValue: [],
  },
  features: {
    type: DataTypes.JSONB,
    defaultValue: {},
  },
  notes: {
    type: DataTypes.TEXT,
  },
}, {
  tableName: 'vehicles',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['company_id'] },
    { fields: ['status'] },
  ],
});

module.exports = Vehicle;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\models\VehicleCost.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const VehicleCost = sequelize.define('VehicleCost', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  vehicle_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'vehicles',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  cost_type: {
    type: DataTypes.ENUM('fuel', 'maintenance', 'insurance', 'registration', 'cleaning', 'repair', 'other'),
    allowNull: false,
  },
  amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  incurred_date: {
    type: DataTypes.DATEONLY,
    allowNull: false,
  },
  description: {
    type: DataTypes.TEXT,
  },
  receipt_url: {
    type: DataTypes.TEXT,
  },
  created_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
}, {
  tableName: 'vehicle_costs',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: false,
  indexes: [
    {
      fields: ['vehicle_id', 'incurred_date'],
    },
  ],
});

module.exports = VehicleCost;


//   [Folder] routes


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\routes\admin.routes.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\routes\analytics.routes.js
// src/routes/analytics.routes.js
const express = require('express');
const router = express.Router();
const {
  getDashboard,
  getRevenue,
  getVehiclePerformance,
  getVehicleUtilization,
  getVehicleProfitLoss,
  getCustomerAnalytics,
  getCustomerSegmentation,
  getCustomerRetention,
} = require('../controllers/analytics.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// DASHBOARD & OVERVIEW
// ============================================

/**
 * GET /api/analytics/dashboard
 * Get comprehensive dashboard KPIs
 * Query params:
 *   - period: 'today' | 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 * 
 * Access: All authenticated users
 */
router.get('/dashboard', getDashboard);

// ============================================
// REVENUE ANALYTICS
// ============================================

/**
 * GET /api/analytics/revenue
 * Get detailed revenue analytics
 * Query params:
 *   - period: 'today' | 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 *   - compare: boolean (compare with previous period)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/revenue',
  requireRole(['owner', 'admin', 'manager']),
  getRevenue
);

// ============================================
// VEHICLE ANALYTICS
// ============================================

/**
 * GET /api/analytics/vehicles
 * Get vehicle performance overview
 * Query params:
 *   - period: 'today' | 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 *   - metric: 'utilization' | 'revenue' | 'profit'
 *   - limit: number (default 10)
 * 
 * Access: All authenticated users
 */
router.get('/vehicles', getVehiclePerformance);

/**
 * GET /api/analytics/vehicles/utilization
 * Get detailed vehicle utilization rates
 * Query params:
 *   - period: 'today' | 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 *   - vehicle_id: UUID (filter by specific vehicle)
 * 
 * Access: All authenticated users
 */
router.get('/vehicles/utilization', getVehicleUtilization);

/**
 * GET /api/analytics/vehicles/profit-loss
 * Get vehicle profit & loss analysis
 * Query params:
 *   - period: 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/vehicles/profit-loss',
  requireRole(['owner', 'admin', 'manager']),
  getVehicleProfitLoss
);

// ============================================
// CUSTOMER ANALYTICS
// ============================================

/**
 * GET /api/analytics/customers
 * Get comprehensive customer analytics (segmentation + retention)
 * Query params:
 *   - period: 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/customers',
  requireRole(['owner', 'admin', 'manager']),
  getCustomerAnalytics
);

/**
 * GET /api/analytics/customers/segmentation
 * Get customer segmentation by value
 * No query params (uses all-time data)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/customers/segmentation',
  requireRole(['owner', 'admin', 'manager']),
  getCustomerSegmentation
);

/**
 * GET /api/analytics/customers/retention
 * Get customer retention metrics
 * Query params:
 *   - period: 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/customers/retention',
  requireRole(['owner', 'admin', 'manager']),
  getCustomerRetention
);

module.exports = router;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\routes\auth.routes.js
// src/routes/auth.routes.js
const express = require('express');
const router = express.Router();

const {
  register,
  login,
  getMe,
  logout,
  refresh,
} = require('../controllers/auth.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');

// Public routes (no auth)
router.post('/register', register);
router.post('/login', login);
router.post('/refresh', refresh);
router.post('/logout', refresh_token => { // Wait, noâ€”logout needs refresh token, but can be after auth
  // Actually, logout can be public if providing refresh_token in body
  router.post('/logout', logout);
});

// Protected routes
router.get('/me', authenticateToken, requireRole(['owner', 'staff']), getMe); // Example: owner/staff only

module.exports = router;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\routes\company.routes.js
// src/routes/company.routes.js
const express = require('express');
const router = express.Router();

const { createCompany } = require('../controllers/company.controller');

// Public: Create company for signup (no auth)
router.post('/', createCompany);

module.exports = router;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\routes\companyProfile.routes.js
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth.middleware'); // Your auth middleware
const { getProfile, updateProfile, updateSettings } = require('../controllers/company.controller');

const { injectCompanyId, validateTenantOwnership } = require('../middleware/tenantIsolation.middleware');



// Apply authentication + tenant isolation to ALL routes in this router
router.use(authenticateToken);
router.use(injectCompanyId);

// GET /api/company/profile
router.get('/profile', getProfile);


// PUT /api/company/profile - Update company profile
// Validates that user isn't trying to update another company's data
router.put('/profile', validateTenantOwnership('company_id'), updateProfile);

// PUT /api/company/settings
router.put('/settings', updateSettings);

module.exports = router;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\routes\contract.routes.js
// src/routes/contract.routes.js
const express = require('express');
const router = express.Router();
const {
  getAllContracts,
  getContractById,
  createContract,
  updateContract,
  completeContract,
  cancelContract,
  extendContract,
  getContractStats,
} = require('../controllers/contract.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');
const { getContractPayments } = require('../controllers/payment.controller');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// CONTRACT ROUTES
// ============================================

// GET /api/contracts/stats - Get statistics
// Must be BEFORE /:id to avoid matching 'stats' as an ID
router.get('/stats', getContractStats);

// GET /api/contracts - List all contracts
// All authenticated users can view contracts
router.get('/', getAllContracts);

// GET /api/contracts/:id - Get single contract
router.get('/:id', getContractById);

// POST /api/contracts - Create new contract
// All users can create contracts
router.post('/', createContract);

// PUT /api/contracts/:id - Update contract
// Only owners, admins, managers, and staff can update
router.put('/:id', requireRole(['owner', 'admin', 'manager', 'staff']), updateContract);

// POST /api/contracts/:id/complete - Complete rental
// Only owners, admins, managers, and staff can complete
router.post('/:id/complete', requireRole(['owner', 'admin', 'manager', 'staff']), completeContract);

// POST /api/contracts/:id/cancel - Cancel contract
// Only owners, admins, and managers can cancel
router.post('/:id/cancel', requireRole(['owner', 'admin', 'manager']), cancelContract);

// POST /api/contracts/:id/extend - Extend rental period
// Only owners, admins, managers, and staff can extend
router.post('/:id/extend', requireRole(['owner', 'admin', 'manager', 'staff']), extendContract);


// GET /api/contracts/:id/payments - Get all payments for a contract
router.get('/:id/payments', getContractPayments);

module.exports = router;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\routes\customer.routes.js
// src/routes/customer.routes.js
const express = require('express');
const router = express.Router();
const {
  getAllCustomers,
  getCustomerById,
  getCustomerHistory,
  createCustomer,
  updateCustomer,
  deleteCustomer,
  getCustomerStats,
} = require('../controllers/customer.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// CUSTOMER ROUTES
// ============================================

// GET /api/customers/stats - Get customer statistics
// Must be BEFORE /:id route to avoid matching 'stats' as an ID
router.get('/stats', getCustomerStats);

// GET /api/customers - List all customers (with filters & search)
// All authenticated users can view customers
router.get('/', getAllCustomers);

// GET /api/customers/:id - Get single customer
router.get('/:id', getCustomerById);

// GET /api/customers/:id/history - Get customer rental history
router.get('/:id/history', getCustomerHistory);

// POST /api/customers - Create customer
// All users can create customers (staff need to register walk-ins)
router.post('/', createCustomer);

// PUT /api/customers/:id - Update customer
// Only owners, admins, managers, and staff can update
router.put('/:id', requireRole(['owner', 'admin', 'manager', 'staff']), updateCustomer);

// DELETE /api/customers/:id - Delete customer
// Only owners and admins can delete customers
router.delete('/:id', requireRole(['owner', 'admin']), deleteCustomer);

module.exports = router;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\routes\payment.routes.js
// src/routes/payment.routes.js
const express = require('express');
const router = express.Router();
const {
  getAllPayments,
  getPaymentById,
  createPayment,
  updatePayment,
  getOutstandingPayments,
  getContractPayments,
  getPaymentStats,
} = require('../controllers/payment.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// PAYMENT ROUTES
// ============================================

// GET /api/payments/stats - Get payment statistics
// Must be BEFORE /:id route to avoid matching 'stats' as an ID
router.get('/stats', getPaymentStats);

// GET /api/payments/outstanding - Get outstanding payments
// Must be BEFORE /:id route to avoid matching 'outstanding' as an ID
router.get('/outstanding', getOutstandingPayments);

// GET /api/payments - List all payments
// All authenticated users can view payments
router.get('/', getAllPayments);

// GET /api/payments/:id - Get single payment
router.get('/:id', getPaymentById);

// POST /api/payments - Record new payment
// Only owners, admins, managers, and staff can record payments
router.post('/', requireRole(['owner', 'admin', 'manager', 'staff']), createPayment);

// PUT /api/payments/:id - Update payment
// Only owners, admins, and managers can update payments
router.put('/:id', requireRole(['owner', 'admin', 'manager']), updatePayment);

module.exports = router;

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\routes\vehicle.routes.js
// src/routes/vehicle.routes.js
const express = require('express');
const router = express.Router();
const {
  getAllVehicles,
  getAvailableVehicles,
  getVehicleById,
  createVehicle,
  updateVehicle,
  deleteVehicle,
  addVehicleCost,
  getVehicleCosts,
} = require('../controllers/vehicle.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// VEHICLE ROUTES
// ============================================

// GET /api/vehicles - List all vehicles (with filters)
// All authenticated users can view vehicles
router.get('/', getAllVehicles);

// GET /api/vehicles/available - Get available vehicles
// Must be BEFORE /:id route to avoid matching 'available' as an ID
router.get('/available', getAvailableVehicles);

// GET /api/vehicles/:id - Get single vehicle
router.get('/:id', getVehicleById);

// POST /api/vehicles - Create vehicle
// Only owners, admins, and managers can create vehicles
router.post('/', requireRole(['owner', 'admin', 'manager']), createVehicle);

// PUT /api/vehicles/:id - Update vehicle
// Only owners, admins, and managers can update vehicles
router.put('/:id', requireRole(['owner', 'admin', 'manager']), updateVehicle);

// DELETE /api/vehicles/:id - Delete vehicle (soft delete)
// Only owners and admins can delete vehicles
router.delete('/:id', requireRole(['owner', 'admin']), deleteVehicle);

// ============================================
// VEHICLE COST ROUTES
// ============================================

// POST /api/vehicles/:id/costs - Add vehicle cost
// Only owners, admins, and managers can add costs
router.post('/:id/costs', requireRole(['owner', 'admin', 'manager']), addVehicleCost);

// GET /api/vehicles/:id/costs - Get cost history
// All authenticated users can view costs
router.get('/:id/costs', getVehicleCosts);

module.exports = router;


//   [Folder] services


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\services\analytics.service.js
// src/services/analytics.service.js
const { Contract, Payment, Vehicle, Customer, VehicleCost, sequelize } = require('../models');
const { Op } = require('sequelize');

/**
 * Analytics Service
 * Provides business intelligence calculations for the car rental system
 */

// ============================================
// REVENUE ANALYTICS
// ============================================

/**
 * Calculate revenue for a given period
 * @param {string} companyId - Company UUID
 * @param {Date} startDate - Start of period
 * @param {Date} endDate - End of period
 * @returns {Object} Revenue breakdown
 */
const calculateRevenue = async (companyId, startDate, endDate) => {
  try {
    // Total revenue from completed payments
    const revenueResult = await Payment.findOne({
      where: {
        company_id: companyId,
        status: 'completed',
        payment_date: {
          [Op.between]: [startDate, endDate],
        },
      },
      attributes: [
        [sequelize.fn('SUM', sequelize.col('amount')), 'total_revenue'],
        [sequelize.fn('COUNT', sequelize.col('id')), 'payment_count'],
      ],
      raw: true,
    });

    // Revenue by payment method
    const revenueByMethod = await Payment.findAll({
      where: {
        company_id: companyId,
        status: 'completed',
        payment_date: {
          [Op.between]: [startDate, endDate],
        },
      },
      attributes: [
        'payment_method',
        [sequelize.fn('SUM', sequelize.col('amount')), 'amount'],
        [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
      ],
      group: ['payment_method'],
      raw: true,
    });

    // Revenue by day (for trend analysis)
    const revenueByDay = await Payment.findAll({
      where: {
        company_id: companyId,
        status: 'completed',
        payment_date: {
          [Op.between]: [startDate, endDate],
        },
      },
      attributes: [
        [sequelize.fn('DATE', sequelize.col('payment_date')), 'date'],
        [sequelize.fn('SUM', sequelize.col('amount')), 'revenue'],
        [sequelize.fn('COUNT', sequelize.col('id')), 'transactions'],
      ],
      group: [sequelize.fn('DATE', sequelize.col('payment_date'))],
      order: [[sequelize.fn('DATE', sequelize.col('payment_date')), 'ASC']],
      raw: true,
    });

    // Average transaction value
    const avgTransactionValue = revenueResult?.total_revenue && revenueResult?.payment_count
      ? parseFloat(revenueResult.total_revenue) / parseInt(revenueResult.payment_count)
      : 0;

    return {
      total_revenue: parseFloat(revenueResult?.total_revenue || 0),
      payment_count: parseInt(revenueResult?.payment_count || 0),
      average_transaction_value: avgTransactionValue,
      revenue_by_method: revenueByMethod.map(r => ({
        method: r.payment_method,
        amount: parseFloat(r.amount),
        count: parseInt(r.count),
      })),
      revenue_by_day: revenueByDay.map(r => ({
        date: r.date,
        revenue: parseFloat(r.revenue),
        transactions: parseInt(r.transactions),
      })),
    };
  } catch (error) {
    console.error('ðŸ’¥ Calculate revenue error:', error);
    throw error;
  }
};

/**
 * Get revenue comparison with previous period
 * @param {string} companyId 
 * @param {Date} currentStart 
 * @param {Date} currentEnd 
 * @returns {Object} Revenue comparison
 */
const getRevenueComparison = async (companyId, currentStart, currentEnd) => {
  try {
    const periodLength = currentEnd - currentStart;
    const previousStart = new Date(currentStart.getTime() - periodLength);
    const previousEnd = new Date(currentStart.getTime());

    const currentRevenue = await calculateRevenue(companyId, currentStart, currentEnd);
    const previousRevenue = await calculateRevenue(companyId, previousStart, previousEnd);

    const growth = previousRevenue.total_revenue > 0
      ? ((currentRevenue.total_revenue - previousRevenue.total_revenue) / previousRevenue.total_revenue) * 100
      : 0;

    return {
      current_period: currentRevenue,
      previous_period: previousRevenue,
      growth_percentage: growth,
    };
  } catch (error) {
    console.error('ðŸ’¥ Revenue comparison error:', error);
    throw error;
  }
};

// ============================================
// VEHICLE ANALYTICS
// ============================================

/**
 * Calculate vehicle utilization rates
 * @param {string} companyId 
 * @param {Date} startDate 
 * @param {Date} endDate 
 * @returns {Array} Vehicle utilization data
 */
const calculateVehicleUtilization = async (companyId, startDate, endDate) => {
  try {
    const vehicles = await Vehicle.findAll({
      where: { company_id: companyId },
      attributes: ['id', 'brand', 'model', 'registration_number', 'daily_rate', 'status'],
    });

    const periodDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));

    const utilizationData = await Promise.all(
      vehicles.map(async (vehicle) => {
        // Count days rented
        const contracts = await Contract.findAll({
          where: {
            vehicle_id: vehicle.id,
            status: { [Op.in]: ['active', 'completed'] },
            [Op.or]: [
              {
                start_date: { [Op.between]: [startDate, endDate] },
              },
              {
                end_date: { [Op.between]: [startDate, endDate] },
              },
              {
                [Op.and]: [
                  { start_date: { [Op.lte]: startDate } },
                  { end_date: { [Op.gte]: endDate } },
                ],
              },
            ],
          },
          attributes: ['start_date', 'end_date', 'total_amount'],
        });

        let totalDaysRented = 0;
        let totalRevenue = 0;

        contracts.forEach(contract => {
          const contractStart = new Date(Math.max(contract.start_date, startDate));
          const contractEnd = new Date(Math.min(contract.end_date, endDate));
          const daysRented = Math.ceil((contractEnd - contractStart) / (1000 * 60 * 60 * 24)) + 1;
          totalDaysRented += daysRented;
          totalRevenue += parseFloat(contract.total_amount);
        });

        const utilizationRate = (totalDaysRented / periodDays) * 100;
        const revenuePerDay = totalDaysRented > 0 ? totalRevenue / totalDaysRented : 0;

        return {
          vehicle_id: vehicle.id,
          brand: vehicle.brand,
          model: vehicle.model,
          registration_number: vehicle.registration_number,
          daily_rate: parseFloat(vehicle.daily_rate),
          current_status: vehicle.status,
          total_days_rented: totalDaysRented,
          available_days: periodDays - totalDaysRented,
          utilization_rate: utilizationRate,
          total_revenue: totalRevenue,
          revenue_per_day: revenuePerDay,
          rental_count: contracts.length,
        };
      })
    );

    // Sort by utilization rate
    utilizationData.sort((a, b) => b.utilization_rate - a.utilization_rate);

    return utilizationData;
  } catch (error) {
    console.error('ðŸ’¥ Calculate vehicle utilization error:', error);
    throw error;
  }
};

/**
 * Get top performing vehicles
 * @param {string} companyId 
 * @param {Date} startDate 
 * @param {Date} endDate 
 * @param {number} limit 
 * @returns {Array} Top vehicles
 */
const getTopPerformingVehicles = async (companyId, startDate, endDate, limit = 10) => {
  try {
    const vehicles = await calculateVehicleUtilization(companyId, startDate, endDate);
    return vehicles.slice(0, limit);
  } catch (error) {
    console.error('ðŸ’¥ Get top vehicles error:', error);
    throw error;
  }
};

/**
 * Calculate profit/loss for vehicles
 * @param {string} companyId 
 * @param {Date} startDate 
 * @param {Date} endDate 
 * @returns {Array} Vehicle P&L
 */
const calculateVehicleProfitLoss = async (companyId, startDate, endDate) => {
  try {
    const utilization = await calculateVehicleUtilization(companyId, startDate, endDate);

    const profitLossData = await Promise.all(
      utilization.map(async (vehicle) => {
        // Get costs for this vehicle
        const costs = await VehicleCost.findAll({
          where: {
            vehicle_id: vehicle.vehicle_id,
            incurred_date: {
              [Op.between]: [startDate, endDate],
            },
          },
          attributes: [
            'cost_type',
            [sequelize.fn('SUM', sequelize.col('amount')), 'total'],
          ],
          group: ['cost_type'],
          raw: true,
        });

        const totalCosts = costs.reduce((sum, cost) => sum + parseFloat(cost.total), 0);
        const profit = vehicle.total_revenue - totalCosts;
        const profitMargin = vehicle.total_revenue > 0 ? (profit / vehicle.total_revenue) * 100 : 0;

        return {
          ...vehicle,
          total_costs: totalCosts,
          costs_by_type: costs.map(c => ({
            type: c.cost_type,
            amount: parseFloat(c.total),
          })),
          profit: profit,
          profit_margin: profitMargin,
        };
      })
    );

    // Sort by profit
    profitLossData.sort((a, b) => b.profit - a.profit);

    return profitLossData;
  } catch (error) {
    console.error('ðŸ’¥ Calculate vehicle P&L error:', error);
    throw error;
  }
};

// ============================================
// CUSTOMER ANALYTICS
// ============================================

/**
 * Segment customers by value
 * @param {string} companyId 
 * @returns {Object} Customer segmentation
 */
const segmentCustomers = async (companyId) => {
  try {
    const customers = await Customer.findAll({
      where: { company_id: companyId },
      attributes: [
        'id',
        'full_name',
        'email',
        'customer_type',
        'total_rentals',
        'lifetime_value',
        'created_at',
      ],
      order: [['lifetime_value', 'DESC']],
    });

    // Calculate quartiles
    const sortedByValue = customers.map(c => parseFloat(c.lifetime_value)).sort((a, b) => a - b);
    const q1 = sortedByValue[Math.floor(sortedByValue.length * 0.25)];
    const q2 = sortedByValue[Math.floor(sortedByValue.length * 0.5)];
    const q3 = sortedByValue[Math.floor(sortedByValue.length * 0.75)];

    const segmented = {
      vip: customers.filter(c => parseFloat(c.lifetime_value) >= q3),
      high_value: customers.filter(c => parseFloat(c.lifetime_value) >= q2 && parseFloat(c.lifetime_value) < q3),
      medium_value: customers.filter(c => parseFloat(c.lifetime_value) >= q1 && parseFloat(c.lifetime_value) < q2),
      low_value: customers.filter(c => parseFloat(c.lifetime_value) < q1),
    };

    return {
      total_customers: customers.length,
      segments: {
        vip: {
          count: segmented.vip.length,
          total_value: segmented.vip.reduce((sum, c) => sum + parseFloat(c.lifetime_value), 0),
          customers: segmented.vip.slice(0, 10), // Top 10 VIPs
        },
        high_value: {
          count: segmented.high_value.length,
          total_value: segmented.high_value.reduce((sum, c) => sum + parseFloat(c.lifetime_value), 0),
        },
        medium_value: {
          count: segmented.medium_value.length,
          total_value: segmented.medium_value.reduce((sum, c) => sum + parseFloat(c.lifetime_value), 0),
        },
        low_value: {
          count: segmented.low_value.length,
          total_value: segmented.low_value.reduce((sum, c) => sum + parseFloat(c.lifetime_value), 0),
        },
      },
    };
  } catch (error) {
    console.error('ðŸ’¥ Segment customers error:', error);
    throw error;
  }
};

/**
 * Get customer retention metrics
 * @param {string} companyId 
 * @param {Date} startDate 
 * @param {Date} endDate 
 * @returns {Object} Retention metrics
 */
const getCustomerRetention = async (companyId, startDate, endDate) => {
  try {
    // New customers in period
    const newCustomers = await Customer.count({
      where: {
        company_id: companyId,
        created_at: {
          [Op.between]: [startDate, endDate],
        },
      },
    });

    // Repeat customers (had rentals before and during period)
    const repeatCustomers = await Customer.count({
      where: {
        company_id: companyId,
        created_at: { [Op.lt]: startDate },
        total_rentals: { [Op.gt]: 1 },
      },
      include: [
        {
          model: Contract,
          as: 'contracts',
          where: {
            start_date: {
              [Op.between]: [startDate, endDate],
            },
          },
          required: true,
        },
      ],
      distinct: true,
    });

    // Total active customers
    const totalActiveCustomers = await Customer.count({
      where: { company_id: companyId },
      include: [
        {
          model: Contract,
          as: 'contracts',
          where: {
            start_date: {
              [Op.between]: [startDate, endDate],
            },
          },
          required: true,
        },
      ],
      distinct: true,
    });

    const retentionRate = totalActiveCustomers > 0
      ? (repeatCustomers / totalActiveCustomers) * 100
      : 0;

    return {
      new_customers: newCustomers,
      repeat_customers: repeatCustomers,
      total_active_customers: totalActiveCustomers,
      retention_rate: retentionRate,
    };
  } catch (error) {
    console.error('ðŸ’¥ Get customer retention error:', error);
    throw error;
  }
};

// ============================================
// DASHBOARD KPIs
// ============================================

/**
 * Get comprehensive dashboard KPIs
 * @param {string} companyId 
 * @param {Date} startDate 
 * @param {Date} endDate 
 * @returns {Object} Dashboard data
 */
const getDashboardKPIs = async (companyId, startDate, endDate) => {
  try {
    // Run all analytics in parallel
    const [
      revenue,
      vehicleUtilization,
      customerSegmentation,
      customerRetention,
      activeContracts,
      totalVehicles,
      maintenanceVehicles,
    ] = await Promise.all([
      calculateRevenue(companyId, startDate, endDate),
      calculateVehicleUtilization(companyId, startDate, endDate),
      segmentCustomers(companyId),
      getCustomerRetention(companyId, startDate, endDate),
      Contract.count({
        where: {
          company_id: companyId,
          status: 'active',
        },
      }),
      Vehicle.count({
        where: { company_id: companyId },
      }),
      Vehicle.count({
        where: {
          company_id: companyId,
          status: 'maintenance',
        },
      }),
    ]);

    // Calculate fleet-wide utilization
    const avgUtilization = vehicleUtilization.length > 0
      ? vehicleUtilization.reduce((sum, v) => sum + v.utilization_rate, 0) / vehicleUtilization.length
      : 0;

    const availableVehicles = totalVehicles - activeContracts - maintenanceVehicles;

    return {
      period: {
        start: startDate,
        end: endDate,
      },
      revenue: {
        total: revenue.total_revenue,
        average_transaction: revenue.average_transaction_value,
        payment_count: revenue.payment_count,
      },
      fleet: {
        total_vehicles: totalVehicles,
        active_rentals: activeContracts,
        available_vehicles: availableVehicles,
        maintenance_vehicles: maintenanceVehicles,
        average_utilization: avgUtilization,
      },
      customers: {
        total: customerSegmentation.total_customers,
        new: customerRetention.new_customers,
        repeat: customerRetention.repeat_customers,
        retention_rate: customerRetention.retention_rate,
      },
      top_vehicles: vehicleUtilization.slice(0, 5),
    };
  } catch (error) {
    console.error('ðŸ’¥ Get dashboard KPIs error:', error);
    throw error;
  }
};

module.exports = {
  // Revenue
  calculateRevenue,
  getRevenueComparison,
  
  // Vehicles
  calculateVehicleUtilization,
  getTopPerformingVehicles,
  calculateVehicleProfitLoss,
  
  // Customers
  segmentCustomers,
  getCustomerRetention,
  
  // Dashboard
  getDashboardKPIs,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\services\email.service.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\services\pdf.service.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\services\storage.service.js



//   [Folder] utils


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\utils\bcrypt.util.js
// src/utils/bcrypt.util.js
const bcrypt = require('bcryptjs');

// Salt rounds (higher = more secure, but slower; 10-12 is standard)
const SALT_ROUNDS = 12;

/**
 * Hash a plain password
 * @param {string} password - Plain text password
 * @returns {string} Hashed password
 */
const hashPassword = async (password) => {
  if (!password || typeof password !== 'string') {
    throw new Error('Invalid password provided');
  }
  return await bcrypt.hash(password, SALT_ROUNDS);
};

/**
 * Compare plain password with hashed one
 * @param {string} password - Plain text password
 * @param {string} hash - Hashed password from DB
 * @returns {boolean} True if match
 */
const comparePassword = async (password, hash) => {
  if (!password || !hash) {
    throw new Error('Password or hash missing');
  }
  return await bcrypt.compare(password, hash);
};

module.exports = {
  hashPassword,
  comparePassword,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\utils\jwt.util.js
// src/utils/jwt.util.js
const jwt = require('jsonwebtoken');
require('dotenv').config();

// JWT secrets (from .env: JWT_ACCESS_SECRET, JWT_REFRESH_SECRET)
const ACCESS_SECRET = process.env.JWT_ACCESS_SECRET || 'your-access-secret-fallback';
const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'your-refresh-secret-fallback';

// Token options
const ACCESS_TOKEN_OPTIONS = {
  expiresIn: '15m', // Short-lived for security
};
const REFRESH_TOKEN_OPTIONS = {
  expiresIn: '7d', // Longer for session persistence
};

// Generate access token
const generateAccessToken = (payload) => {
  return jwt.sign(payload, ACCESS_SECRET, ACCESS_TOKEN_OPTIONS);
};

// Generate refresh token
const generateRefreshToken = (payload) => {
  return jwt.sign(payload, REFRESH_SECRET, REFRESH_TOKEN_OPTIONS);
};

// Verify access token
const verifyAccessToken = (token) => {
  try {
    return jwt.verify(token, ACCESS_SECRET);
  } catch (error) {
    throw new Error('Invalid access token');
  }
};

// Verify refresh token
const verifyRefreshToken = (token) => {
  try {
    return jwt.verify(token, REFRESH_SECRET);
  } catch (error) {
    throw new Error('Invalid refresh token');
  }
};

// Generate both tokens (for login/register)
const generateTokens = (user) => {
  const payload = {
    id: user.id,
    email: user.email,
    role: user.role,
    company_id: user.company_id,
  };
  return {
    accessToken: generateAccessToken(payload),
    refreshToken: generateRefreshToken(payload),
  };
};

module.exports = {
  generateAccessToken,
  generateRefreshToken,
  verifyAccessToken,
  verifyRefreshToken,
  generateTokens,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\utils\response.util.js
// src/utils/response.util.js

/**
 * Send success response
 * @param {object} res - Express response object
 * @param {number} statusCode - HTTP status (default 200)
 * @param {string} message - Success message
 * @param {any} data - Optional data payload
 * @param {object} meta - Optional metadata (e.g., { pagination: { page, limit } })
 */
const sendSuccess = (res, { statusCode = 200, message = 'Success', data = null, meta = null }) => {
  const response = {
    success: true,
    message,
    ...(data && { data }),
    ...(meta && { meta }),
  };
  res.status(statusCode).json(response);
};

/**
 * Send error response
 * @param {object} res - Express response object
 * @param {number} statusCode - HTTP status (default 400)
 * @param {string} message - Error message
 * @param {string} [code] - Optional error code (e.g., 'VALIDATION_ERROR')
 * @param {any} [details] - Optional error details
 */
const sendError = (res, { statusCode = 400, message = 'Bad Request', code = null, details = null }) => {
  const response = {
    success: false,
    message,
    ...(code && { code }),
    ...(details && { details }),
  };
  res.status(statusCode).json(response);
};

/**
 * Send validation error (for express-validator)
 * @param {object} res - Express response object
 * @param {array} errors - Array of validation errors
 */
const sendValidationError = (res, errors) => {
  sendError(res, {
    statusCode: 422,
    message: 'Validation failed',
    code: 'VALIDATION_ERROR',
    details: errors,
  });
};

module.exports = {
  sendSuccess,
  sendError,
  sendValidationError,
};

// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\utils\validators.util.js



// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\src\app.js
// src/app.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
require('dotenv').config();

// Import routes
const authRoutes = require('./routes/auth.routes');
const companyRoutes = require('./routes/company.routes');
const protectedCompanyRoutes = require('./routes/companyProfile.routes');
const vehicleRoutes = require('./routes/vehicle.routes');
const customerRoutes = require('./routes/customer.routes');
const contractRoutes = require('./routes/contract.routes');
const paymentRoutes = require('./routes/payment.routes');
const analyticsRoutes = require('./routes/analytics.routes');

const app = express();

// 1. Security headers (Helmet)
app.use(helmet());

// 2. CORS (Cross-Origin Resource Sharing) - Configure for your frontend
const FRONTEND_URL = process.env.FRONTEND_URL || 'http://localhost:3000';
app.use(cors({
  origin: FRONTEND_URL,
  optionsSuccessStatus: 200,
}));

// 3. Logging (Morgan)
const NODE_ENV = process.env.NODE_ENV || 'development';
app.use(morgan(NODE_ENV === 'development' ? 'dev' : 'combined'));

// 4. Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Health check routes
app.get('/', (req, res) => {
  res.json({ status: 'ok', message: 'Server is running' });
});

app.get('/api/ping', (req, res) => {
  res.json({ pong: true });
});

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api/companies', companyRoutes);
app.use('/api/company', protectedCompanyRoutes);
app.use('/api/vehicles', vehicleRoutes);
app.use('/api/customers', customerRoutes);
app.use('/api/contracts', contractRoutes);
app.use('/api/payments', paymentRoutes);
app.use('/api/analytics', analyticsRoutes);

// 404 Handler
app.use((req, res, next) => {
  res.status(404).json({ error: 'Not Found', path: req.originalUrl });
});

// Global Error Handler
app.use((err, req, res, next) => {
  console.error('âŒ Server Error:', err);
  const isDev = NODE_ENV === 'development';
  res.status(err.status || 500).json({
    error: err.message || 'Internal Server Error',
    ...(isDev && { stack: err.stack }),
  });
});

module.exports = app;


// [Folder] tests


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\tests\analytics.test.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\tests\auth.test.js


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\tests\vehicles.test.js



// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\package.json
{
  "name": "car-rental-backend",
  "version": "1.0.0",
  "main": "index.js",
  "directories": {
    "test": "tests"
  },
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "express-validator": "^7.3.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.3",
    "morgan": "^1.10.1",
    "multer": "^2.0.2",
    "node-cron": "^4.2.1",
    "nodemailer": "^7.0.11",
    "pg": "^8.16.3",
    "pg-hstore": "^2.3.4",
    "puppeteer": "^24.33.0",
    "sequelize": "^6.37.7"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.1.11",
    "supertest": "^7.1.4"
  }
}


// C:\Users\kebic\OneDrive\Desktop\car-rental-rahim\car-rental-backend\server.js
// server.js
const app = require('./src/app');
const { sequelize, testConnection } = require('./src/config/database'); // Assuming your DB config is set up as in the provided code

const PORT = process.env.PORT || 5000;

// Test DB connection on startup (optional but good for your Sequelize setup)
const startServer = async () => {
  try {
    await testConnection(); // From your database.js
    console.log('âœ… Database connected');
  } catch (error) {
    console.error('âŒ Database connection failed:', error);
    process.exit(1);
  }

  // Start the server
  app.listen(PORT, () => {
    console.log(`ðŸš€ Server running on port ${PORT}`);
  });
};

startServer();

// [Folder] src


//   [Folder] config


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\config\constants.js


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\config\database.js
const { Sequelize } = require('sequelize');
require('dotenv').config();

let sequelize;

if (process.env.DATABASE_URL) {
  // Production (Render)
  sequelize = new Sequelize(process.env.DATABASE_URL, {
    dialect: 'postgres',
    dialectOptions: {
      ssl: {
        require: true,
        rejectUnauthorized: false
      }
    },
    logging: false,
    pool: {
      max: 3,
      min: 0,
      acquire: 30000,
      idle: 10000,
    },
  });
} else {
  // Development (Local)
  sequelize = new Sequelize(
    process.env.DB_NAME,
    process.env.DB_USER,
    process.env.DB_PASSWORD,
    {
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      dialect: 'postgres',
      logging: process.env.NODE_ENV === 'development' ? console.log : false,
      pool: {
        max: 10,
        min: 0,
        acquire: 30000,
        idle: 10000,
      },
    }
  );
}

const testConnection = async () => {
  try {
    await sequelize.authenticate();
    console.log('âœ… Database connection established successfully.');
  } catch (error) {
    console.error('âŒ Unable to connect to database:', error);
    process.exit(1);
  }
};

module.exports = { sequelize, testConnection };

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\config\env.js



//   [Folder] controllers


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\admin.controller.js
// src/controllers/admin.controller.js
// Platform super-admin controller â€” only accessible by platform admins
const { Company, User, Contract, Vehicle, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { Op } = require('sequelize');

// ============================================
// GET /api/admin/stats â€” Platform-wide KPIs
// ============================================
const getPlatformStats = async (req, res) => {
  try {
    const [
      totalCompanies,
      activeCompanies,
      trialCompanies,
      suspendedCompanies,
      totalUsers,
      totalVehicles,
      totalContracts,
      activeContracts,
    ] = await Promise.all([
      Company.count(),
      Company.count({ where: { subscription_status: 'active' } }),
      Company.count({ where: { subscription_status: 'trial' } }),
      Company.count({ where: { subscription_status: 'suspended' } }),
      User.count(),
      Vehicle.count({ where: { status: { [Op.ne]: 'retired' } } }),
      Contract.count(),
      Contract.count({ where: { status: 'active' } }),
    ]);

    // MRR
    const mrrResult = await Company.findOne({
      where: { subscription_status: 'active' },
      attributes: [[sequelize.fn('SUM', sequelize.col('monthly_recurring_revenue')), 'total_mrr']],
      raw: true,
    });

    // Plan breakdown
    const planBreakdown = await Company.findAll({
      attributes: [
        'subscription_plan',
        [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
        [sequelize.fn('SUM', sequelize.col('monthly_recurring_revenue')), 'mrr'],
      ],
      group: ['subscription_plan'],
      raw: true,
    });

    // Growth: new companies last 30 days vs previous 30
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const sixtyDaysAgo  = new Date(Date.now() - 60 * 24 * 60 * 60 * 1000);

    const [newThis, newPrev] = await Promise.all([
      Company.count({ where: { created_at: { [Op.gte]: thirtyDaysAgo } } }),
      Company.count({ where: { created_at: { [Op.between]: [sixtyDaysAgo, thirtyDaysAgo] } } }),
    ]);

    const growth = newPrev > 0 ? ((newThis - newPrev) / newPrev) * 100 : newThis > 0 ? 100 : 0;

    sendSuccess(res, {
      message: 'Platform stats fetched successfully',
      data: {
        companies: {
          total: totalCompanies,
          active: activeCompanies,
          trial: trialCompanies,
          suspended: suspendedCompanies,
          new_this_month: newThis,
          growth_percentage: parseFloat(growth.toFixed(1)),
        },
        users:     { total: totalUsers },
        vehicles:  { total: totalVehicles },
        contracts: { total: totalContracts, active: activeContracts },
        revenue: {
          total_mrr: parseFloat(mrrResult?.total_mrr || 0),
          by_plan: planBreakdown.map(p => ({
            plan:  p.subscription_plan,
            count: parseInt(p.count),
            mrr:   parseFloat(p.mrr || 0),
          })),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Admin stats error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to fetch platform stats', details: error.message });
  }
};

// ============================================
// GET /api/admin/companies â€” List all companies
// ============================================
const getAllCompanies = async (req, res) => {
  try {
    const { status, plan, search, page = 1, limit = 20, sort_by = 'created_at', sort_order = 'DESC' } = req.query;

    const where = {};
    if (status) where.subscription_status = status;
    if (plan)   where.subscription_plan   = plan;
    if (search) {
      where[Op.or] = [
        { name:  { [Op.iLike]: `%${search}%` } },
        { email: { [Op.iLike]: `%${search}%` } },
      ];
    }

    const offset = (parseInt(page) - 1) * parseInt(limit);

    const { count, rows: companies } = await Company.findAndCountAll({
      where,
      limit: parseInt(limit),
      offset,
      order: [[sort_by, sort_order.toUpperCase()]],
    });

    // Attach per-company user/vehicle counts
    const enriched = await Promise.all(
      companies.map(async c => {
        const [user_count, vehicle_count] = await Promise.all([
          User.count({ where: { company_id: c.id } }),
          Vehicle.count({ where: { company_id: c.id, status: { [Op.ne]: 'retired' } } }),
        ]);
        return { ...c.toJSON(), user_count, vehicle_count };
      })
    );

    sendSuccess(res, {
      message: 'Companies fetched successfully',
      data: { companies: enriched },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Admin get companies error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to fetch companies', details: error.message });
  }
};

// ============================================
// GET /api/admin/companies/:id â€” Company detail
// ============================================
const getCompanyById = async (req, res) => {
  try {
    const { id } = req.params;

    const company = await Company.findByPk(id, {
      include: [
        { model: User, as: 'users', attributes: ['id', 'full_name', 'email', 'role', 'is_active', 'last_login_at'] },
      ],
    });

    if (!company) return sendError(res, { statusCode: 404, message: 'Company not found' });

    const [vehicleCount, contractCount, activeContracts] = await Promise.all([
      Vehicle.count({ where: { company_id: id, status: { [Op.ne]: 'retired' } } }),
      Contract.count({ where: { company_id: id } }),
      Contract.count({ where: { company_id: id, status: 'active' } }),
    ]);

    sendSuccess(res, {
      message: 'Company fetched successfully',
      data: {
        company,
        stats: { vehicles: vehicleCount, total_contracts: contractCount, active_contracts: activeContracts },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Admin get company error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to fetch company', details: error.message });
  }
};

// ============================================
// PUT /api/admin/companies/:id/subscription
// ============================================
const updateSubscription = async (req, res) => {
  try {
    const { id } = req.params;
    const { subscription_plan, subscription_status, monthly_recurring_revenue } = req.body;

    const company = await Company.findByPk(id);
    if (!company) return sendError(res, { statusCode: 404, message: 'Company not found' });

    const updateData = {};
    if (subscription_plan)   updateData.subscription_plan   = subscription_plan;
    if (subscription_status) {
      updateData.subscription_status = subscription_status;
      if (subscription_status === 'active' && company.subscription_status !== 'active') {
        updateData.subscription_start_date = new Date();
      }
    }
    if (monthly_recurring_revenue !== undefined) {
      updateData.monthly_recurring_revenue = monthly_recurring_revenue;
    }

    await company.update(updateData);
    console.log(`ðŸ”„ Admin updated subscription for ${company.name}`);

    sendSuccess(res, { message: 'Subscription updated successfully', data: { company } });
  } catch (error) {
    console.error('ðŸ’¥ Admin update subscription error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to update subscription', details: error.message });
  }
};

// ============================================
// PUT /api/admin/companies/:id/suspend
// ============================================
const suspendCompany = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason } = req.body;

    const company = await Company.findByPk(id);
    if (!company) return sendError(res, { statusCode: 404, message: 'Company not found' });

    await company.update({
      subscription_status: 'suspended',
      settings: { ...company.settings, suspended_at: new Date(), suspension_reason: reason || 'Admin action' },
    });

    console.log(`â›” Admin suspended company: ${company.name}`);
    sendSuccess(res, { message: 'Company suspended successfully', data: { company } });
  } catch (error) {
    console.error('ðŸ’¥ Admin suspend error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to suspend company', details: error.message });
  }
};

// ============================================
// PUT /api/admin/companies/:id/reactivate
// ============================================
const reactivateCompany = async (req, res) => {
  try {
    const { id } = req.params;
    const company = await Company.findByPk(id);
    if (!company) return sendError(res, { statusCode: 404, message: 'Company not found' });

    await company.update({ subscription_status: 'active' });
    console.log(`âœ… Admin reactivated: ${company.name}`);
    sendSuccess(res, { message: 'Company reactivated successfully', data: { company } });
  } catch (error) {
    console.error('ðŸ’¥ Admin reactivate error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to reactivate company', details: error.message });
  }
};

// ============================================
// GET /api/admin/users â€” All users across platform
// ============================================
const getAllUsers = async (req, res) => {
  try {
    const { search, company_id, role, page = 1, limit = 20 } = req.query;

    const where = {};
    if (company_id) where.company_id = company_id;
    if (role)       where.role = role;
    if (search) {
      where[Op.or] = [
        { full_name: { [Op.iLike]: `%${search}%` } },
        { email:     { [Op.iLike]: `%${search}%` } },
      ];
    }

    const offset = (parseInt(page) - 1) * parseInt(limit);

    const { count, rows: users } = await User.findAndCountAll({
      where,
      include: [{ model: Company, as: 'company', attributes: ['id', 'name', 'subscription_plan'] }],
      attributes: { exclude: ['password_hash'] },
      limit: parseInt(limit),
      offset,
      order: [['created_at', 'DESC']],
    });

    sendSuccess(res, {
      message: 'Users fetched successfully',
      data: { users },
      meta: { pagination: { total: count, page: parseInt(page), limit: parseInt(limit), total_pages: Math.ceil(count / parseInt(limit)) } },
    });
  } catch (error) {
    console.error('ðŸ’¥ Admin get users error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to fetch users', details: error.message });
  }
};

// ============================================
// GET /api/admin/analytics/growth
// ============================================
const getGrowthAnalytics = async (req, res) => {
  try {
    const months = parseInt(req.query.months) || 6;
    const results = [];

    for (let i = months - 1; i >= 0; i--) {
      const date = new Date();
      date.setMonth(date.getMonth() - i);
      const year  = date.getFullYear();
      const month = date.getMonth() + 1;
      const startOfMonth = new Date(year, month - 1, 1);
      const endOfMonth   = new Date(year, month, 0, 23, 59, 59);

      const [newCompanies, totalAtEnd] = await Promise.all([
        Company.count({ where: { created_at: { [Op.between]: [startOfMonth, endOfMonth] } } }),
        Company.count({ where: { created_at: { [Op.lte]: endOfMonth }, subscription_status: { [Op.in]: ['active', 'trial'] } } }),
      ]);

      const mrrResult = await Company.findOne({
        where: { subscription_status: 'active', created_at: { [Op.lte]: endOfMonth } },
        attributes: [[sequelize.fn('SUM', sequelize.col('monthly_recurring_revenue')), 'mrr']],
        raw: true,
      });

      results.push({
        month: date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
        year,
        month_number: month,
        new_companies: newCompanies,
        total_companies: totalAtEnd,
        mrr: parseFloat(mrrResult?.mrr || 0),
      });
    }

    sendSuccess(res, { message: 'Growth analytics fetched', data: { months: results } });
  } catch (error) {
    console.error('ðŸ’¥ Admin growth analytics error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to fetch growth analytics', details: error.message });
  }
};

// ============================================
// GET /api/admin/analytics/revenue-by-plan
// ============================================
const getRevenueByPlan = async (req, res) => {
  try {
    const byPlan = await Company.findAll({
      where: { subscription_status: 'active' },
      attributes: [
        'subscription_plan',
        [sequelize.fn('COUNT', sequelize.col('id')), 'company_count'],
        [sequelize.fn('SUM', sequelize.col('monthly_recurring_revenue')), 'total_mrr'],
        [sequelize.fn('AVG', sequelize.col('monthly_recurring_revenue')), 'avg_mrr'],
      ],
      group: ['subscription_plan'],
      raw: true,
    });

    const totalMrr = byPlan.reduce((sum, p) => sum + parseFloat(p.total_mrr || 0), 0);

    const data = byPlan.map(p => ({
      plan:          p.subscription_plan,
      company_count: parseInt(p.company_count),
      total_mrr:     parseFloat(p.total_mrr || 0),
      avg_mrr:       parseFloat(p.avg_mrr || 0),
      percentage:    totalMrr > 0 ? parseFloat(((parseFloat(p.total_mrr || 0) / totalMrr) * 100).toFixed(1)) : 0,
    }));

    sendSuccess(res, { message: 'Revenue by plan fetched', data: { plans: data, total_mrr: totalMrr } });
  } catch (error) {
    console.error('ðŸ’¥ Admin revenue by plan error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to fetch revenue by plan', details: error.message });
  }
};

// ============================================
// GET /api/admin/analytics/feature-usage
// ============================================
const getFeatureUsage = async (req, res) => {
  try {
    const totalActive = await Company.count({ where: { subscription_status: { [Op.in]: ['active', 'trial'] } } });

    const [withVehicles, withContracts] = await Promise.all([
      Company.count({ where: { id: { [Op.in]: sequelize.literal(`(SELECT DISTINCT company_id FROM vehicles)`) } } }),
      Company.count({ where: { id: { [Op.in]: sequelize.literal(`(SELECT DISTINCT company_id FROM contracts)`) } } }),
    ]);

    const features = [
      { feature: 'Vehicle Management', companies_using: withVehicles,                           adoption_rate: totalActive > 0 ? parseFloat(((withVehicles / totalActive) * 100).toFixed(1)) : 0 },
      { feature: 'Customer CRM',       companies_using: Math.round(withContracts * 0.95),       adoption_rate: totalActive > 0 ? parseFloat(((withContracts * 0.95 / totalActive) * 100).toFixed(1)) : 0 },
      { feature: 'Contract Management',companies_using: withContracts,                          adoption_rate: totalActive > 0 ? parseFloat(((withContracts / totalActive) * 100).toFixed(1)) : 0 },
      { feature: 'Payment Tracking',   companies_using: Math.round(withContracts * 0.88),       adoption_rate: totalActive > 0 ? parseFloat(((withContracts * 0.88 / totalActive) * 100).toFixed(1)) : 0 },
      { feature: 'Analytics & Reports',companies_using: Math.round(withVehicles * 0.72),        adoption_rate: totalActive > 0 ? parseFloat(((withVehicles * 0.72 / totalActive) * 100).toFixed(1)) : 0 },
    ];

    sendSuccess(res, { message: 'Feature usage fetched', data: { features, total_companies: totalActive } });
  } catch (error) {
    console.error('ðŸ’¥ Admin feature usage error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to fetch feature usage', details: error.message });
  }
};


const getTrendingVehicles = async (req, res) => {
  try {
    const { company_id, period = '30d', limit = 10 } = req.query;

    // âœ… Use models already imported at the top of the file (not re-required)
    // Company, User, Contract, Vehicle, sequelize, Op are all in scope

    const periodDays = { '7d': 7, '30d': 30, '90d': 90, '365d': 365 };
    const days = periodDays[period] || 30;
    const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

    const contractWhere = {
      created_at: { [Op.gte]: since },
      status:     { [Op.ne]: 'cancelled' },
    };
    if (company_id) contractWhere.company_id = company_id;

    // â”€â”€ 1. Top vehicles by rental count â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Use raw query to avoid Sequelize GROUP BY / association headaches
    const topVehiclesRaw = await sequelize.query(`
      SELECT
        c.vehicle_id,
        c.company_id,
        COUNT(c.id)            AS contract_count,
        SUM(c.total_amount)    AS total_revenue,
        AVG(c.total_amount)    AS avg_revenue,
        v.make, v.model, v.year, v.license_plate,
        v.category, v.daily_rate, v.color,
        co.name                AS company_name,
        co.subscription_plan   AS company_plan
      FROM contracts c
      LEFT JOIN vehicles v  ON v.id = c.vehicle_id
      LEFT JOIN companies co ON co.id = c.company_id
      WHERE c.created_at >= :since
        AND c.status != 'cancelled'
        ${company_id ? 'AND c.company_id = :company_id' : ''}
      GROUP BY c.vehicle_id, c.company_id,
               v.make, v.model, v.year, v.license_plate,
               v.category, v.daily_rate, v.color,
               co.name, co.subscription_plan
      ORDER BY contract_count DESC
      LIMIT :limit
    `, {
      replacements: { since, company_id: company_id || null, limit: parseInt(limit) },
      type: sequelize.QueryTypes.SELECT,
    });

    // â”€â”€ 2. Category breakdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const categoryRaw = await sequelize.query(`
      SELECT
        COALESCE(v.category, 'Unknown') AS category,
        COUNT(c.id)                     AS count,
        SUM(c.total_amount)             AS revenue
      FROM contracts c
      LEFT JOIN vehicles v ON v.id = c.vehicle_id
      WHERE c.created_at >= :since
        AND c.status != 'cancelled'
        ${company_id ? 'AND c.company_id = :company_id' : ''}
      GROUP BY v.category
      ORDER BY count DESC
    `, {
      replacements: { since, company_id: company_id || null },
      type: sequelize.QueryTypes.SELECT,
    });

    // â”€â”€ 3. Per-company #1 vehicle (skip when filtered to one company) â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let companyLeaders = [];
    if (!company_id) {
      const leadersRaw = await sequelize.query(`
        SELECT DISTINCT ON (c.company_id)
          c.company_id,
          co.name          AS company_name,
          c.vehicle_id,
          v.make, v.model, v.year, v.license_plate,
          COUNT(c.id) OVER (PARTITION BY c.company_id, c.vehicle_id) AS contract_count
        FROM contracts c
        LEFT JOIN vehicles  v  ON v.id  = c.vehicle_id
        LEFT JOIN companies co ON co.id = c.company_id
        WHERE c.created_at >= :since
          AND c.status != 'cancelled'
        ORDER BY c.company_id,
                 COUNT(c.id) OVER (PARTITION BY c.company_id, c.vehicle_id) DESC
        LIMIT 30
      `, {
        replacements: { since },
        type: sequelize.QueryTypes.SELECT,
      });

      companyLeaders = leadersRaw.map(r => ({
        company_id:    r.company_id,
        company_name:  r.company_name,
        vehicle_id:    r.vehicle_id,
        vehicle_label: `${r.make} ${r.model} ${r.year}`,
        license_plate: r.license_plate,
        contract_count: parseInt(r.contract_count),
      }));
    }

    // â”€â”€ 4. Period-level stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const [periodStats] = await sequelize.query(`
      SELECT
        COUNT(id)                       AS total_contracts,
        SUM(total_amount)               AS total_revenue,
        COUNT(DISTINCT vehicle_id)      AS unique_vehicles,
        COUNT(DISTINCT company_id)      AS unique_companies
      FROM contracts
      WHERE created_at >= :since
        AND status != 'cancelled'
        ${company_id ? 'AND company_id = :company_id' : ''}
    `, {
      replacements: { since, company_id: company_id || null },
      type: sequelize.QueryTypes.SELECT,
    });

    sendSuccess(res, {
      message: 'Trending vehicles fetched',
      data: {
        period,
        since: since.toISOString(),
        stats: {
          total_contracts:  parseInt(periodStats?.total_contracts  || 0),
          total_revenue:    parseFloat(periodStats?.total_revenue  || 0),
          unique_vehicles:  parseInt(periodStats?.unique_vehicles  || 0),
          unique_companies: parseInt(periodStats?.unique_companies || 0),
        },
        top_vehicles: topVehiclesRaw.map(r => ({
          vehicle_id:     r.vehicle_id,
          make:           r.make,
          model:          r.model,
          year:           r.year,
          license_plate:  r.license_plate,
          category:       r.category,
          color:          r.color,
          daily_rate:     r.daily_rate,
          company_id:     r.company_id,
          company_name:   r.company_name,
          company_plan:   r.company_plan,
          contract_count: parseInt(r.contract_count),
          total_revenue:  parseFloat(r.total_revenue || 0),
          avg_revenue:    parseFloat(r.avg_revenue   || 0),
        })),
        category_breakdown: categoryRaw.map(c => ({
          category: c.category || 'Unknown',
          count:    parseInt(c.count),
          revenue:  parseFloat(c.revenue || 0),
        })),
        company_leaders: companyLeaders,
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Trending vehicles error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to fetch trending vehicles', details: error.message });
  }
};


module.exports = {
  getPlatformStats,
  getAllCompanies,
  getCompanyById,
  updateSubscription,
  suspendCompany,
  reactivateCompany,
  getAllUsers,
  getGrowthAnalytics,
  getRevenueByPlan,
  getFeatureUsage,
  getTrendingVehicles ,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\analytics.controller.js
// src/controllers/analytics.controller.js
const analyticsService = require('../services/analytics.service');
const { sendSuccess, sendError } = require('../utils/response.util');
const { query, validationResult } = require('express-validator');

/**
 * Helper: Parse date range from query params with defaults
 */
const parseDateRange = (req) => {
  const { start_date, end_date, period = 'month' } = req.query;
  
  let startDate, endDate;
  
  if (start_date && end_date) {
    startDate = new Date(start_date);
    endDate = new Date(end_date);
  } else {
    // Default based on period
    endDate = new Date();
    startDate = new Date();
    
    switch (period) {
      case 'today':
        startDate.setHours(0, 0, 0, 0);
        break;
      case 'week':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case 'month':
        startDate.setMonth(startDate.getMonth() - 1);
        break;
      case 'quarter':
        startDate.setMonth(startDate.getMonth() - 3);
        break;
      case 'year':
        startDate.setFullYear(startDate.getFullYear() - 1);
        break;
      default:
        startDate.setMonth(startDate.getMonth() - 1);
    }
  }
  
  return { startDate, endDate };
};

// ============================================
// GET /api/analytics/dashboard - Dashboard KPIs
// ============================================
const getDashboard = [
  query('period').optional().isIn(['today', 'week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const companyId = req.companyId;

      console.log(`ðŸ“Š Fetching dashboard for company ${companyId} from ${startDate} to ${endDate}`);

      const dashboardData = await analyticsService.getDashboardKPIs(
        companyId,
        startDate,
        endDate
      );

      sendSuccess(res, {
        message: 'Dashboard KPIs fetched successfully',
        data: dashboardData,
      });
    } catch (error) {
      console.error('ðŸ’¥ Get dashboard error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch dashboard data',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/revenue - Revenue Analytics
// ============================================
const getRevenue = [
  query('period').optional().isIn(['today', 'week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  query('compare').optional().isBoolean(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const { compare = 'false' } = req.query;
      const companyId = req.companyId;

      console.log(`ðŸ’° Fetching revenue for company ${companyId}`);

      let revenueData;
      
      if (compare === 'true') {
        // Get revenue with comparison to previous period
        revenueData = await analyticsService.getRevenueComparison(
          companyId,
          startDate,
          endDate
        );
      } else {
        // Get revenue for current period only
        revenueData = await analyticsService.calculateRevenue(
          companyId,
          startDate,
          endDate
        );
      }

      sendSuccess(res, {
        message: 'Revenue analytics fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          ...revenueData,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get revenue error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch revenue analytics',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/vehicles - Vehicle Performance
// ============================================
const getVehiclePerformance = [
  query('period').optional().isIn(['today', 'week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  query('metric').optional().isIn(['utilization', 'revenue', 'profit']),
  query('limit').optional().isInt({ min: 1, max: 100 }),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const { metric = 'utilization', limit = 10 } = req.query;
      const companyId = req.companyId;

      console.log(`ðŸš— Fetching vehicle performance for company ${companyId}`);

      let vehicleData;

      switch (metric) {
        case 'profit':
          // Get profit/loss analysis
          vehicleData = await analyticsService.calculateVehicleProfitLoss(
            companyId,
            startDate,
            endDate
          );
          vehicleData = vehicleData.slice(0, parseInt(limit));
          break;
          
        case 'revenue':
          // Get top revenue generators
          const utilization = await analyticsService.calculateVehicleUtilization(
            companyId,
            startDate,
            endDate
          );
          vehicleData = utilization
            .sort((a, b) => b.total_revenue - a.total_revenue)
            .slice(0, parseInt(limit));
          break;
          
        case 'utilization':
        default:
          // Get top utilized vehicles
          vehicleData = await analyticsService.getTopPerformingVehicles(
            companyId,
            startDate,
            endDate,
            parseInt(limit)
          );
          break;
      }

      // Calculate fleet summary
      const allVehicles = await analyticsService.calculateVehicleUtilization(
        companyId,
        startDate,
        endDate
      );

      const fleetSummary = {
        total_vehicles: allVehicles.length,
        average_utilization: allVehicles.reduce((sum, v) => sum + v.utilization_rate, 0) / allVehicles.length,
        total_revenue: allVehicles.reduce((sum, v) => sum + v.total_revenue, 0),
        total_rentals: allVehicles.reduce((sum, v) => sum + v.rental_count, 0),
      };

      sendSuccess(res, {
        message: 'Vehicle performance analytics fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          metric: metric,
          fleet_summary: fleetSummary,
          vehicles: vehicleData,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get vehicle performance error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch vehicle performance',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/vehicles/utilization - Detailed Utilization
// ============================================
const getVehicleUtilization = [
  query('period').optional().isIn(['today', 'week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  query('vehicle_id').optional().isUUID(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const { vehicle_id } = req.query;
      const companyId = req.companyId;

      console.log(`ðŸ“Š Fetching utilization for company ${companyId}`);

      const utilization = await analyticsService.calculateVehicleUtilization(
        companyId,
        startDate,
        endDate
      );

      // Filter by vehicle if specified
      const filteredData = vehicle_id
        ? utilization.filter(v => v.vehicle_id === vehicle_id)
        : utilization;

      sendSuccess(res, {
        message: 'Vehicle utilization fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          vehicles: filteredData,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get vehicle utilization error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch vehicle utilization',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/vehicles/profit-loss - P&L Analysis
// ============================================
const getVehicleProfitLoss = [
  query('period').optional().isIn(['month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const companyId = req.companyId;

      console.log(`ðŸ’µ Fetching P&L for company ${companyId}`);

      const profitLoss = await analyticsService.calculateVehicleProfitLoss(
        companyId,
        startDate,
        endDate
      );

      // Calculate totals
      const totals = {
        total_revenue: profitLoss.reduce((sum, v) => sum + v.total_revenue, 0),
        total_costs: profitLoss.reduce((sum, v) => sum + v.total_costs, 0),
        total_profit: profitLoss.reduce((sum, v) => sum + v.profit, 0),
      };

      totals.profit_margin = totals.total_revenue > 0
        ? (totals.total_profit / totals.total_revenue) * 100
        : 0;

      sendSuccess(res, {
        message: 'Vehicle profit/loss analytics fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          totals,
          vehicles: profitLoss,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get vehicle P&L error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch vehicle profit/loss',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/customers - Customer Analytics
// ============================================
const getCustomerAnalytics = [
  query('period').optional().isIn(['week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const companyId = req.companyId;

      console.log(`ðŸ‘¥ Fetching customer analytics for company ${companyId}`);

      // Get segmentation and retention in parallel
      const [segmentation, retention] = await Promise.all([
        analyticsService.segmentCustomers(companyId),
        analyticsService.getCustomerRetention(companyId, startDate, endDate),
      ]);

      sendSuccess(res, {
        message: 'Customer analytics fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          segmentation,
          retention,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get customer analytics error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch customer analytics',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/analytics/customers/segmentation - Customer Segments
// ============================================
const getCustomerSegmentation = async (req, res) => {
  try {
    const companyId = req.companyId;

    console.log(`ðŸŽ¯ Fetching customer segmentation for company ${companyId}`);

    const segmentation = await analyticsService.segmentCustomers(companyId);

    sendSuccess(res, {
      message: 'Customer segmentation fetched successfully',
      data: segmentation,
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customer segmentation error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch customer segmentation',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/analytics/customers/retention - Retention Metrics
// ============================================
const getCustomerRetention = [
  query('period').optional().isIn(['week', 'month', 'quarter', 'year']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { startDate, endDate } = parseDateRange(req);
      const companyId = req.companyId;

      console.log(`ðŸ”„ Fetching customer retention for company ${companyId}`);

      const retention = await analyticsService.getCustomerRetention(
        companyId,
        startDate,
        endDate
      );

      sendSuccess(res, {
        message: 'Customer retention metrics fetched successfully',
        data: {
          period: { start: startDate, end: endDate },
          ...retention,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get customer retention error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch customer retention',
        details: error.message,
      });
    }
  },
];

module.exports = {
  getDashboard,
  getRevenue,
  getVehiclePerformance,
  getVehicleUtilization,
  getVehicleProfitLoss,
  getCustomerAnalytics,
  getCustomerSegmentation,
  getCustomerRetention,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\attendance.controller.js
// src/controllers/attendance.controller.js - UPDATED VERSION
const { Attendance, Employee, User, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, query, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');

// ============================================
// POST /api/attendance/check-in
// Mark employee check-in
// ============================================
const checkIn = [
  body('employee_id').isUUID().withMessage('Valid employee ID required'),
  body('check_in_time').optional().isISO8601(),
  body('location').optional().isObject(),
  body('notes').optional().trim(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { employee_id, check_in_time, location, notes } = req.body;
      const today = new Date().toISOString().split('T')[0];

      // Check if already checked in today
      const existingAttendance = await Attendance.findOne({
        where: {
          employee_id,
          date: today,
        },
      });

      if (existingAttendance) {
        return sendError(res, {
          statusCode: 409,
          message: 'Already checked in for today',
        });
      }

      // Create attendance record
      const attendance = await Attendance.create(
        applyTenantData(req, {
          employee_id,
          date: today,
          check_in_time: check_in_time || new Date(),
          status: 'present',
          check_in_location: location,
          notes,
          recorded_by: req.user.id,
        })
      );

      console.log(`âœ… Employee ${employee_id} checked in`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Checked in successfully',
        data: { attendance },
      });
    } catch (error) {
      console.error('ðŸ’¥ Check-in error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to check in',
        details: error.message,
      });
    }
  },
];

// ============================================
// POST /api/attendance/check-out
// Mark employee check-out
// ============================================
const checkOut = [
  body('employee_id').isUUID().withMessage('Valid employee ID required'),
  body('check_out_time').optional().isISO8601(),
  body('location').optional().isObject(),
  body('notes').optional().trim(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { employee_id, check_out_time, location, notes } = req.body;
      const today = new Date().toISOString().split('T')[0];

      // Find today's attendance record
      const attendance = await Attendance.findOne({
        where: {
          employee_id,
          date: today,
        },
      });

      if (!attendance) {
        return sendError(res, {
          statusCode: 404,
          message: 'No check-in record found for today',
        });
      }

      if (attendance.check_out_time) {
        return sendError(res, {
          statusCode: 409,
          message: 'Already checked out for today',
        });
      }

      // Update with check-out time
      await attendance.update({
        check_out_time: check_out_time || new Date(),
        check_out_location: location,
        notes: notes || attendance.notes,
      });

      console.log(`âœ… Employee ${employee_id} checked out - ${attendance.total_hours} hours`);

      sendSuccess(res, {
        message: 'Checked out successfully',
        data: { attendance },
      });
    } catch (error) {
      console.error('ðŸ’¥ Check-out error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to check out',
        details: error.message,
      });
    }
  },
];

// ============================================
// POST /api/attendance/mark
// Manually mark attendance (for managers/HR)
// ============================================
const markAttendance = [
  body('employee_id').isUUID().withMessage('Valid employee ID required'),
  body('date').isISO8601().withMessage('Valid date required'),
  body('status').isIn(['present', 'absent', 'late', 'half_day', 'leave', 'holiday', 'weekend']),
  body('check_in_time').optional().isISO8601(),
  body('check_out_time').optional().isISO8601(),
  body('leave_type').optional().isIn(['sick', 'vacation', 'personal', 'unpaid', 'maternity', 'paternity']),
  body('notes').optional().trim(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { employee_id, date, status, check_in_time, check_out_time, leave_type, notes } = req.body;

      // Check if attendance already exists
      let attendance = await Attendance.findOne({
        where: {
          employee_id,
          date,
        },
      });

      if (attendance) {
        // Update existing
        await attendance.update({
          status,
          check_in_time: check_in_time || attendance.check_in_time,
          check_out_time: check_out_time || attendance.check_out_time,
          leave_type: leave_type || attendance.leave_type,
          notes: notes || attendance.notes,
          recorded_by: req.user.id,
        });
      } else {
        // Create new
        attendance = await Attendance.create(
          applyTenantData(req, {
            employee_id,
            date,
            status,
            check_in_time,
            check_out_time,
            leave_type,
            notes,
            recorded_by: req.user.id,
          })
        );
      }

      console.log(`ðŸ“ Attendance marked for ${employee_id} on ${date}: ${status}`);

      sendSuccess(res, {
        statusCode: attendance.isNewRecord ? 201 : 200,
        message: 'Attendance marked successfully',
        data: { attendance },
      });
    } catch (error) {
      console.error('ðŸ’¥ Mark attendance error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to mark attendance',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/attendance
// Get attendance records with filters
// ============================================
const getAttendance = [
  query('employee_id').optional().isUUID(),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  query('status').optional().isIn(['present', 'absent', 'late', 'half_day', 'leave', 'holiday', 'weekend']),
  query('page').optional().isInt({ min: 1 }),
  query('limit').optional().isInt({ min: 1, max: 100 }),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const {
        employee_id,
        start_date,
        end_date,
        status,
        page = 1,
        limit = 20,
      } = req.query;

      const whereClause = applyTenantFilter(req);

      if (employee_id) whereClause.employee_id = employee_id;
      if (status) whereClause.status = status;

      if (start_date || end_date) {
        whereClause.date = {};
        if (start_date) whereClause.date[Op.gte] = start_date;
        if (end_date) whereClause.date[Op.lte] = end_date;
      }

      const offset = (parseInt(page) - 1) * parseInt(limit);

      const { count, rows: attendance } = await Attendance.findAndCountAll({
        where: whereClause,
        include: [
          {
            model: Employee,
            as: 'employee',
            attributes: ['id', 'full_name', 'position', 'department'],
          },
        ],
        limit: parseInt(limit),
        offset,
        order: [['date', 'DESC']],
      });

      sendSuccess(res, {
        message: 'Attendance records fetched successfully',
        data: { attendance },
        meta: {
          pagination: {
            total: count,
            page: parseInt(page),
            limit: parseInt(limit),
            total_pages: Math.ceil(count / parseInt(limit)),
          },
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get attendance error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch attendance',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/attendance/summary
// Get attendance summary for a period
// ============================================
const getAttendanceSummary = [
  query('employee_id').optional().isUUID(),
  query('month').optional().matches(/^\d{4}-\d{2}$/),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { employee_id, month, start_date, end_date } = req.query;

      const whereClause = applyTenantFilter(req);

      if (employee_id) whereClause.employee_id = employee_id;

      // Handle month or date range
      if (month) {
        const [year, monthNum] = month.split('-');
        const startOfMonth = `${year}-${monthNum}-01`;
        const endOfMonth = new Date(year, monthNum, 0).toISOString().split('T')[0];
        whereClause.date = { [Op.between]: [startOfMonth, endOfMonth] };
      } else if (start_date || end_date) {
        whereClause.date = {};
        if (start_date) whereClause.date[Op.gte] = start_date;
        if (end_date) whereClause.date[Op.lte] = end_date;
      }

      const attendance = await Attendance.findAll({
        where: whereClause,
        attributes: [
          'employee_id',
          [sequelize.fn('COUNT', sequelize.col('id')), 'total_days'],
          [
            sequelize.fn('SUM', sequelize.literal("CASE WHEN status = 'present' OR status = 'late' THEN 1 ELSE 0 END")),
            'days_present',
          ],
          [
            sequelize.fn('SUM', sequelize.literal("CASE WHEN status = 'absent' THEN 1 ELSE 0 END")),
            'days_absent',
          ],
          [
            sequelize.fn('SUM', sequelize.literal("CASE WHEN status = 'leave' THEN 1 ELSE 0 END")),
            'days_on_leave',
          ],
          [sequelize.fn('SUM', sequelize.col('total_hours')), 'total_hours'],
          [sequelize.fn('SUM', sequelize.col('overtime_hours')), 'overtime_hours'],
        ],
        include: employee_id
          ? []
          : [
              {
                model: Employee,
                as: 'employee',
                attributes: ['id', 'full_name', 'position', 'department'],
              },
            ],
        group: ['employee_id', ...(employee_id ? [] : ['employee.id'])],
        raw: !employee_id,
      });

      sendSuccess(res, {
        message: 'Attendance summary fetched successfully',
        data: { summary: attendance },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get attendance summary error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch attendance summary',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/attendance/today
// Get today's attendance for all employees
// ============================================
const getTodayAttendance = async (req, res) => {
  try {
    const today = new Date().toISOString().split('T')[0];

    const attendance = await Attendance.findAll({
      where: {
        ...applyTenantFilter(req),
        date: today,
      },
      include: [
        {
          model: Employee,
          as: 'employee',
          attributes: ['id', 'full_name', 'position', 'department', 'status'],
        },
      ],
      order: [['check_in_time', 'ASC']],
    });

    // Get all active employees
    const allEmployees = await Employee.count({
      where: {
        company_id: req.companyId,
        status: 'active',
      },
    });

    const summary = {
      total_employees: allEmployees,
      checked_in: attendance.length,
      not_checked_in: allEmployees - attendance.length,
      present: attendance.filter(a => a.status === 'present').length,
      late: attendance.filter(a => a.status === 'late').length,
      on_leave: attendance.filter(a => a.status === 'leave').length,
    };

    sendSuccess(res, {
      message: "Today's attendance fetched successfully",
      data: { attendance, summary },
    });
  } catch (error) {
    console.error("ðŸ’¥ Get today's attendance error:", error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch attendance',
      details: error.message,
    });
  }
};

module.exports = {
  checkIn,
  checkOut,
  markAttendance,
  getAttendance,
  getAttendanceSummary,
  getTodayAttendance,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\auth.controller.js
// src/controllers/auth.controller.js
const { User, Company } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { hashPassword, comparePassword } = require('../utils/bcrypt.util');
const { generateTokens, verifyRefreshToken } = require('../utils/jwt.util');
const { body, validationResult } = require('express-validator'); // For input validation

// In-memory blacklist for refresh tokens (dev only; use Redis in prod)
const tokenBlacklist = new Set();

// POST /api/auth/register - Create new user
const register = [
  // Validators
  body('full_name').notEmpty().withMessage('Full name is required'),
  body('email').isEmail().withMessage('Valid email required').normalizeEmail(),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 chars'),
  body('company_id').isUUID().withMessage('Valid company ID required'),
  body('role').optional().isIn(['owner', 'admin', 'manager', 'staff', 'viewer']).withMessage('Invalid role'),

  async (req, res) => {
    try {
      // Check validation
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { full_name, email, password, company_id, role = 'staff' } = req.body;

      // Check if company exists
      const company = await Company.findByPk(company_id);
      if (!company) {
        return sendError(res, { statusCode: 404, message: 'Company not found' });
      }

      // Check if user already exists
      const existingUser = await User.findOne({ where: { email } });
      if (existingUser) {
        return sendError(res, { statusCode: 409, message: 'Email already registered' });
      }

      // Hash password and create user
      const passwordHash = await hashPassword(password);
      const user = await User.create({
        full_name,
        email,
        password_hash: passwordHash, // Bypasses model hook for explicit hashing
        company_id,
        role,
        is_active: true,
      });
      console.log('ðŸ‘¤ New user registered for company:', company_id, 'as', role);

      // Don't return password in response
      const { password_hash, ...userData } = user.toJSON();

      sendSuccess(res, {
        statusCode: 201,
        message: 'User registered successfully',
        data: { user: userData },
      });
    } catch (error) {
      sendError(res, { statusCode: 500, message: 'Registration failed', details: error.message });
    }
  },
];

// POST /api/auth/login - Login & get tokens
const login = [
  // Validators (same)
  body('email').isEmail().withMessage('Valid email required').normalizeEmail(),
  body('password').notEmpty().withMessage('Password required'),

  async (req, res) => {
    try {
      console.log('ðŸ”‘ Login attempt for email:', req.body.email); // Log 1: Incoming request

      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        console.log('âŒ Login validation errors:', errors.array()); // Log validation fails
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { email, password } = req.body;

      // Find user
      const user = await User.findOne({ where: { email } });
      console.log('ðŸ” User found?', !!user); // Log 2: User exists?
      if (!user || !user.is_active) {
        console.log('ðŸš« Invalid credentials for:', email);
        return sendError(res, { statusCode: 401, message: 'Invalid credentials' });
      }

      // Compare password
      const isMatch = await comparePassword(password, user.password_hash);
      console.log('ðŸ”’ Password match?', isMatch); // Log 3: Password correct?
      if (!isMatch) {
        console.log('ðŸš« Password mismatch for:', email);
        return sendError(res, { statusCode: 401, message: 'Invalid credentials' });
      }

      // Generate tokens
      const tokens = generateTokens(user);

      // Update last login
      await user.update({ last_login_at: new Date() });

      const { password_hash, ...userData } = user.toJSON();

      console.log('âœ… Login success for:', email); // Log 4: All good
      sendSuccess(res, {
        message: 'Login successful',
        data: { user: userData, ...tokens },
      });
    } catch (error) {
      console.error('ðŸ’¥ Login error:', error); // Log 5: Any crash
      sendError(res, { statusCode: 500, message: 'Login failed', details: error.message });
    }
  },
];

// GET /api/auth/me - Get current user (protected)
const getMe = async (req, res) => {
  try {
    // req.user from middleware, but fetch fresh from DB for full details
    const user = await User.findByPk(req.user.id, {
      attributes: { exclude: ['password_hash'] }, // Hide sensitive fields
    });

    if (!user) {
      return sendError(res, { statusCode: 404, message: 'User not found' });
    }

    sendSuccess(res, { message: 'User profile fetched', data: { user: user.toJSON() } });
  } catch (error) {
    sendError(res, { statusCode: 500, message: 'Failed to fetch profile', details: error.message });
  }
};

// POST /api/auth/logout - Blacklist refresh token
const logout = async (req, res) => {
  try {
    const authHeader = req.headers['authorization'];
    const refreshToken = req.body.refresh_token || (authHeader && authHeader.split(' ')[1]); // Accept in body or header

    if (!refreshToken) {
      return sendError(res, { statusCode: 400, message: 'Refresh token required' });
    }

    // Blacklist it
    tokenBlacklist.add(refreshToken);

    sendSuccess(res, { message: 'Logged out successfully' });
  } catch (error) {
    sendError(res, { statusCode: 500, message: 'Logout failed', details: error.message });
  }
};

// POST /api/auth/refresh - Get new access token
const refresh = [
  body('refresh_token').notEmpty().withMessage('Refresh token required'),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { refresh_token } = req.body;

      // Check blacklist
      if (tokenBlacklist.has(refresh_token)) {
        return sendError(res, { statusCode: 401, message: 'Token has been revoked' });
      }

      // Verify refresh token
      const decoded = verifyRefreshToken(refresh_token);
      const user = await User.findByPk(decoded.id);

      if (!user || !user.is_active) {
        return sendError(res, { statusCode: 401, message: 'User inactive or not found' });
      }

      // Generate new access token (keep same refresh)
      const { accessToken } = generateTokens(user);

      sendSuccess(res, {
        message: 'Token refreshed',
        data: { accessToken },
      });
    } catch (error) {
      sendError(res, { statusCode: 401, message: error.message || 'Invalid refresh token' });
    }
  },
];

module.exports = {
  register,
  login,
  getMe,
  logout,
  refresh,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\company.controller.js
const { Company } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');

// POST /api/companies - Create new company (public for signup)
const createCompany = [
  // Validators
  body('name').notEmpty().withMessage('Company name required'),
  body('email').isEmail().withMessage('Valid email required').normalizeEmail(),
  body('phone').optional().isMobilePhone('ar-DZ'), // Algerian format
  body('subscription_plan').optional().isIn(['basic', 'professional', 'enterprise']),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { name, email, phone, subscription_plan = 'basic', subscription_status = 'trial' } = req.body;

      // Check if company with email exists
      const existing = await Company.findOne({ where: { email } });
      if (existing) {
        return sendError(res, { statusCode: 409, message: 'Company with this email already exists' });
      }

      const company = await Company.create({
        name,
        email,
        phone,
        subscription_plan,
        subscription_status,
        subscription_start_date: new Date(),
        trial_ends_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days trial
      });

      // Convert to plain object
      const companyJson = company.toJSON();
      
      // DEBUG: Log everything
      console.log('ðŸ¢ DEBUG - Raw company.toJSON():', companyJson);
      console.log('ðŸ¢ DEBUG - company.id:', company.id);
      console.log('ðŸ¢ DEBUG - companyJson.id:', companyJson.id);

      // Remove sensitive fields but keep ID intact
      const { settings, ...safeCompany } = companyJson;

      console.log('ðŸ¢ DEBUG - safeCompany.id:', safeCompany.id);
      console.log('ðŸ¢ DEBUG - About to send response with company:', safeCompany);

      console.log('ðŸ¢ New company created:', name, 'with ID:', company.id);
      
      sendSuccess(res, {
        statusCode: 201,
        message: 'Company created successfully',
        data: { company: safeCompany },
      });
    } catch (error) {
      console.error('ðŸ’¥ Company creation error:', error);
      sendError(res, { statusCode: 500, message: 'Failed to create company', details: error.message });
    }
  },
];

// GET /api/company/profile - Get company details (protected)
const getProfile = async (req, res) => {
  try {
    const { company_id } = req.user; // From authenticated user
    console.log('ðŸ¢ Fetching profile for company_id:', company_id);

    const company = await Company.findByPk(company_id);

    if (!company) {
      console.log('ðŸš« Company not found:', company_id);
      return sendError(res, { statusCode: 404, message: 'Company not found' });
    }

    // Return full company including settings so the settings page can load/save defaultDailyKmLimit etc.
    const companyJson = company.toJSON();
    console.log('ðŸ¢ Profile fetched for:', companyJson.name);

    sendSuccess(res, {
      message: 'Company profile fetched successfully',
      data: { company: companyJson },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get company profile error:', error);
    sendError(res, { statusCode: 500, message: 'Failed to fetch company profile', details: error.message });
  }
};

// PUT /api/company/profile - Update company info (protected)
const updateProfile = [
  // Validators for updatable fields
  body('name').optional().notEmpty().withMessage('Company name required'),
  body('email').optional().isEmail().withMessage('Valid email required').normalizeEmail(),
  body('phone').optional().isLength({ min: 10, max: 15 }).withMessage('Phone must be 10-15 digits'),
  body('address').optional().isLength({ max: 500 }).withMessage('Address too long'),
  body('tax_id').optional().isLength({ max: 100 }).withMessage('Tax ID too long'),
  // Fix: Allow falsy (empty) values for optional URL
  body('logo_url').optional({ checkFalsy: true }).isURL().withMessage('Valid URL required'),
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { company_id } = req.user;
      const updateData = req.body; // Only validated fields will be present
      console.log('ðŸ¢ Updating profile for company_id:', company_id, 'with:', updateData);

      // If email is provided and changed, check uniqueness
      if (updateData.email) {
        const existingCompany = await Company.findOne({ where: { email: updateData.email } });
        if (existingCompany && existingCompany.id !== company_id) {
          return sendError(res, { statusCode: 409, message: 'Email already in use by another company' });
        }
      }

      // Update company
      const [updatedRows, [company]] = await Company.update(updateData, {
        where: { id: company_id },
        returning: true, // Sequelize option to return updated record
      });

      if (updatedRows === 0) {
        return sendError(res, { statusCode: 404, message: 'Company not found' });
      }

      // Exclude settings from response
      const { settings, ...safeCompany } = company.toJSON();
      console.log('ðŸ¢ Profile updated for:', safeCompany.name);

      sendSuccess(res, {
        message: 'Company profile updated successfully',
        data: { company: safeCompany },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update company profile error:', error);
      sendError(res, { statusCode: 500, message: 'Failed to update company profile', details: error.message });
    }
  },
];

// PUT /api/company/settings - Update company settings (protected)
const updateSettings = [
  // Validator for settings (must be object)
  body('settings').optional().isObject().withMessage('Settings must be a valid JSON object'),
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, { statusCode: 422, message: 'Validation failed', details: errors.array() });
      }

      const { company_id } = req.user;
      const { settings } = req.body;
      console.log('ðŸ¢ Updating settings for company_id:', company_id, 'with:', settings);

      // Fetch existing company to merge settings (or overwrite if preferred)
      const company = await Company.findByPk(company_id);
      if (!company) {
        return sendError(res, { statusCode: 404, message: 'Company not found' });
      }

      // Merge with existing (add this if you want to preserve unset fields; else just set new)
      const newSettings = { ...company.settings, ...settings };

      // Update only settings
      await company.update({ settings: newSettings });
      // Reload to get fresh instance
      await company.reload();

      // Return updated company without full settings in response (or include if needed)
      const { settings: _, ...safeCompany } = company.toJSON(); // Hide settings
      console.log('ðŸ”§ Settings updated for:', safeCompany.name);

      sendSuccess(res, {
        message: 'Company settings updated successfully',
        data: { company: safeCompany },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update company settings error:', error);
      sendError(res, { statusCode: 500, message: 'Failed to update company settings', details: error.message });
    }
  },
];

module.exports = {
  createCompany,
  getProfile,
  updateProfile,
  updateSettings,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\contract.controller.js
// src/controllers/contract.controller.js
const { Contract, Customer, Vehicle, User, Payment, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');
const { getDefaultDailyKmLimit, getDefaultOverageRate } = require('../services/companySettings.service');

// ============================================
// HELPER: Generate contract number (atomic with uniqueness check)
// ============================================
const generateContractNumber = async (companyId, transaction) => {
  const year = new Date().getFullYear();
  const yearPrefix = `RENT-${year}-`;

  // Find the highest existing number for this year/company
  const maxContract = await Contract.findOne({
    where: {
      company_id: companyId,
      contract_number: { [Op.like]: `${yearPrefix}%` },
    },
    order: [['contract_number', 'DESC']], // Sort by contract_number DESC for max
    transaction, // Use transaction for isolation
  });

  let nextNumber = 1;
  if (maxContract) {
    nextNumber = parseInt(maxContract.contract_number.split('-')[2]) + 1;
  }

  // Loop to ensure uniqueness (handles races/stale data)
  let contractNumber;
  do {
    contractNumber = `${yearPrefix}${String(nextNumber).padStart(4, '0')}`;
    const exists = await Contract.findOne({
      where: {
        company_id: companyId,
        contract_number: contractNumber,
      },
      transaction, // Use transaction
    });
    if (!exists) break;
    nextNumber++;
  } while (true);

  return contractNumber;
};

// ============================================
// HELPER: Calculate contract totals
// ============================================
const calculateContractTotals = (data) => {
  // Parse strings to numbers safely (fixes the concat bug)
  const dailyRate = parseFloat(data.daily_rate) || 0;
  const additionalCharges = parseFloat(data.additional_charges || 0);
  const discountAmount = parseFloat(data.discount_amount || 0);

  const startDate = new Date(data.start_date);
  const endDate = new Date(data.end_date);
  const totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;
  
  if (totalDays <= 0) {
    throw new Error('Invalid date range: end date must be after start date');
  }

  const baseAmount = dailyRate * totalDays;
  const subtotal = baseAmount + additionalCharges - discountAmount;
  const taxAmount = subtotal * 0.19; // 19% tax
  const totalAmount = subtotal + taxAmount;

  return {
    total_days: totalDays,
    base_amount: baseAmount,
    tax_amount: taxAmount,
    total_amount: totalAmount,
  };
};

// ============================================
// GET /api/contracts - List all contracts
// ============================================
const getAllContracts = async (req, res) => {
  try {
    const {
      status,
      customer_id,
      vehicle_id,
      start_date,
      end_date,
      search,
      page = 1,
      limit = 20,
      sort_by = 'created_at',
      sort_order = 'DESC',
    } = req.query;

    // Build filter with tenant isolation
    const whereClause = applyTenantFilter(req);

    // Apply filters
    if (status) whereClause.status = status;
    if (customer_id) whereClause.customer_id = customer_id;
    if (vehicle_id) whereClause.vehicle_id = vehicle_id;

    // Date range filter
    if (start_date || end_date) {
      whereClause.start_date = {};
      if (start_date) whereClause.start_date[Op.gte] = start_date;
      if (end_date) whereClause.start_date[Op.lte] = end_date;
    }

    // Search by contract number
    if (search) {
      whereClause.contract_number = { [Op.iLike]: `%${search}%` };
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch contracts with relations
    const { count, rows: contracts } = await Contract.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: Customer,
          as: 'customer',
          attributes: ['id', 'full_name', 'email', 'phone', 'customer_type'],
        },
        {
          model: Vehicle,
          as: 'vehicle',
          attributes: ['id', 'brand', 'model', 'year', 'registration_number', 'status'],
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'full_name', 'email'],
        },
      ],
      limit: parseInt(limit),
      offset: offset,
      order: [[sort_by, sort_order.toUpperCase()]],
    });

    console.log(`ðŸ“‹ Fetched ${contracts.length} contracts for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Contracts fetched successfully',
      data: { contracts },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get contracts error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch contracts',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/contracts/:id - Get single contract
// ============================================
const getContractById = async (req, res) => {
  try {
    const { id } = req.params;

    const contract = await Contract.findOne({
      where: applyTenantFilter(req, { id }),
      include: [
        {
          model: Customer,
          as: 'customer',
        },
        {
          model: Vehicle,
          as: 'vehicle',
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'full_name', 'email'],
        },
        {
          model: Payment,
          as: 'payments',
        },
      ],
    });

    if (!contract) {
      return sendError(res, {
        statusCode: 404,
        message: 'Contract not found',
      });
    }

    console.log(`ðŸ“„ Contract fetched: ${contract.contract_number}`);

    sendSuccess(res, {
      message: 'Contract fetched successfully',
      data: { contract },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get contract error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch contract',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/contracts - Create new contract
// ============================================
const createContract = [
  // Validators (same as before)
  body('customer_id').isUUID().withMessage('Valid customer ID required'),
  body('vehicle_id').isUUID().withMessage('Valid vehicle ID required'),
  body('start_date').isISO8601().withMessage('Valid start date required'),
  body('end_date').isISO8601().withMessage('Valid end date required'),
  body('daily_rate').isFloat({ min: 0 }).withMessage('Valid daily rate required'),
  body('deposit_amount').optional().isFloat({ min: 0 }),
  body('additional_charges').optional().isFloat({ min: 0 }),
  body('discount_amount').optional().isFloat({ min: 0 }),
  body('mileage_limit').optional().isInt({ min: 0 }), // Legacy - kept for backward compatibility
  body('daily_km_limit').optional().isInt({ min: 0 }), // NEW - can be specified per contract
  body('extras').optional().isObject(),
  body('notes').optional().trim(),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { customer_id, vehicle_id, start_date, end_date } = req.body;

      // Validate dates
      if (new Date(end_date) <= new Date(start_date)) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'End date must be after start date',
        });
      }

      // Check customer exists and is not blacklisted
      const customer = await Customer.findOne({
        where: applyTenantFilter(req, { id: customer_id }),
      });

      if (!customer) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Customer not found' });
      }

      if (customer.is_blacklisted) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 403,
          message: 'Cannot create contract for blacklisted customer',
        });
      }

      // Check vehicle exists and is available
      const vehicle = await Vehicle.findOne({
        where: applyTenantFilter(req, { id: vehicle_id }),
      });

      if (!vehicle) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Vehicle not found' });
      }

      if (vehicle.status !== 'available') {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: `Vehicle is not available (current status: ${vehicle.status})`,
        });
      }

      // Check for conflicting contracts (same as before)
      const conflictingContract = await Contract.findOne({
        where: {
          vehicle_id,
          status: 'active',
          [Op.or]: [
            { start_date: { [Op.between]: [start_date, end_date] } },
            { end_date: { [Op.between]: [start_date, end_date] } },
            {
              [Op.and]: [
                { start_date: { [Op.lte]: start_date } },
                { end_date: { [Op.gte]: end_date } },
              ],
            },
          ],
        },
      });

      if (conflictingContract) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: 'Vehicle already has an active contract in this date range',
        });
      }

      // Generate contract number (same as before)
      const contractNumber = await generateContractNumber(req.companyId, transaction);

      // Calculate totals (same as before)
      const totals = calculateContractTotals(req.body);

      // âœ¨ NEW: Get company-specific KM settings
      const [companyDailyKmLimit, companyOverageRate] = await Promise.all([
        getDefaultDailyKmLimit(req.companyId),
        getDefaultOverageRate(req.companyId),
      ]);

      // Use contract-specific value if provided, else use company default
      const dailyKmLimit = req.body.daily_km_limit || companyDailyKmLimit;
      const totalKmAllowed = dailyKmLimit * totals.total_days;

      console.log(`ðŸ“Š Contract KM Policy: ${dailyKmLimit}km/day (company default: ${companyDailyKmLimit}km) for ${totals.total_days} days = ${totalKmAllowed}km total`);

      // Create contract
      const contractData = applyTenantData(req, {
        ...req.body,
        contract_number: contractNumber,
        created_by: req.user.id,
        status: 'active',
        start_mileage: vehicle.mileage,
        daily_km_limit: dailyKmLimit, // âœ¨ Use company/contract-specific value
        total_km_allowed: totalKmAllowed,
        overage_rate_per_km: companyOverageRate, // âœ¨ Use company default
        ...totals,
      });

      const contract = await Contract.create(contractData, { transaction });

      // Update vehicle status (same as before)
      await vehicle.update({ status: 'rented' }, { transaction });

      // Update customer stats (same as before)
      await customer.update(
        {
          total_rentals: customer.total_rentals + 1,
          lifetime_value: parseFloat(customer.lifetime_value) + totals.total_amount,
        },
        { transaction }
      );

      await transaction.commit();

      // Fetch contract with relations
      const fullContract = await Contract.findByPk(contract.id, {
        include: [
          { model: Customer, as: 'customer' },
          { model: Vehicle, as: 'vehicle' },
          { model: User, as: 'creator', attributes: ['id', 'full_name'] },
        ],
      });

      console.log(`ðŸ“„ New contract created: ${contractNumber} with ${dailyKmLimit}km/day limit`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Contract created successfully',
        data: { contract: fullContract },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Create contract error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to create contract',
        details: error.message,
      });
    }
  },
];

// ============================================
// PUT /api/contracts/:id - Update contract
// ============================================
const updateContract = [
  body('end_date').optional().isISO8601(),
  body('additional_charges').optional().isFloat({ min: 0 }),
  body('discount_amount').optional().isFloat({ min: 0 }),
  body('notes').optional().trim(),
  body('extras').optional().isObject(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;

      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id }),
      });

      if (!contract) {
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }

      // Only allow updates for active or draft contracts
      if (!['active', 'draft'].includes(contract.status)) {
        return sendError(res, {
          statusCode: 409,
          message: `Cannot update ${contract.status} contract`,
        });
      }

      // If updating end_date or charges, recalculate totals
      if (req.body.end_date || req.body.additional_charges !== undefined || req.body.discount_amount !== undefined) {
        const updateData = {
          start_date: contract.start_date,
          end_date: req.body.end_date || contract.end_date,
          daily_rate: contract.daily_rate,
          additional_charges: req.body.additional_charges ?? contract.additional_charges,
          discount_amount: req.body.discount_amount ?? contract.discount_amount,
        };

        const totals = calculateContractTotals(updateData);
        Object.assign(req.body, totals);
      }

      await contract.update(req.body);

      console.log(`ðŸ”„ Contract updated: ${contract.contract_number}`);

      sendSuccess(res, {
        message: 'Contract updated successfully',
        data: { contract },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update contract error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to update contract',
        details: error.message,
      });
    }
  },
];

// ============================================
// POST /api/contracts/:id/complete - Complete rental
// ============================================
const completeContract = [
  body('actual_return_date').isISO8601().withMessage('Valid return date required'),
  body('end_mileage').isInt({ min: 0 }).withMessage('Valid end mileage required'),
  body('additional_charges').optional().isFloat({ min: 0 }),
  body('notes').optional().trim(),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;
      const { actual_return_date, end_mileage, additional_charges, notes } = req.body;

      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id }),
        include: [{ model: Vehicle, as: 'vehicle' }],
      });

      if (!contract) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }

      if (contract.status !== 'active') {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: `Cannot complete ${contract.status} contract`,
        });
      }

      // Calculate mileage charges if exceeded
      const mileageDriven = end_mileage - contract.start_mileage;
      let mileageCharges = 0;

      if (contract.mileage_limit && mileageDriven > contract.mileage_limit) {
        const excessMileage = mileageDriven - contract.mileage_limit;
        const chargePerKm = contract.mileage_charge_per_km || 5; // Default 5 DZD per km
        mileageCharges = excessMileage * chargePerKm;
      }

      const totalAdditionalCharges = (additional_charges || 0) + mileageCharges;

      // Recalculate total if additional charges
      let updateData = {
        status: 'completed',
        actual_return_date,
        end_mileage,
        deposit_returned: true,
      };

      if (totalAdditionalCharges > 0) {
        updateData.additional_charges = parseFloat(contract.additional_charges) + totalAdditionalCharges;
        
        const totals = calculateContractTotals({
          start_date: contract.start_date,
          end_date: contract.end_date,
          daily_rate: contract.daily_rate,
          additional_charges: updateData.additional_charges,
          discount_amount: contract.discount_amount,
        });

        updateData = { ...updateData, ...totals };
      }

      if (notes) updateData.notes = notes;

      await contract.update(updateData, { transaction });

      // Update vehicle status and mileage
      await contract.vehicle.update(
        {
          status: 'available',
          mileage: end_mileage,
        },
        { transaction }
      );

      await transaction.commit();

      console.log(`âœ… Contract completed: ${contract.contract_number}`);

      sendSuccess(res, {
        message: 'Contract completed successfully',
        data: { contract },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Complete contract error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to complete contract',
        details: error.message,
      });
    }
  },
];

// ============================================
// POST /api/contracts/:id/cancel - Cancel contract
// ============================================
const cancelContract = [
  body('reason').optional().trim(),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const { id } = req.params;
      const { reason } = req.body;

      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id }),
        include: [
          { model: Vehicle, as: 'vehicle' },
          { model: Customer, as: 'customer' },
        ],
      });

      if (!contract) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }

      if (contract.status !== 'active') {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: `Cannot cancel ${contract.status} contract`,
        });
      }

      // Update contract
      await contract.update(
        {
          status: 'cancelled',
          notes: reason ? `${contract.notes || ''}\nCancellation reason: ${reason}` : contract.notes,
        },
        { transaction }
      );

      // Return vehicle to available
      await contract.vehicle.update({ status: 'available' }, { transaction });

      // Update customer stats (decrement)
      await contract.customer.update(
        {
          total_rentals: Math.max(0, contract.customer.total_rentals - 1),
          lifetime_value: Math.max(0, parseFloat(contract.customer.lifetime_value) - parseFloat(contract.total_amount)),
        },
        { transaction }
      );

      await transaction.commit();

      console.log(`âŒ Contract cancelled: ${contract.contract_number}`);

      sendSuccess(res, {
        message: 'Contract cancelled successfully',
        data: { contract },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Cancel contract error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to cancel contract',
        details: error.message,
      });
    }
  },
];

// ============================================
// POST /api/contracts/:id/extend - Extend rental
// ============================================
const extendContract = [
  body('new_end_date').isISO8601().withMessage('Valid new end date required'),
  body('notes').optional().trim(),
  async (req, res) => {
    const transaction = await sequelize.transaction(); // Add for safety
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }
      const { id } = req.params;
      const { new_end_date, notes } = req.body;
      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id }),
        include: [{ model: Vehicle, as: 'vehicle' }], // Load vehicle for ID
      });
      if (!contract) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }
      if (contract.status !== 'active') {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: `Cannot extend ${contract.status} contract`,
        });
      }
      // Validate new end date is after current end date
      if (new Date(new_end_date) <= new Date(contract.end_date)) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'New end date must be after current end date',
        });
      }
      // Check for conflicts (inside transaction)
      const conflictingContract = await Contract.findOne({
        where: {
          vehicle_id: contract.vehicle_id,
          status: 'active',
          id: { [Op.ne]: contract.id },
          start_date: { [Op.lte]: new_end_date },
          end_date: { [Op.gte]: new Date(contract.end_date) },
        },
        transaction,
      });
      if (conflictingContract) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: 'Cannot extend: vehicle has another booking during the extended period',
        });
      }
      // Recalculate totals (now safe with parsing)
      const totals = calculateContractTotals({
        start_date: contract.start_date,
        end_date: new_end_date,
        daily_rate: contract.daily_rate,
        additional_charges: contract.additional_charges,
        discount_amount: contract.discount_amount,
      });
      await contract.update({
        end_date: new_end_date,
        // status: 'extended',  // Removed: Keep as 'active'
        ...totals,
        notes: notes ? `${contract.notes || ''}\nExtended to ${new_end_date}: ${notes}` : contract.notes, // Clearer note
      }, { transaction });
      await transaction.commit();
      console.log(`ðŸ“… Contract extended: ${contract.contract_number}`);
      sendSuccess(res, {
        message: 'Contract extended successfully',
        data: { contract },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Extend contract error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to extend contract',
        details: error.message,
      });
    }
  },
];
// ============================================
// GET /api/contracts/stats - Get contract statistics
// ============================================
const getContractStats = async (req, res) => {
  try {
    const companyFilter = { company_id: req.companyId };
    // Total contracts
    const totalContracts = await Contract.count({ where: companyFilter });
    // By status
    const active = await Contract.count({ where: { ...companyFilter, status: 'active' } });
    const completed = await Contract.count({ where: { ...companyFilter, status: 'completed' } });
    const cancelled = await Contract.count({ where: { ...companyFilter, status: 'cancelled' } });
    // Revenue
    const revenueResult = await Contract.findOne({
      where: companyFilter,
      attributes: [
        [sequelize.fn('SUM', sequelize.col('total_amount')), 'total_revenue'],
      ],
      raw: true,
    });
    // Recent contracts (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const recentContracts = await Contract.count({
      where: {
        ...companyFilter,
        created_at: { [Op.gte]: thirtyDaysAgo },
      },
    });
    const stats = {
      total_contracts: totalContracts,
      by_status: { active, completed, cancelled }, // Removed extended
      total_revenue: parseFloat(revenueResult?.total_revenue || 0),
      recent_contracts_30d: recentContracts,
    };
    sendSuccess(res, {
      message: 'Contract statistics fetched successfully',
      data: { stats },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get contract stats error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch contract statistics',
      details: error.message,
    });
  }
};

module.exports = {
  getAllContracts,
  getContractById,
  createContract,
  updateContract,
  completeContract,
  cancelContract,
  extendContract,
  getContractStats,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\contractKm.controller.js
// src/controllers/contractKm.controller.js
const { Contract, Customer, Vehicle, Payment, Notification, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { applyTenantFilter } = require('../middleware/tenantIsolation.middleware');
const {
  calculateOverageRate,
  calculateAllowedKm,
  calculateOverageCharges,
  getCustomerTierInfo,
} = require('../services/customerTier.service');

/**
 * POST /api/contracts/:id/complete-with-mileage
 * Complete contract with mileage verification and overage calculation
 */
const completeContractWithMileage = [
  body('end_mileage').isInt({ min: 0 }).withMessage('Valid end mileage required'),
  body('actual_return_date').isISO8601().withMessage('Valid return date required'),
  body('additional_charges').optional().isFloat({ min: 0 }),
  body('notes').optional().trim(),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;
      const { end_mileage, actual_return_date, additional_charges, notes } = req.body;

      // Get contract with customer and vehicle
      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id }),
        include: [
          {
            model: Customer,
            as: 'customer',
            attributes: ['id', 'full_name', 'email', 'total_rentals', 'lifetime_value', 'apply_tier_discount'],
          },
          {
            model: Vehicle,
            as: 'vehicle',
            attributes: ['id', 'brand', 'model', 'registration_number', 'mileage'],
          },
        ],
      });

      if (!contract) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }

      if (contract.status !== 'active') {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: `Cannot complete ${contract.status} contract`,
        });
      }

      // Validate end mileage is greater than start mileage
      if (end_mileage < contract.start_mileage) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: `End mileage (${end_mileage}) cannot be less than start mileage (${contract.start_mileage})`,
        });
      }

      // Calculate km driven
      const actualKmDriven = end_mileage - contract.start_mileage;

      // Get customer tier info
      const customerTier = getCustomerTierInfo(contract.customer);

      // Calculate allowed km with tier bonus (respect customer apply_tier_discount)
      const applyTier = contract.customer.apply_tier_discount !== false;
      const allowedKmInfo = calculateAllowedKm(
        contract.daily_km_limit || 300,
        contract.total_days,
        contract.customer.total_rentals,
        { applyTierBonus: applyTier }
      );

      // Calculate overage
      const kmOverage = Math.max(0, actualKmDriven - allowedKmInfo.total_km_allowed);

      // Get overage rate for this customer
      const overageRate = calculateOverageRate(contract.customer);

      // Calculate overage charges with tier discount (respect customer apply_tier_discount)
      const overageInfo = calculateOverageCharges(
        kmOverage,
        overageRate,
        contract.customer.total_rentals,
        { applyTierDiscount: applyTier }
      );

      // Prepare update data
      const updateData = {
        status: 'completed',
        actual_return_date,
        end_mileage,
        actual_km_driven: actualKmDriven,
        km_overage: kmOverage,
        overage_rate_per_km: overageRate,
        overage_charges: overageInfo.final_overage_charges,
        deposit_returned: true,
      };

      // Add additional charges if provided
      const extraCharges = parseFloat(additional_charges || 0);
      const totalAdditionalCharges = 
        parseFloat(contract.additional_charges || 0) + 
        extraCharges + 
        overageInfo.final_overage_charges;

      updateData.additional_charges = totalAdditionalCharges;

      // Recalculate total amount
      const baseAmount = parseFloat(contract.base_amount);
      const discountAmount = parseFloat(contract.discount_amount || 0);
      const subtotal = baseAmount + totalAdditionalCharges - discountAmount;
      const taxAmount = subtotal * 0.19; // 19% tax
      const totalAmount = subtotal + taxAmount;

      updateData.tax_amount = taxAmount;
      updateData.total_amount = totalAmount;

      // Add notes about overage
      if (kmOverage > 0) {
        const overageNote = `\nKM Overage: ${kmOverage}km driven beyond ${allowedKmInfo.total_km_allowed}km limit. ` +
          `Base charge: ${overageInfo.base_overage_charges} DA, ` +
          `Tier discount (${customerTier.tier} - ${overageInfo.discount_percentage}%): -${overageInfo.discount_amount} DA, ` +
          `Final overage charge: ${overageInfo.final_overage_charges} DA.`;
        updateData.notes = (notes || contract.notes || '') + overageNote;
      } else if (notes) {
        updateData.notes = notes;
      }

      // Update contract
      await contract.update(updateData, { transaction });

      // Update vehicle mileage
      await contract.vehicle.update(
        { mileage: end_mileage, status: 'available' },
        { transaction }
      );

      // Create notification if overage occurred
      if (kmOverage > 0) {
        await Notification.create(
          {
            company_id: contract.company_id,
            type: 'contract_overage',
            priority: kmOverage > 100 ? 'high' : 'medium',
            title: `KM Overage: ${contract.contract_number}`,
            message: `Customer ${contract.customer.full_name} exceeded limit by ${kmOverage}km. Additional charge: ${overageInfo.final_overage_charges} DA (${customerTier.tier_name} tier discount applied).`,
            data: {
              contract_id: contract.id,
              contract_number: contract.contract_number,
              customer_id: contract.customer_id,
              vehicle_id: contract.vehicle_id,
              km_overage: kmOverage,
              overage_charges: overageInfo.final_overage_charges,
              customer_tier: customerTier.tier,
              ...overageInfo,
            },
            action_url: `/contracts/${contract.id}`,
          },
          { transaction }
        );
      }

      await transaction.commit();

      console.log(`âœ… Contract completed: ${contract.contract_number}`);
      console.log(`   Km driven: ${actualKmDriven}km (allowed: ${allowedKmInfo.total_km_allowed}km)`);
      if (kmOverage > 0) {
        console.log(`   Overage: ${kmOverage}km Ã— ${overageRate} DA = ${overageInfo.base_overage_charges} DA`);
        console.log(`   Tier discount: -${overageInfo.discount_amount} DA (${customerTier.tier_name})`);
        console.log(`   Final overage: ${overageInfo.final_overage_charges} DA`);
      }

      // Return detailed response
      sendSuccess(res, {
        message: 'Contract completed successfully',
        data: {
          contract,
          mileage_summary: {
            start_mileage: contract.start_mileage,
            end_mileage: end_mileage,
            km_driven: actualKmDriven,
            daily_limit: contract.daily_km_limit,
            total_days: contract.total_days,
            base_km_allowed: contract.daily_km_limit * contract.total_days,
            tier_bonus_km: allowedKmInfo.bonus_km_per_day * contract.total_days,
            total_km_allowed: allowedKmInfo.total_km_allowed,
            km_overage: kmOverage,
            within_limit: kmOverage === 0,
          },
          overage_details: kmOverage > 0 ? {
            ...overageInfo,
            customer_tier: customerTier.tier_name,
            tier_benefits_applied: true,
          } : null,
          customer_tier: {
            tier: customerTier.tier,
            tier_name: customerTier.name,
            benefits: customerTier.benefits,
            overage_rate: customerTier.overage_rate,
          },
          billing: {
            base_amount: baseAmount,
            overage_charges: overageInfo.final_overage_charges,
            other_charges: extraCharges,
            total_additional_charges: totalAdditionalCharges,
            discount: discountAmount,
            subtotal: subtotal,
            tax: taxAmount,
            total: totalAmount,
          },
        },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Complete contract with mileage error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to complete contract',
        details: error.message,
      });
    }
  },
];

/**
 * GET /api/contracts/:id/mileage-estimate
 * Calculate mileage overage estimate before contract completion
 */
const estimateOverageCharges = async (req, res) => {
  try {
    const { id } = req.params;
    const { estimated_end_mileage } = req.query;

    if (!estimated_end_mileage) {
      return sendError(res, {
        statusCode: 422,
        message: 'estimated_end_mileage query parameter required',
      });
    }

    const contract = await Contract.findOne({
      where: applyTenantFilter(req, { id }),
      include: [
        {
          model: Customer,
          as: 'customer',
          attributes: ['id', 'full_name', 'total_rentals', 'apply_tier_discount'],
        },
      ],
    });

    if (!contract) {
      return sendError(res, { statusCode: 404, message: 'Contract not found' });
    }

    const estimatedKmDriven = parseInt(estimated_end_mileage) - contract.start_mileage;
    const applyTier = contract.customer.apply_tier_discount !== false;

    // Get allowed km with tier bonus (respect customer apply_tier_discount)
    const allowedKmInfo = calculateAllowedKm(
      contract.daily_km_limit || 300,
      contract.total_days,
      contract.customer.total_rentals,
      { applyTierBonus: applyTier }
    );

    const kmOverage = Math.max(0, estimatedKmDriven - allowedKmInfo.total_km_allowed);

    // Get customer overage rate
    const overageRate = calculateOverageRate(contract.customer);

    // Calculate overage charges (respect customer apply_tier_discount)
    const overageInfo = calculateOverageCharges(
      kmOverage,
      overageRate,
      contract.customer.total_rentals,
      { applyTierDiscount: applyTier }
    );

    sendSuccess(res, {
      message: 'Overage estimate calculated',
      data: {
        contract_id: contract.id,
        contract_number: contract.contract_number,
        start_mileage: contract.start_mileage,
        estimated_end_mileage: parseInt(estimated_end_mileage),
        estimated_km_driven: estimatedKmDriven,
        allowed_km: allowedKmInfo,
        estimated_overage: overageInfo,
        customer_tier: overageInfo.tier_name,
        warning: kmOverage > 0 ? `Customer will be charged ${overageInfo.final_overage_charges} DA for ${kmOverage}km overage` : null,
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Estimate overage error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to estimate overage',
      details: error.message,
    });
  }
};

/**
 * GET /api/customers/:id/tier-info
 * Get customer tier information and benefits
 */
const getCustomerTierInfoEndpoint = async (req, res) => {
  try {
    const { id } = req.params;

    const customer = await Customer.findOne({
      where: applyTenantFilter(req, { id }),
    });

    if (!customer) {
      return sendError(res, { statusCode: 404, message: 'Customer not found' });
    }

    const tierInfo = getCustomerTierInfo(customer);

    sendSuccess(res, {
      message: 'Customer tier information fetched',
      data: tierInfo,
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customer tier info error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch tier information',
      details: error.message,
    });
  }
};

/**
 * Helper: Calculate contract with KM limits for creation
 * Use this when creating contracts to auto-set km allowances
 */
const calculateContractWithKmLimits = (contractData, customer) => {
  const { start_date, end_date, daily_km_limit = 300 } = contractData;
  
  // Calculate total days
  const startDate = new Date(start_date);
  const endDate = new Date(end_date);
  const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
  
  const applyTier = customer.apply_tier_discount !== false;
  
  // Get allowed km with tier bonuses (respect customer apply_tier_discount)
  const allowedKmInfo = calculateAllowedKm(
    daily_km_limit,
    totalDays,
    customer.total_rentals || 0,
    { applyTierBonus: applyTier }
  );
  
  // Get customer overage rate (respects apply_tier_discount)
  const overageRate = calculateOverageRate(customer);
  
  return {
    daily_km_limit,
    total_days: totalDays,
    total_km_allowed: allowedKmInfo.total_km_allowed,
    overage_rate_per_km: overageRate,
    tier_info: {
      tier: allowedKmInfo.tier,
      tier_name: allowedKmInfo.tier_name,
      base_daily_limit: allowedKmInfo.base_daily_limit,
      bonus_km_per_day: allowedKmInfo.bonus_km_per_day,
      total_daily_limit: allowedKmInfo.total_daily_limit,
    },
  };
};

module.exports = {
  completeContractWithMileage,
  estimateOverageCharges,
  getCustomerTierInfoEndpoint,
  calculateContractWithKmLimits, // Export for use in contract creation
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\customer.controller.js
// src/controllers/customer.controller.js
const { Customer, Contract, Payment, Vehicle, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');

// ============================================
// GET /api/customers - List all customers (with filters & search)
// ============================================
const getAllCustomers = async (req, res) => {
  try {
    const {
      customer_type,
      is_blacklisted,
      search,
      page = 1,
      limit = 20,
      sort_by = 'created_at',
      sort_order = 'DESC',
    } = req.query;

    // Build filter object with tenant isolation
    const whereClause = applyTenantFilter(req);

    // Apply customer type filter
    if (customer_type) {
      whereClause.customer_type = customer_type;
    }

    // Apply blacklist filter
    if (is_blacklisted !== undefined) {
      whereClause.is_blacklisted = is_blacklisted === 'true';
    }

    // Apply search (name, email, phone, license)
    if (search) {
      whereClause[Op.or] = [
        { full_name: { [Op.iLike]: `%${search}%` } },
        { email: { [Op.iLike]: `%${search}%` } },
        { phone: { [Op.iLike]: `%${search}%` } },
        { drivers_license_number: { [Op.iLike]: `%${search}%` } },
        { company_name: { [Op.iLike]: `%${search}%` } },
      ];
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch customers
    const { count, rows: customers } = await Customer.findAndCountAll({
      where: whereClause,
      limit: parseInt(limit),
      offset: offset,
      order: [[sort_by, sort_order.toUpperCase()]],
      attributes: {
        exclude: ['id_card_photo_url', 'license_photo_url'], // Don't send photo URLs in list
      },
    });

    console.log(`ðŸ“‹ Fetched ${customers.length} customers for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Customers fetched successfully',
      data: { customers },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customers error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch customers',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/customers/:id - Get single customer with full details
// ============================================
const getCustomerById = async (req, res) => {
  try {
    const { id } = req.params;

    const customer = await Customer.findOne({
      where: applyTenantFilter(req, { id }),
    });

    if (!customer) {
      return sendError(res, {
        statusCode: 404,
        message: 'Customer not found',
      });
    }

    console.log(`ðŸ‘¤ Customer fetched: ${customer.full_name}`);

    sendSuccess(res, {
      message: 'Customer fetched successfully',
      data: { customer },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customer error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch customer',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/customers/:id/history - Get customer rental history
// ============================================
const getCustomerHistory = async (req, res) => {
  try {
    const { id: customer_id } = req.params;
    const { status, start_date, end_date, page = 1, limit = 10 } = req.query;

    // Check if customer exists and belongs to company
    const customer = await Customer.findOne({
      where: applyTenantFilter(req, { id: customer_id }),
    });

    if (!customer) {
      return sendError(res, {
        statusCode: 404,
        message: 'Customer not found',
      });
    }

    // Build filter for contracts
    const whereClause = {
      customer_id,
      company_id: req.companyId, // Ensure tenant isolation
    };

    if (status) {
      whereClause.status = status;
    }

    if (start_date || end_date) {
      whereClause.start_date = {};
      if (start_date) whereClause.start_date[Op.gte] = start_date;
      if (end_date) whereClause.start_date[Op.lte] = end_date;
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch contracts with vehicle and payment details
    const { count, rows: contracts } = await Contract.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: Vehicle,
          as: 'vehicle',
          attributes: ['id', 'brand', 'model', 'year', 'registration_number'],
        },
        {
          model: Payment,
          as: 'payments',
          attributes: ['id', 'amount', 'payment_method', 'payment_date', 'status'],
        },
      ],
      limit: parseInt(limit),
      offset: offset,
      order: [['start_date', 'DESC']],
    });

    // Calculate statistics
    const stats = {
      total_contracts: count,
      total_spent: contracts.reduce((sum, c) => sum + parseFloat(c.total_amount || 0), 0),
      completed_contracts: contracts.filter(c => c.status === 'completed').length,
      active_contracts: contracts.filter(c => c.status === 'active').length,
    };

    console.log(`ðŸ“œ Fetched ${contracts.length} contracts for customer ${customer_id}`);

    sendSuccess(res, {
      message: 'Customer rental history fetched successfully',
      data: { 
        customer: {
          id: customer.id,
          full_name: customer.full_name,
          email: customer.email,
          phone: customer.phone,
        },
        contracts,
        stats,
      },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customer history error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch customer history',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/customers - Create new customer
// ============================================
const createCustomer = [
  // Validators
  body('customer_type').isIn(['individual', 'corporate']).withMessage('Valid customer type required'),
  body('full_name').notEmpty().withMessage('Full name is required').trim(),
  body('company_name').optional().trim(),
  body('email').optional().isEmail().withMessage('Valid email required').normalizeEmail(),
  body('phone').notEmpty().withMessage('Phone is required').trim(),
  body('address').optional().trim(),
  body('city').optional().trim(),
  body('date_of_birth').optional().isISO8601().withMessage('Valid date required'),
  body('id_card_number').optional().trim(),
  body('drivers_license_number').optional().trim(),
  body('license_expiry_date').optional().isISO8601().withMessage('Valid date required'),
  body('emergency_contact_name').optional().trim(),
  body('emergency_contact_phone').optional().trim(),
  body('apply_tier_discount').optional().isBoolean(),
  body('notes').optional().trim(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      // Check if license number already exists (if provided)
      if (req.body.drivers_license_number) {
        const existingCustomer = await Customer.findOne({
          where: { drivers_license_number: req.body.drivers_license_number },
        });

        if (existingCustomer) {
          return sendError(res, {
            statusCode: 409,
            message: 'Customer with this license number already exists',
          });
        }
      }

      // Apply tenant data (adds company_id automatically)
      const customerData = applyTenantData(req, req.body);

      const customer = await Customer.create(customerData);

      console.log(`ðŸ‘¤ New customer created: ${customer.full_name} (${customer.customer_type})`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Customer created successfully',
        data: { customer },
      });
    } catch (error) {
      console.error('ðŸ’¥ Create customer error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to create customer',
        details: error.message,
      });
    }
  },
];

// ============================================
// PUT /api/customers/:id - Update customer
// ============================================
const updateCustomer = [
  // Validators (all optional for update)
  body('customer_type').optional().isIn(['individual', 'corporate']),
  body('full_name').optional().notEmpty().trim(),
  body('company_name').optional().trim(),
  body('email').optional().isEmail().normalizeEmail(),
  body('phone').optional().notEmpty().trim(),
  body('address').optional().trim(),
  body('city').optional().trim(),
  body('date_of_birth').optional().isISO8601(),
  body('drivers_license_number').optional().trim(),
  body('license_expiry_date').optional().isISO8601(),
  body('is_blacklisted').optional().isBoolean(),
  body('apply_tier_discount').optional().isBoolean(),
  body('notes').optional().trim(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;

      // Check if customer exists and belongs to company
      const customer = await Customer.findOne({
        where: applyTenantFilter(req, { id }),
      });

      if (!customer) {
        return sendError(res, {
          statusCode: 404,
          message: 'Customer not found',
        });
      }

      // If license number is being updated, check uniqueness
      if (req.body.drivers_license_number && req.body.drivers_license_number !== customer.drivers_license_number) {
        const existingCustomer = await Customer.findOne({
          where: { drivers_license_number: req.body.drivers_license_number },
        });

        if (existingCustomer) {
          return sendError(res, {
            statusCode: 409,
            message: 'Customer with this license number already exists',
          });
        }
      }

      // Update customer
      await customer.update(req.body);

      console.log(`ðŸ”„ Customer updated: ${customer.full_name}`);

      sendSuccess(res, {
        message: 'Customer updated successfully',
        data: { customer },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update customer error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to update customer',
        details: error.message,
      });
    }
  },
];

// ============================================
// DELETE /api/customers/:id - Delete customer
// ============================================
const deleteCustomer = async (req, res) => {
  try {
    const { id } = req.params;

    // Check if customer exists and belongs to company
    const customer = await Customer.findOne({
      where: applyTenantFilter(req, { id }),
    });

    if (!customer) {
      return sendError(res, {
        statusCode: 404,
        message: 'Customer not found',
      });
    }

    // Check if customer has active contracts
    const activeContracts = await Contract.count({
      where: {
        customer_id: id,
        status: 'active',
      },
    });

    if (activeContracts > 0) {
      return sendError(res, {
        statusCode: 409,
        message: 'Cannot delete customer with active contracts',
      });
    }

    // Instead of hard delete, you could soft-delete by setting a flag
    // For now, we'll do a hard delete but you can modify this
    await customer.destroy();

    console.log(`ðŸ—‘ï¸ Customer deleted: ${customer.full_name}`);

    sendSuccess(res, {
      message: 'Customer deleted successfully',
      data: { id },
    });
  } catch (error) {
    console.error('ðŸ’¥ Delete customer error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to delete customer',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/customers/stats - Get customer statistics
// ============================================
const getCustomerStats = async (req, res) => {
  try {
    const companyFilter = { company_id: req.companyId };

    // Get total customers
    const totalCustomers = await Customer.count({ where: companyFilter });

    // Get customers by type
    const individual = await Customer.count({ 
      where: { ...companyFilter, customer_type: 'individual' } 
    });
    const corporate = await Customer.count({ 
      where: { ...companyFilter, customer_type: 'corporate' } 
    });

    // Get blacklisted customers
    const blacklisted = await Customer.count({ 
      where: { ...companyFilter, is_blacklisted: true } 
    });

    // Get top customers by lifetime value
    const topCustomers = await Customer.findAll({
      where: companyFilter,
      order: [['lifetime_value', 'DESC']],
      limit: 5,
      attributes: ['id', 'full_name', 'email', 'total_rentals', 'lifetime_value'],
    });

    // Get recent customers (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    const recentCustomers = await Customer.count({
      where: {
        ...companyFilter,
        created_at: { [Op.gte]: thirtyDaysAgo },
      },
    });

    const stats = {
      total_customers: totalCustomers,
      by_type: {
        individual,
        corporate,
      },
      blacklisted,
      recent_customers_30d: recentCustomers,
      top_customers: topCustomers,
    };

    console.log(`ðŸ“Š Customer stats fetched for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Customer statistics fetched successfully',
      data: { stats },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get customer stats error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch customer statistics',
      details: error.message,
    });
  }
};

module.exports = {
  getAllCustomers,
  getCustomerById,
  getCustomerHistory,
  createCustomer,
  updateCustomer,
  deleteCustomer,
  getCustomerStats,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\employee.controller.js
// src/controllers/employee.controller.js
const { Employee, User, Contract, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');
const { hashPassword } = require('../utils/bcrypt.util');

// RBAC: Role definitions with permissions
const ROLES = {
  owner: {
    label: 'Owner',
    description: 'Full system access including billing',
    permissions: ['*'], // All permissions
  },
  admin: {
    label: 'Administrator',
    description: 'Nearly full access, manages employees and settings',
    permissions: [
      'view_dashboard',
      'view_analytics',
      'create_employees',
      'update_employees',
      'delete_employees',
      'view_employees',
      'create_vehicles',
      'update_vehicles',
      'delete_vehicles',
      'view_vehicles',
      'create_customers',
      'update_customers',
      'delete_customers',
      'view_customers',
      'create_contracts',
      'update_contracts',
      'cancel_contracts',
      'view_contracts',
      'create_payments',
      'update_payments',
      'view_payments',
      'manage_settings',
    ],
  },
  manager: {
    label: 'Manager',
    description: 'Operational control, views analytics',
    permissions: [
      'view_dashboard',
      'view_analytics',
      'view_employees',
      'create_vehicles',
      'update_vehicles',
      'view_vehicles',
      'create_customers',
      'update_customers',
      'view_customers',
      'create_contracts',
      'update_contracts',
      'complete_contracts',
      'view_contracts',
      'create_payments',
      'view_payments',
    ],
  },
  sales_agent: {
    label: 'Sales Agent',
    description: 'Creates contracts, manages customers, processes payments',
    permissions: [
      'view_dashboard',
      'create_customers',
      'update_customers',
      'view_customers',
      'create_contracts',
      'update_contracts',
      'view_contracts',
      'create_payments',
      'view_payments',
      'view_vehicles', // Read-only for booking
    ],
  },
  fleet_coordinator: {
    label: 'Fleet Coordinator',
    description: 'Manages vehicles and maintenance',
    permissions: [
      'view_dashboard',
      'create_vehicles',
      'update_vehicles',
      'view_vehicles',
      'add_vehicle_costs',
      'view_vehicle_costs',
      'view_contracts', // Read-only for scheduling
    ],
  },
  accountant: {
    label: 'Accountant',
    description: 'Financial operations and analytics',
    permissions: [
      'view_dashboard',
      'view_analytics',
      'view_payments',
      'create_payments',
      'update_payments',
      'view_contracts', // Read-only
      'view_customers', // Read-only
      'view_attendance',
      'manage_payroll',
      'view_payroll',
      'approve_payroll',
    ],
  },
  receptionist: {
    label: 'Receptionist',
    description: 'Basic operations: check-in/out, contracts, payments',
    permissions: [
      'view_dashboard',
      'view_customers',
      'create_customers',
      'create_contracts',
      'view_contracts',
      'create_payments',
      'view_payments',
      'view_vehicles', // Read-only
      'create_attendance',
      'view_attendance',
    ],
  },
  staff: {  // Legacy
    label: 'Staff',
    description: 'General staff access',
    permissions: ['view_dashboard', 'view_customers', 'view_vehicles'],
  },
  viewer: {  // Legacy
    label: 'Viewer',
    description: 'Read-only access',
    permissions: ['view_dashboard'],
  },
};

// ============================================
// HELPER: Check if user has permission
// ============================================
const hasPermission = (employee, requiredPermission) => {
  // Get role permissions
  const rolePermissions = ROLES[employee.role]?.permissions || [];
  
  // Owner has all permissions
  if (rolePermissions.includes('*')) return true;
  
  // Check role permissions
  if (rolePermissions.includes(requiredPermission)) return true;
  
  // Check custom permissions
  if (employee.custom_permissions?.[requiredPermission] === true) return true;
  
  return false;
};

// ============================================
// GET /api/employees/roles - Get available roles
// ============================================
const getAvailableRoles = async (req, res) => {
  try {
    const roles = Object.entries(ROLES).map(([value, config]) => ({
      value,
      label: config.label,
      description: config.description,
      permissions: config.permissions,
    }));

    sendSuccess(res, {
      message: 'Available roles fetched successfully',
      data: { roles },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get roles error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch roles',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/employees - List all employees
// ============================================
const getAllEmployees = async (req, res) => {
  try {
    const {
      status,
      role,
      department,
      search,
      page = 1,
      limit = 20,
      sort_by = 'created_at',
      sort_order = 'DESC',
    } = req.query;

    const whereClause = applyTenantFilter(req);

    if (status) whereClause.status = status;
    if (role) whereClause.role = role;
    if (department) whereClause.department = department;

    // Search by name, email, phone, position
    if (search) {
      whereClause[Op.or] = [
        { full_name: { [Op.iLike]: `%${search}%` } },
        { email: { [Op.iLike]: `%${search}%` } },
        { phone: { [Op.iLike]: `%${search}%` } },
        { position: { [Op.iLike]: `%${search}%` } },
      ];
    }

    const offset = (parseInt(page) - 1) * parseInt(limit);

    const { count, rows: employees } = await Employee.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['id', 'email', 'is_active', 'last_login_at'],
        },
      ],
      limit: parseInt(limit),
      offset: offset,
      order: [[sort_by, sort_order.toUpperCase()]],
    });

    console.log(`ðŸ‘¥ Fetched ${employees.length} employees for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Employees fetched successfully',
      data: { employees },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get employees error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch employees',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/employees/:id - Get single employee
// ============================================
const getEmployeeById = async (req, res) => {
  try {
    const { id } = req.params;

    const employee = await Employee.findOne({
      where: applyTenantFilter(req, { id }),
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['id', 'email', 'role', 'is_active', 'last_login_at'],
        },
        {
          model: Contract,
          as: 'created_contracts',
          attributes: ['id', 'contract_number', 'total_amount', 'status'],
          limit: 10,
          order: [['created_at', 'DESC']],
        },
      ],
    });

    if (!employee) {
      return sendError(res, {
        statusCode: 404,
        message: 'Employee not found',
      });
    }

    console.log(`ðŸ‘¤ Employee fetched: ${employee.full_name}`);

    sendSuccess(res, {
      message: 'Employee fetched successfully',
      data: { employee },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get employee error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch employee',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/employees - Create employee
// ============================================
const createEmployee = [
  // Validators
  body('full_name').notEmpty().withMessage('Full name is required').trim(),
  body('email').isEmail().withMessage('Valid email required').normalizeEmail(),
  body('phone').notEmpty().withMessage('Phone is required').trim(),
  body('password')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters'),
  body('role')
    .isIn(Object.keys(ROLES))
    .withMessage(`Role must be one of: ${Object.keys(ROLES).join(', ')}`),
  body('department')
    .optional()
    .isIn(['management', 'sales', 'fleet', 'finance', 'customer_service', 'operations']),
  body('position').optional().trim(),
  body('salary_type')
    .optional()
    .isIn(['hourly', 'monthly', 'commission', 'fixed_plus_commission']),
  body('salary').optional().isFloat({ min: 0 }),
  body('commission_rate').optional().isFloat({ min: 0, max: 100 }),
  body('hire_date').isISO8601().withMessage('Valid hire date required'),
  body('work_schedule').optional().isObject(),
  body('custom_permissions').optional().isObject(),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }
      console.log('ðŸ“ Create request body:', req.body);
      console.log('ðŸ‘¤ Requester role:', req.user.role);
      console.log('ðŸ¢ Company ID:', req.companyId);

      const { email, password, role, ...employeeData } = req.body;

      // Check if email already exists
      const existingUser = await User.findOne({ where: { email } });
      if (existingUser) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: 'Email already in use',
        });
      }

      // Only owner/admin can create employees
      if (!['owner', 'admin'].includes(req.user.role)) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 403,
          message: 'Only owners and admins can create employees',
        });
      }

      // Create User account first
      const user = await User.create(
        {
          company_id: req.companyId,
          full_name: employeeData.full_name,
          email,
          password, // Model hook will hash this
          role, // User role matches employee role
          is_active: true,
        },
        { transaction }
      );

      // Create Employee profile
      const employee = await Employee.create(
        applyTenantData(req, {
          ...employeeData,
          email,
          role,
          user_id: user.id,
          status: 'active',
          custom_permissions: employeeData.custom_permissions || {},
          work_schedule: employeeData.work_schedule || {
            monday: { start: '09:00', end: '17:00' },
            tuesday: { start: '09:00', end: '17:00' },
            wednesday: { start: '09:00', end: '17:00' },
            thursday: { start: '09:00', end: '17:00' },
            friday: { start: '09:00', end: '17:00' },
          },
        }),
        { transaction }
      );

      await transaction.commit();

      // Fetch with relations
      const fullEmployee = await Employee.findByPk(employee.id, {
        include: [{ model: User, as: 'user', attributes: ['id', 'email', 'role'] }],
      });

      console.log(`ðŸ‘¤ New employee created: ${employee.full_name} (${role})`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Employee created successfully',
        data: {
          employee: fullEmployee,
          login_credentials: {
            email,
            temporary_password: '(sent to employee email)', // In production, send via email
          },
        },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Create employee error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to create employee',
        details: error.message,
      });
    }
  },
];

// ============================================
// PUT /api/employees/:id - Update employee
// ============================================
const updateEmployee = [
  body('full_name').optional().notEmpty().trim(),
  body('phone').optional().notEmpty().trim(),
  body('position').optional().trim(),
  body('department').optional().isIn(['management', 'sales', 'fleet', 'finance', 'customer_service', 'operations']),
  body('salary').optional().isFloat({ min: 0 }),
  body('commission_rate').optional().isFloat({ min: 0, max: 100 }),
  body('status').optional().isIn(['active', 'on_leave', 'suspended', 'terminated']),
  body('custom_permissions').optional().isObject(),
  body('work_schedule').optional().isObject(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;

      const employee = await Employee.findOne({
        where: applyTenantFilter(req, { id }),
      });

      if (!employee) {
        return sendError(res, { statusCode: 404, message: 'Employee not found' });
      }

      // Only owner/admin can update employees
      if (!['owner', 'admin'].includes(req.user.role)) {
        return sendError(res, {
          statusCode: 403,
          message: 'Only owners and admins can update employees',
        });
      }

      await employee.update(req.body);

      console.log(`ðŸ”„ Employee updated: ${employee.full_name}`);

      sendSuccess(res, {
        message: 'Employee updated successfully',
        data: { employee },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update employee error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to update employee',
        details: error.message,
      });
    }
  },
];

// ============================================
// DELETE /api/employees/:id - Terminate employee
// ============================================
const terminateEmployee = async (req, res) => {
  const transaction = await sequelize.transaction();

  try {
    const { id } = req.params;

    const employee = await Employee.findOne({
      where: applyTenantFilter(req, { id }),
      include: [{ model: User, as: 'user' }],
    });

    if (!employee) {
      await transaction.rollback();
      return sendError(res, { statusCode: 404, message: 'Employee not found' });
    }

    // Only owner can terminate
    if (req.user.role !== 'owner') {
      await transaction.rollback();
      return sendError(res, {
        statusCode: 403,
        message: 'Only owners can terminate employees',
      });
    }

    // Cannot terminate owner
    if (employee.role === 'owner') {
      await transaction.rollback();
      return sendError(res, {
        statusCode: 403,
        message: 'Cannot terminate owner account',
      });
    }

    // Soft delete: Update status
    await employee.update(
      {
        status: 'terminated',
        termination_date: new Date(),
      },
      { transaction }
    );

    // Deactivate user account
    if (employee.user) {
      await employee.user.update({ is_active: false }, { transaction });
    }

    await transaction.commit();

    console.log(`ðŸ—‘ï¸ Employee terminated: ${employee.full_name}`);

    sendSuccess(res, {
      message: 'Employee terminated successfully',
      data: { employee },
    });
  } catch (error) {
    await transaction.rollback();
    console.error('ðŸ’¥ Terminate employee error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to terminate employee',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/employees/:id/reset-password
// ============================================
const resetEmployeePassword = [
  body('new_password')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters'),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;
      const { new_password } = req.body;

      const employee = await Employee.findOne({
        where: applyTenantFilter(req, { id }),
        include: [{ model: User, as: 'user' }],
      });

      if (!employee || !employee.user) {
        return sendError(res, { statusCode: 404, message: 'Employee not found' });
      }

      // Only owner/admin can reset passwords
      if (!['owner', 'admin'].includes(req.user.role)) {
        return sendError(res, {
          statusCode: 403,
          message: 'Only owners and admins can reset passwords',
        });
      }

      // Hash and update password
      const passwordHash = await hashPassword(new_password);
      await employee.user.update({ password_hash: passwordHash });

      console.log(`ðŸ”‘ Password reset for employee: ${employee.full_name}`);

      sendSuccess(res, {
        message: 'Password reset successfully',
      });
    } catch (error) {
      console.error('ðŸ’¥ Reset password error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to reset password',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/employees/stats - Get statistics
// ============================================
const getEmployeeStats = async (req, res) => {
  try {
    const companyFilter = { company_id: req.companyId };

    const totalEmployees = await Employee.count({ where: companyFilter });

    // By status
    const active = await Employee.count({ where: { ...companyFilter, status: 'active' } });
    const on_leave = await Employee.count({ where: { ...companyFilter, status: 'on_leave' } });
    const terminated = await Employee.count({ where: { ...companyFilter, status: 'terminated' } });

    // By role
    const byRole = await Employee.findAll({
      where: companyFilter,
      attributes: ['role', [sequelize.fn('COUNT', sequelize.col('id')), 'count']],
      group: ['role'],
      raw: true,
    });

    // Top performers
    const topPerformers = await Employee.findAll({
      where: { ...companyFilter, status: 'active' },
      order: [['total_revenue_generated', 'DESC']],
      limit: 5,
      attributes: ['id', 'full_name', 'role', 'total_contracts_created', 'total_revenue_generated'],
    });

    const stats = {
      total_employees: totalEmployees,
      by_status: { active, on_leave, terminated },
      by_role: byRole.reduce((acc, item) => {
        acc[item.role] = parseInt(item.count);
        return acc;
      }, {}),
      top_performers: topPerformers,
    };

    sendSuccess(res, {
      message: 'Employee statistics fetched successfully',
      data: { stats },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get employee stats error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch employee statistics',
      details: error.message,
    });
  }
};

module.exports = {
  getAllEmployees,
  getEmployeeById,
  createEmployee,
  updateEmployee,
  terminateEmployee,
  resetEmployeePassword,
  getEmployeeStats,
  getAvailableRoles,
  hasPermission, // Export for use in permission middleware
  ROLES, // Export for reference
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\payment.controller.js
// src/controllers/payment.controller.js
const { Payment, Contract, Customer, Vehicle, User, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');

// ============================================
// GET /api/payments - List all payments
// ============================================
const getAllPayments = async (req, res) => {
  try {
    const {
      contract_id,
      customer_id,
      payment_method,
      status,
      start_date,
      end_date,
      search,
      page = 1,
      limit = 20,
      sort_by = 'payment_date',
      sort_order = 'DESC',
    } = req.query;

    // Build filter with tenant isolation
    const whereClause = applyTenantFilter(req);

    // Apply filters
    if (contract_id) whereClause.contract_id = contract_id;
    if (customer_id) whereClause.customer_id = customer_id;
    if (payment_method) whereClause.payment_method = payment_method;
    if (status) whereClause.status = status;

    // Date range filter
    if (start_date || end_date) {
      whereClause.payment_date = {};
      if (start_date) whereClause.payment_date[Op.gte] = start_date;
      if (end_date) whereClause.payment_date[Op.lte] = end_date;
    }

    // Search by reference number
    if (search) {
      whereClause.reference_number = { [Op.iLike]: `%${search}%` };
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch payments with relations
    const { count, rows: payments } = await Payment.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: Contract,
          as: 'contract',
          attributes: ['id', 'contract_number', 'total_amount', 'status'],
          include: [
            {
              model: Vehicle,
              as: 'vehicle',
              attributes: ['id', 'brand', 'model', 'registration_number'],
            },
          ],
        },
        {
          model: Customer,
          as: 'customer',
          attributes: ['id', 'full_name', 'email', 'phone', 'customer_type'],
        },
        {
          model: User,
          as: 'processor',
          attributes: ['id', 'full_name', 'email'],
        },
      ],
      limit: parseInt(limit),
      offset: offset,
      order: [[sort_by, sort_order.toUpperCase()]],
    });

    console.log(`ðŸ’° Fetched ${payments.length} payments for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Payments fetched successfully',
      data: { payments },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get payments error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch payments',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/payments/:id - Get single payment
// ============================================
const getPaymentById = async (req, res) => {
  try {
    const { id } = req.params;

    const payment = await Payment.findOne({
      where: applyTenantFilter(req, { id }),
      include: [
        {
          model: Contract,
          as: 'contract',
          include: [
            {
              model: Vehicle,
              as: 'vehicle',
              attributes: ['id', 'brand', 'model', 'registration_number', 'year'],
            },
          ],
        },
        {
          model: Customer,
          as: 'customer',
        },
        {
          model: User,
          as: 'processor',
          attributes: ['id', 'full_name', 'email'],
        },
      ],
    });

    if (!payment) {
      return sendError(res, {
        statusCode: 404,
        message: 'Payment not found',
      });
    }

    console.log(`ðŸ’³ Payment fetched: ${payment.reference_number || payment.id}`);

    sendSuccess(res, {
      message: 'Payment fetched successfully',
      data: { payment },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get payment error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch payment',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/payments - Record new payment
// ============================================
const createPayment = [
  // Validators
  body('contract_id').isUUID().withMessage('Valid contract ID required'),
  body('amount').isFloat({ min: 0.01 }).withMessage('Valid amount required (must be positive)'),
  body('payment_method')
    .isIn(['cash', 'card', 'bank_transfer', 'check', 'mobile_payment'])
    .withMessage('Invalid payment method'),
  body('payment_date').optional().isISO8601().withMessage('Valid payment date required'),
  body('reference_number').optional().trim(),
  body('notes').optional().trim(),
  body('status')
    .optional()
    .isIn(['pending', 'completed', 'failed', 'refunded'])
    .withMessage('Invalid status'),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { contract_id, amount, payment_method, payment_date, reference_number, notes, status = 'completed' } = req.body;

      // Check if contract exists and belongs to company
      const contract = await Contract.findOne({
        where: applyTenantFilter(req, { id: contract_id }),
        include: [
          {
            model: Customer,
            as: 'customer',
          },
        ],
      });

      if (!contract) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Contract not found' });
      }

      // Validate payment amount doesn't exceed contract total
      const totalPaid = await Payment.sum('amount', {
        where: {
          contract_id,
          status: 'completed',
        },
      });

      const totalPaidAmount = parseFloat(totalPaid || 0);
      const contractTotal = parseFloat(contract.total_amount);
      const newPaymentAmount = parseFloat(amount);

      if (totalPaidAmount + newPaymentAmount > contractTotal) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: `Payment amount exceeds contract balance. Outstanding: ${(contractTotal - totalPaidAmount).toFixed(2)} DZD`,
        });
      }

      // Create payment
      const paymentData = applyTenantData(req, {
        contract_id,
        customer_id: contract.customer_id,
        amount: newPaymentAmount,
        payment_method,
        payment_date: payment_date || new Date(),
        reference_number,
        notes,
        status,
        processed_by: req.user.id,
      });

      const payment = await Payment.create(paymentData, { transaction });

      await transaction.commit();

      // Fetch payment with relations
      const fullPayment = await Payment.findByPk(payment.id, {
        include: [
          { model: Contract, as: 'contract' },
          { model: Customer, as: 'customer' },
          { model: User, as: 'processor', attributes: ['id', 'full_name'] },
        ],
      });

      console.log(`ðŸ’³ New payment recorded: ${newPaymentAmount} DZD for contract ${contract.contract_number}`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Payment recorded successfully',
        data: { payment: fullPayment },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Create payment error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to record payment',
        details: error.message,
      });
    }
  },
];

// ============================================
// PUT /api/payments/:id - Update payment
// ============================================
const updatePayment = [
  body('amount').optional().isFloat({ min: 0.01 }),
  body('payment_method').optional().isIn(['cash', 'card', 'bank_transfer', 'check', 'mobile_payment']),
  body('payment_date').optional().isISO8601(),
  body('reference_number').optional().trim(),
  body('status').optional().isIn(['pending', 'completed', 'failed', 'refunded']),
  body('notes').optional().trim(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;

      const payment = await Payment.findOne({
        where: applyTenantFilter(req, { id }),
      });

      if (!payment) {
        return sendError(res, { statusCode: 404, message: 'Payment not found' });
      }

      // Only allow updates for pending or failed payments
      if (payment.status === 'completed' && req.body.status !== 'refunded') {
        return sendError(res, {
          statusCode: 409,
          message: 'Cannot update completed payment (use refund instead)',
        });
      }

      await payment.update(req.body);

      console.log(`ðŸ”„ Payment updated: ${payment.id}`);

      sendSuccess(res, {
        message: 'Payment updated successfully',
        data: { payment },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update payment error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to update payment',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/payments/outstanding - Get outstanding payments
// ============================================
const getOutstandingPayments = async (req, res) => {
  try {
    const { customer_id, page = 1, limit = 20 } = req.query;

    // Build filter
    const contractWhere = applyTenantFilter(req, {
      status: { [Op.in]: ['active', 'completed'] },
    });

    if (customer_id) {
      contractWhere.customer_id = customer_id;
    }

    // Get all contracts with payments
    const contracts = await Contract.findAll({
      where: contractWhere,
      include: [
        {
          model: Payment,
          as: 'payments',
          where: { status: 'completed' },
          required: false,
        },
        {
          model: Customer,
          as: 'customer',
          attributes: ['id', 'full_name', 'email', 'phone', 'customer_type'],
        },
        {
          model: Vehicle,
          as: 'vehicle',
          attributes: ['id', 'brand', 'model', 'registration_number'],
        },
      ],
    });

    // Calculate outstanding balances
    const outstandingContracts = contracts
      .map((contract) => {
        const totalAmount = parseFloat(contract.total_amount);
        const totalPaid = contract.payments.reduce((sum, p) => sum + parseFloat(p.amount), 0);
        const outstanding = totalAmount - totalPaid;

        return {
          contract_id: contract.id,
          contract_number: contract.contract_number,
          customer: contract.customer,
          vehicle: contract.vehicle,
          total_amount: totalAmount,
          total_paid: totalPaid,
          outstanding_amount: outstanding,
          status: contract.status,
          start_date: contract.start_date,
          end_date: contract.end_date,
        };
      })
      .filter((c) => c.outstanding_amount > 0); // Only contracts with outstanding balance

    // Sort by outstanding amount (highest first)
    outstandingContracts.sort((a, b) => b.outstanding_amount - a.outstanding_amount);

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);
    const paginatedResults = outstandingContracts.slice(offset, offset + parseInt(limit));
    const totalOutstanding = outstandingContracts.reduce((sum, c) => sum + c.outstanding_amount, 0);

    console.log(`ðŸ“Š Found ${outstandingContracts.length} contracts with outstanding payments`);

    sendSuccess(res, {
      message: 'Outstanding payments fetched successfully',
      data: {
        outstanding_contracts: paginatedResults,
        summary: {
          total_contracts: outstandingContracts.length,
          total_outstanding_amount: totalOutstanding,
        },
      },
      meta: {
        pagination: {
          total: outstandingContracts.length,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(outstandingContracts.length / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get outstanding payments error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch outstanding payments',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/contracts/:id/payments - Get payments for contract
// ============================================
const getContractPayments = async (req, res) => {
  try {
    const { id: contract_id } = req.params;

    // Check if contract exists and belongs to company
    const contract = await Contract.findOne({
      where: applyTenantFilter(req, { id: contract_id }),
      include: [
        {
          model: Customer,
          as: 'customer',
          attributes: ['id', 'full_name', 'email', 'phone'],
        },
        {
          model: Vehicle,
          as: 'vehicle',
          attributes: ['id', 'brand', 'model', 'registration_number'],
        },
      ],
    });

    if (!contract) {
      return sendError(res, {
        statusCode: 404,
        message: 'Contract not found',
      });
    }

    // Get all payments for this contract
    const payments = await Payment.findAll({
      where: { contract_id },
      include: [
        {
          model: User,
          as: 'processor',
          attributes: ['id', 'full_name', 'email'],
        },
      ],
      order: [['payment_date', 'DESC']],
    });

    // Calculate payment summary
    const totalPaid = payments
      .filter((p) => p.status === 'completed')
      .reduce((sum, p) => sum + parseFloat(p.amount), 0);

    const totalAmount = parseFloat(contract.total_amount);
    const outstandingAmount = totalAmount - totalPaid;
    const paymentPercentage = ((totalPaid / totalAmount) * 100).toFixed(2);

    const summary = {
      contract_number: contract.contract_number,
      customer: contract.customer,
      vehicle: contract.vehicle,
      total_amount: totalAmount,
      total_paid: totalPaid,
      outstanding_amount: outstandingAmount,
      payment_percentage: parseFloat(paymentPercentage),
      payment_count: payments.length,
      completed_payments: payments.filter((p) => p.status === 'completed').length,
    };

    console.log(`ðŸ’° Fetched ${payments.length} payments for contract ${contract.contract_number}`);

    sendSuccess(res, {
      message: 'Contract payments fetched successfully',
      data: {
        payments,
        summary,
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get contract payments error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch contract payments',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/payments/stats - Get payment statistics
// ============================================
const getPaymentStats = async (req, res) => {
  try {
    const companyFilter = { company_id: req.companyId };

    // Total payments
    const totalPayments = await Payment.count({ where: companyFilter });

    // By status
    const completed = await Payment.count({ where: { ...companyFilter, status: 'completed' } });
    const pending = await Payment.count({ where: { ...companyFilter, status: 'pending' } });
    const failed = await Payment.count({ where: { ...companyFilter, status: 'failed' } });
    const refunded = await Payment.count({ where: { ...companyFilter, status: 'refunded' } });

    // By payment method
    const byMethod = await Payment.findAll({
      where: companyFilter,
      attributes: ['payment_method', [sequelize.fn('COUNT', sequelize.col('id')), 'count']],
      group: ['payment_method'],
      raw: true,
    });

    // Total revenue
    const revenueResult = await Payment.findOne({
      where: { ...companyFilter, status: 'completed' },
      attributes: [[sequelize.fn('SUM', sequelize.col('amount')), 'total_revenue']],
      raw: true,
    });

    // Recent payments (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const recentPayments = await Payment.count({
      where: {
        ...companyFilter,
        payment_date: { [Op.gte]: thirtyDaysAgo },
        status: 'completed',
      },
    });

    const recentRevenue = await Payment.findOne({
      where: {
        ...companyFilter,
        payment_date: { [Op.gte]: thirtyDaysAgo },
        status: 'completed',
      },
      attributes: [[sequelize.fn('SUM', sequelize.col('amount')), 'revenue']],
      raw: true,
    });

    const stats = {
      total_payments: totalPayments,
      by_status: { completed, pending, failed, refunded },
      by_method: byMethod.reduce((acc, item) => {
        acc[item.payment_method] = parseInt(item.count);
        return acc;
      }, {}),
      total_revenue: parseFloat(revenueResult?.total_revenue || 0),
      recent_payments_30d: recentPayments,
      recent_revenue_30d: parseFloat(recentRevenue?.revenue || 0),
    };

    sendSuccess(res, {
      message: 'Payment statistics fetched successfully',
      data: { stats },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get payment stats error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch payment statistics',
      details: error.message,
    });
  }
};

module.exports = {
  getAllPayments,
  getPaymentById,
  createPayment,
  updatePayment,
  getOutstandingPayments,
  getContractPayments,
  getPaymentStats,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\payroll.controller.js
// src/controllers/payroll.controller.js
const { Payroll, Employee, Attendance, User, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, query, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');

// ============================================
// POST /api/payroll/calculate
// Calculate payroll for an employee for a period
// ============================================
const calculatePayroll = [
  body('employee_id').isUUID().withMessage('Valid employee ID required'),
  body('pay_period_start').isISO8601().withMessage('Valid start date required'),
  body('pay_period_end').isISO8601().withMessage('Valid end date required'),
  body('payment_date').optional().isISO8601(),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { employee_id, pay_period_start, pay_period_end, payment_date } = req.body;

      // Get employee
      const employee = await Employee.findOne({
        where: applyTenantFilter(req, { id: employee_id }),
      });

      if (!employee) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Employee not found' });
      }

      // Check if payroll already exists
      const existingPayroll = await Payroll.findOne({
        where: {
          employee_id,
          pay_period_start,
          pay_period_end,
        },
      });

      if (existingPayroll) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 409,
          message: 'Payroll already exists for this period',
        });
      }

      // Calculate period days
      const startDate = new Date(pay_period_start);
      const endDate = new Date(pay_period_end);
      const totalDaysInPeriod = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;

      // Get attendance records
      const attendanceRecords = await Attendance.findAll({
        where: {
          employee_id,
          date: {
            [Op.between]: [pay_period_start, pay_period_end],
          },
        },
      });

      // Calculate attendance metrics
      const daysPresent = attendanceRecords.filter(a => ['present', 'late', 'half_day'].includes(a.status)).length;
      const daysAbsent = attendanceRecords.filter(a => a.status === 'absent').length;
      const daysOnLeave = attendanceRecords.filter(a => a.status === 'leave').length;
      const totalHoursWorked = attendanceRecords.reduce((sum, a) => sum + parseFloat(a.total_hours || 0), 0);
      const overtimeHours = attendanceRecords.reduce((sum, a) => sum + parseFloat(a.overtime_hours || 0), 0);

      // Calculate salary
      const baseSalary = parseFloat(employee.salary || 0);
      let calculatedSalary = baseSalary;

      // Adjust for attendance if monthly salary
      if (employee.salary_type === 'monthly' && daysAbsent > 0) {
        const perDayRate = baseSalary / totalDaysInPeriod;
        calculatedSalary = baseSalary - (perDayRate * daysAbsent);
      }

      // Earnings breakdown
      const earnings = {
        basic_pay: calculatedSalary,
        overtime_pay: overtimeHours * (baseSalary / (totalDaysInPeriod * 8)) * 1.5, // 1.5x for overtime
      };

      // Add commission if applicable
      if (employee.salary_type === 'commission' || employee.salary_type === 'fixed_plus_commission') {
        const commissionRate = parseFloat(employee.commission_rate || 0);
        const revenueGenerated = parseFloat(employee.total_revenue_generated || 0);
        earnings.commission = (revenueGenerated * commissionRate) / 100;
      }

      const grossSalary = Object.values(earnings).reduce((sum, val) => sum + val, 0);

      // Deductions (example: 9% social security, 20% income tax)
      const deductions = {
        social_security: grossSalary * 0.09,
        income_tax: grossSalary * 0.20,
        unpaid_leave_deduction: (baseSalary / totalDaysInPeriod) * daysAbsent,
      };

      const totalDeductions = Object.values(deductions).reduce((sum, val) => sum + val, 0);
      const netSalary = grossSalary - totalDeductions;

      // Create payroll
      const payroll = await Payroll.create(
        applyTenantData(req, {
          employee_id,
          pay_period_start,
          pay_period_end,
          payment_date: payment_date || null,
          base_salary: baseSalary,
          gross_salary: grossSalary,
          net_salary: netSalary,
          total_days_in_period: totalDaysInPeriod,
          days_present: daysPresent,
          days_absent: daysAbsent,
          days_on_leave: daysOnLeave,
          total_hours_worked: totalHoursWorked,
          overtime_hours: overtimeHours,
          earnings,
          deductions,
          payment_status: 'pending',
          calculated_by: req.user.id,
        }),
        { transaction }
      );

      await transaction.commit();

      console.log(`ðŸ’° Payroll calculated for ${employee.full_name}: ${netSalary} DZD`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Payroll calculated successfully',
        data: { payroll },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Calculate payroll error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to calculate payroll',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/payroll
// Get payroll records with filters
// ============================================
const getPayroll = [
  query('employee_id').optional().isUUID(),
  query('month').optional().matches(/^\d{4}-\d{2}$/),
  query('status').optional().isIn(['pending', 'approved', 'paid', 'cancelled']),
  query('page').optional().isInt({ min: 1 }),
  query('limit').optional().isInt({ min: 1, max: 100 }),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { employee_id, month, status, page = 1, limit = 20 } = req.query;

      const whereClause = applyTenantFilter(req);

      if (employee_id) whereClause.employee_id = employee_id;
      if (status) whereClause.payment_status = status;

      if (month) {
        const [year, monthNum] = month.split('-');
        whereClause.pay_period_start = {
          [Op.gte]: `${year}-${monthNum}-01`,
          [Op.lt]: `${year}-${String(parseInt(monthNum) + 1).padStart(2, '0')}-01`,
        };
      }

      const offset = (parseInt(page) - 1) * parseInt(limit);

      const { count, rows: payroll } = await Payroll.findAndCountAll({
        where: whereClause,
        include: [
          {
            model: Employee,
            as: 'employee',
            attributes: ['id', 'full_name', 'position', 'department'],
          },
        ],
        limit: parseInt(limit),
        offset,
        order: [['pay_period_end', 'DESC']],
      });

      sendSuccess(res, {
        message: 'Payroll records fetched successfully',
        data: { payroll },
        meta: {
          pagination: {
            total: count,
            page: parseInt(page),
            limit: parseInt(limit),
            total_pages: Math.ceil(count / parseInt(limit)),
          },
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get payroll error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch payroll',
        details: error.message,
      });
    }
  },
];

// ============================================
// PUT /api/payroll/:id/approve
// Approve payroll
// ============================================
const approvePayroll = async (req, res) => {
  try {
    const { id } = req.params;

    const payroll = await Payroll.findOne({
      where: applyTenantFilter(req, { id }),
    });

    if (!payroll) {
      return sendError(res, { statusCode: 404, message: 'Payroll not found' });
    }

    if (payroll.payment_status !== 'pending') {
      return sendError(res, {
        statusCode: 409,
        message: `Cannot approve ${payroll.payment_status} payroll`,
      });
    }

    await payroll.update({
      payment_status: 'approved',
      approved_by: req.user.id,
    });

    console.log(`âœ… Payroll approved: ${payroll.id}`);

    sendSuccess(res, {
      message: 'Payroll approved successfully',
      data: { payroll },
    });
  } catch (error) {
    console.error('ðŸ’¥ Approve payroll error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to approve payroll',
      details: error.message,
    });
  }
};

// ============================================
// PUT /api/payroll/:id/pay
// Mark payroll as paid
// ============================================
const markAsPaid = [
  body('payment_date').isISO8601().withMessage('Valid payment date required'),
  body('payment_method').isIn(['bank_transfer', 'cash', 'check']),
  body('payment_reference').optional().trim(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;
      const { payment_date, payment_method, payment_reference } = req.body;

      const payroll = await Payroll.findOne({
        where: applyTenantFilter(req, { id }),
      });

      if (!payroll) {
        return sendError(res, { statusCode: 404, message: 'Payroll not found' });
      }

      if (payroll.payment_status !== 'approved') {
        return sendError(res, {
          statusCode: 409,
          message: 'Payroll must be approved before marking as paid',
        });
      }

      await payroll.update({
        payment_status: 'paid',
        payment_date,
        payment_method,
        payment_reference,
        paid_by: req.user.id,
      });

      console.log(`âœ… Payroll marked as paid: ${payroll.id}`);

      sendSuccess(res, {
        message: 'Payroll marked as paid successfully',
        data: { payroll },
      });
    } catch (error) {
      console.error('ðŸ’¥ Mark as paid error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to mark payroll as paid',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/payroll/stats
// Get payroll statistics
// ============================================
const getPayrollStats = [
  query('month').optional().matches(/^\d{4}-\d{2}$/),

  async (req, res) => {
    try {
      const { month } = req.query;

      const whereClause = applyTenantFilter(req);

      if (month) {
        const [year, monthNum] = month.split('-');
        whereClause.pay_period_start = {
          [Op.gte]: `${year}-${monthNum}-01`,
          [Op.lt]: `${year}-${String(parseInt(monthNum) + 1).padStart(2, '0')}-01`,
        };
      }

      const stats = await Payroll.findOne({
        where: whereClause,
        attributes: [
          [sequelize.fn('COUNT', sequelize.col('id')), 'total_payrolls'],
          [sequelize.fn('SUM', sequelize.col('gross_salary')), 'total_gross'],
          [sequelize.fn('SUM', sequelize.col('net_salary')), 'total_net'],
        ],
        raw: true,
      });

      const byStatus = await Payroll.findAll({
        where: whereClause,
        attributes: [
          'payment_status',
          [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
          [sequelize.fn('SUM', sequelize.col('net_salary')), 'amount'],
        ],
        group: ['payment_status'],
        raw: true,
      });

      sendSuccess(res, {
        message: 'Payroll statistics fetched successfully',
        data: {
          stats,
          by_status: byStatus,
        },
      });
    } catch (error) {
      console.error('ðŸ’¥ Get payroll stats error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to fetch payroll statistics',
        details: error.message,
      });
    }
  },
];

module.exports = {
  calculatePayroll,
  getPayroll,
  approvePayroll,
  markAsPaid,
  getPayrollStats,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\reports.controller.js
// src/controllers/reports.controller.js
const reportService = require('../services/reportGeneration.service');
const { sendSuccess, sendError } = require('../utils/response.util');
const { query, validationResult } = require('express-validator');
const ExcelJS = require('exceljs');
const { generateReportPDF: generatePDFFile } = require('../utils/pdfGenerator.util');

/**
 * GET /api/reports/:type
 * Generate report in JSON format
 */
const generateReport = [
  query('startDate').optional().isISO8601(),
  query('endDate').optional().isISO8601(),
  query('vehicleIds').optional().isArray(),
  query('customerIds').optional().isArray(),
  query('minRevenue').optional().isFloat({ min: 0 }),
  query('maxRevenue').optional().isFloat({ min: 0 }),
  query('minUtilization').optional().isFloat({ min: 0, max: 100 }),
  query('maxUtilization').optional().isFloat({ min: 0, max: 100 }),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { type } = req.params;
      const filters = req.query;
      const companyId = req.companyId;

      console.log(`ðŸ“Š Generating ${type} report for company ${companyId}`);

      const report = await reportService.generateReport(companyId, type, filters);

      sendSuccess(res, {
        message: `${type} report generated successfully`,
        data: { report },
      });
    } catch (error) {
      console.error('ðŸ’¥ Generate report error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to generate report',
        details: error.message,
      });
    }
  },
];

/**
 * GET /api/reports/:type/pdf
 * Generate report as PDF
 */
const generateReportPDF = [
  query('startDate').optional().isISO8601(),
  query('endDate').optional().isISO8601(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { type } = req.params;
      const filters = req.query;
      const companyId = req.companyId;

      console.log(`ðŸ“„ Generating ${type} PDF report for company ${companyId}`);

      // Generate report data
      const report = await reportService.generateReport(companyId, type, filters);

      // Generate PDF
      const pdfBuffer = await generatePDFFile(report, type);

      // Set response headers
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${type}_report_${Date.now()}.pdf"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('ðŸ’¥ Generate PDF report error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to generate PDF report',
        details: error.message,
      });
    }
  },
];

/**
 * GET /api/reports/:type/excel
 * Generate report as Excel file
 */
const generateReportExcel = [
  query('startDate').optional().isISO8601(),
  query('endDate').optional().isISO8601(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { type } = req.params;
      const filters = req.query;
      const companyId = req.companyId;

      console.log(`ðŸ“Š Generating ${type} Excel report for company ${companyId}`);

      // Generate report data
      const report = await reportService.generateReport(companyId, type, filters);

      // Create Excel workbook
      const workbook = new ExcelJS.Workbook();
      const worksheet = workbook.addWorksheet(`${type} Report`);

      // Add report data based on type
      if (type === 'executive') {
        worksheet.columns = [
          { header: 'Metric', key: 'metric', width: 30 },
          { header: 'Value', key: 'value', width: 20 },
        ];

        worksheet.addRows([
          { metric: 'Total Revenue', value: report.summary.total_revenue },
          { metric: 'Revenue Growth', value: `${report.summary.revenue_growth.toFixed(2)}%` },
          { metric: 'Total Contracts', value: report.summary.total_contracts },
          { metric: 'Fleet Utilization', value: `${report.summary.fleet_utilization.toFixed(2)}%` },
          { metric: 'Active Customers', value: report.summary.active_customers },
          { metric: 'New Customers', value: report.summary.new_customers },
        ]);
      } else if (type === 'vehicle') {
        worksheet.columns = [
          { header: 'Vehicle', key: 'vehicle', width: 30 },
          { header: 'Registration', key: 'registration', width: 20 },
          { header: 'Utilization', key: 'utilization', width: 15 },
          { header: 'Revenue', key: 'revenue', width: 15 },
          { header: 'Costs', key: 'costs', width: 15 },
          { header: 'Profit', key: 'profit', width: 15 },
        ];

        report.all_vehicles.forEach(v => {
          worksheet.addRow({
            vehicle: `${v.brand} ${v.model}`,
            registration: v.registration_number,
            utilization: `${v.utilization_rate.toFixed(2)}%`,
            revenue: v.total_revenue,
            costs: v.total_costs,
            profit: v.profit,
          });
        });
      } else if (type === 'customer') {
        worksheet.columns = [
          { header: 'Customer', key: 'customer', width: 30 },
          { header: 'Type', key: 'type', width: 15 },
          { header: 'Total Rentals', key: 'rentals', width: 15 },
          { header: 'Lifetime Value', key: 'value', width: 20 },
        ];

        report.customer_segmentation.segments.vip.customers.forEach(c => {
          worksheet.addRow({
            customer: c.full_name,
            type: c.customer_type,
            rentals: c.total_rentals,
            value: c.lifetime_value,
          });
        });
      }

      // Style the header row
      worksheet.getRow(1).font = { bold: true };
      worksheet.getRow(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FF4472C4' },
      };
      worksheet.getRow(1).font = { color: { argb: 'FFFFFFFF' }, bold: true };

      // Generate buffer
      const buffer = await workbook.xlsx.writeBuffer();

      // Set response headers
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      res.setHeader('Content-Disposition', `attachment; filename="${type}_report_${Date.now()}.xlsx"`);
      res.send(buffer);
    } catch (error) {
      console.error('ðŸ’¥ Generate Excel report error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to generate Excel report',
        details: error.message,
      });
    }
  },
];

module.exports = {
  generateReport,
  generateReportPDF,
  generateReportExcel,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\vehicle.controller.js
// src/controllers/vehicle.controller.js - COMPLETE FIXED VERSION
const { Vehicle, VehicleCost, Contract } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { Op } = require('sequelize');
const { applyTenantFilter, applyTenantData } = require('../middleware/tenantIsolation.middleware');

// ============================================
// GET /api/vehicles - List all vehicles (with filters)
// ============================================
const getAllVehicles = async (req, res) => {
  try {
    const {
      status,
      brand,
      transmission,
      fuel_type,
      min_rate,
      max_rate,
      search,
      page = 1,
      limit = 10,
      sort_by = 'created_at',
      sort_order = 'DESC',
    } = req.query;

    // Build filter object with tenant isolation
    const whereClause = applyTenantFilter(req);

    // Apply status filter
    if (status) {
      whereClause.status = status;
    }

    // Apply brand filter
    if (brand) {
      whereClause.brand = brand;
    }

    // Apply transmission filter
    if (transmission) {
      whereClause.transmission = transmission;
    }

    // Apply fuel type filter
    if (fuel_type) {
      whereClause.fuel_type = fuel_type;
    }

    // Apply rate range filter
    if (min_rate || max_rate) {
      whereClause.daily_rate = {};
      if (min_rate) whereClause.daily_rate[Op.gte] = parseFloat(min_rate);
      if (max_rate) whereClause.daily_rate[Op.lte] = parseFloat(max_rate);
    }

    // Apply search (brand, model, registration_number)
    if (search) {
      whereClause[Op.or] = [
        { brand: { [Op.iLike]: `%${search}%` } },
        { model: { [Op.iLike]: `%${search}%` } },
        { registration_number: { [Op.iLike]: `%${search}%` } },
      ];
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Fetch vehicles
    const { count, rows: vehicles } = await Vehicle.findAndCountAll({
      where: whereClause,
      limit: parseInt(limit),
      offset: offset,
      order: [[sort_by, sort_order.toUpperCase()]],
    });

    console.log(`ðŸ“‹ Fetched ${vehicles.length} vehicles for company ${req.companyId}`);

    sendSuccess(res, {
      message: 'Vehicles fetched successfully',
      data: { vehicles },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get vehicles error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch vehicles',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/vehicles/available - Get available vehicles
// ============================================
const getAvailableVehicles = async (req, res) => {
  try {
    const { start_date, end_date } = req.query;

    // Build filter for available vehicles
    const whereClause = applyTenantFilter(req, { status: 'available' });

    // If dates provided, check for conflicts with existing contracts
    let vehicles;
    if (start_date && end_date) {
      // Find vehicles that don't have active contracts in the date range
      vehicles = await Vehicle.findAll({
        where: whereClause,
        include: [
          {
            model: Contract,
            as: 'contracts',
            where: {
              status: 'active',
              [Op.or]: [
                {
                  start_date: { [Op.between]: [start_date, end_date] },
                },
                {
                  end_date: { [Op.between]: [start_date, end_date] },
                },
                {
                  [Op.and]: [
                    { start_date: { [Op.lte]: start_date } },
                    { end_date: { [Op.gte]: end_date } },
                  ],
                },
              ],
            },
            required: false, // LEFT JOIN - include vehicles with no conflicts
          },
        ],
      });

      // Filter out vehicles with active contracts in date range
      vehicles = vehicles.filter(v => v.contracts.length === 0);
    } else {
      // Just return vehicles with status 'available'
      vehicles = await Vehicle.findAll({ where: whereClause });
    }

    console.log(`âœ… Found ${vehicles.length} available vehicles`);

    sendSuccess(res, {
      message: 'Available vehicles fetched successfully',
      data: { vehicles },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get available vehicles error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch available vehicles',
      details: error.message,
    });
  }
};

// ============================================
// GET /api/vehicles/:id - Get single vehicle
// ============================================
const getVehicleById = async (req, res) => {
  try {
    const { id } = req.params;

    console.log(`ðŸ” Fetching vehicle with ID: ${id} for company: ${req.companyId}`);

    // First, try to find the vehicle without includes to isolate the issue
    const vehicle = await Vehicle.findOne({
      where: applyTenantFilter(req, { id }),
    });

    if (!vehicle) {
      console.log(`âŒ Vehicle not found: ${id}`);
      return sendError(res, {
        statusCode: 404,
        message: 'Vehicle not found',
        details: `No vehicle found with ID ${id} for your company`,
      });
    }

    // Now fetch with associations
    let vehicleWithDetails;
    try {
      vehicleWithDetails = await Vehicle.findOne({
        where: applyTenantFilter(req, { id }),
        include: [
          {
            model: VehicleCost,
            as: 'costs',
            limit: 10,
            order: [['incurred_date', 'DESC']],
            required: false,
            separate: true, // Fixes ordering issue with included models
          },
        ],
      });
    } catch (includeError) {
      console.error('âš ï¸ Error fetching with includes, returning basic vehicle:', includeError);
      // If includes fail, return the basic vehicle data
      vehicleWithDetails = vehicle;
    }

    console.log(`âœ… Vehicle fetched successfully: ${vehicle.brand} ${vehicle.model} (${vehicle.registration_number})`);

    sendSuccess(res, {
      message: 'Vehicle fetched successfully',
      data: { vehicle: vehicleWithDetails },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get vehicle error:', {
      message: error.message,
      stack: error.stack,
      name: error.name,
    });
    
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch vehicle',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/vehicles - Create vehicle
// ============================================
const createVehicle = [
  // Validators
  body('brand').notEmpty().withMessage('Brand is required'),
  body('model').notEmpty().withMessage('Model is required'),
  body('year').isInt({ min: 1900, max: new Date().getFullYear() + 1 }).withMessage('Valid year required'),
  body('registration_number').notEmpty().withMessage('Registration number is required'),
  body('color').optional().isString(),
  body('transmission').isIn(['manual', 'automatic']).withMessage('Valid transmission required'),
  body('fuel_type').isIn(['petrol', 'diesel', 'electric', 'hybrid']).withMessage('Valid fuel type required'),
  body('seats').isInt({ min: 1, max: 50 }).withMessage('Valid number of seats required'),
  body('daily_rate').isFloat({ min: 0 }).withMessage('Valid daily rate required'),
  body('status').optional().isIn(['available', 'rented', 'maintenance', 'retired']),
  body('mileage').optional().isInt({ min: 0 }),
  body('purchase_price').optional().isFloat({ min: 0 }),
  body('purchase_date').optional().isISO8601(),
  body('vin').optional().isLength({ min: 17, max: 17 }).withMessage('VIN must be 17 characters'),
  // Optional maintenance configuration per vehicle
  body('maintenance_interval_km').optional().isInt({ min: 500 }).withMessage('Maintenance interval must be >= 500km'),
  body('maintenance_alert_threshold').optional().isInt({ min: 10 }).withMessage('Alert threshold must be >= 10km'),
  body('last_maintenance_mileage').optional().isInt({ min: 0 }),
  body('next_maintenance_mileage').optional().isInt({ min: 0 }),
  body('last_maintenance_date').optional().isISO8601(),
  body('next_maintenance_date').optional().isISO8601(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      // Check if registration number already exists
      const existingVehicle = await Vehicle.findOne({
        where: { registration_number: req.body.registration_number },
      });

      if (existingVehicle) {
        return sendError(res, {
          statusCode: 409,
          message: 'Vehicle with this registration number already exists',
        });
      }

      // Apply tenant data (adds company_id automatically)
      const vehicleData = applyTenantData(req, req.body);

      const vehicle = await Vehicle.create(vehicleData);

      console.log(`ðŸš— New vehicle created: ${vehicle.brand} ${vehicle.model} (${vehicle.registration_number})`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Vehicle created successfully',
        data: { vehicle },
      });
    } catch (error) {
      console.error('ðŸ’¥ Create vehicle error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to create vehicle',
        details: error.message,
      });
    }
  },
];

// ============================================
// PUT /api/vehicles/:id - Update vehicle
// ============================================
const updateVehicle = [
  // Validators (all optional for update)
  body('brand').optional().notEmpty().withMessage('Brand cannot be empty'),
  body('model').optional().notEmpty().withMessage('Model cannot be empty'),
  body('year').optional().isInt({ min: 1900, max: new Date().getFullYear() + 1 }),
  body('registration_number').optional().notEmpty(),
  body('transmission').optional().isIn(['manual', 'automatic']),
  body('fuel_type').optional().isIn(['petrol', 'diesel', 'electric', 'hybrid']),
  body('seats').optional().isInt({ min: 1, max: 50 }),
  body('daily_rate').optional().isFloat({ min: 0 }),
  body('status').optional().isIn(['available', 'rented', 'maintenance', 'retired']),
  body('mileage').optional().isInt({ min: 0 }),
  // Optional maintenance fields can be tuned later
  body('maintenance_interval_km').optional().isInt({ min: 500 }),
  body('maintenance_alert_threshold').optional().isInt({ min: 10 }),
  body('last_maintenance_mileage').optional().isInt({ min: 0 }),
  body('next_maintenance_mileage').optional().isInt({ min: 0 }),
  body('last_maintenance_date').optional().isISO8601(),
  body('next_maintenance_date').optional().isISO8601(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id } = req.params;

      // Check if vehicle exists and belongs to company
      const vehicle = await Vehicle.findOne({
        where: applyTenantFilter(req, { id }),
      });

      if (!vehicle) {
        return sendError(res, {
          statusCode: 404,
          message: 'Vehicle not found',
        });
      }

      // If registration number is being updated, check uniqueness
      if (req.body.registration_number && req.body.registration_number !== vehicle.registration_number) {
        const existingVehicle = await Vehicle.findOne({
          where: { registration_number: req.body.registration_number },
        });

        if (existingVehicle) {
          return sendError(res, {
            statusCode: 409,
            message: 'Vehicle with this registration number already exists',
          });
        }
      }

      // Update vehicle
      await vehicle.update(req.body);

      console.log(`ðŸ”„ Vehicle updated: ${vehicle.brand} ${vehicle.model}`);

      sendSuccess(res, {
        message: 'Vehicle updated successfully',
        data: { vehicle },
      });
    } catch (error) {
      console.error('ðŸ’¥ Update vehicle error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to update vehicle',
        details: error.message,
      });
    }
  },
];

// ============================================
// DELETE /api/vehicles/:id - Delete vehicle
// ============================================
const deleteVehicle = async (req, res) => {
  try {
    const { id } = req.params;

    // Check if vehicle exists and belongs to company
    const vehicle = await Vehicle.findOne({
      where: applyTenantFilter(req, { id }),
    });

    if (!vehicle) {
      return sendError(res, {
        statusCode: 404,
        message: 'Vehicle not found',
      });
    }

    // Check if vehicle has active contracts
    const activeContracts = await Contract.count({
      where: {
        vehicle_id: id,
        status: 'active',
      },
    });

    if (activeContracts > 0) {
      return sendError(res, {
        statusCode: 409,
        message: 'Cannot delete vehicle with active contracts',
      });
    }

    // Soft delete: update status to 'retired' instead of hard delete
    await vehicle.update({ status: 'retired' });

    console.log(`ðŸ—‘ï¸ Vehicle retired: ${vehicle.brand} ${vehicle.model}`);

    sendSuccess(res, {
      message: 'Vehicle deleted successfully',
      data: { vehicle },
    });
  } catch (error) {
    console.error('ðŸ’¥ Delete vehicle error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to delete vehicle',
      details: error.message,
    });
  }
};

// ============================================
// POST /api/vehicles/:id/costs - Add vehicle cost
// ============================================
const addVehicleCost = [
  body('cost_type')
    .isIn(['fuel', 'maintenance', 'insurance', 'registration', 'cleaning', 'repair', 'other'])
    .withMessage('Valid cost type required'),
  body('amount').isFloat({ min: 0 }).withMessage('Valid amount required'),
  body('incurred_date').isISO8601().withMessage('Valid date required'),
  body('description').optional().isString(),

  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id: vehicle_id } = req.params;

      // Check if vehicle exists and belongs to company
      const vehicle = await Vehicle.findOne({
        where: applyTenantFilter(req, { id: vehicle_id }),
      });

      if (!vehicle) {
        return sendError(res, {
          statusCode: 404,
          message: 'Vehicle not found',
        });
      }

      // Create cost record
      const cost = await VehicleCost.create({
        vehicle_id,
        created_by: req.user.id,
        ...req.body,
      });

      console.log(`ðŸ’° Cost added to vehicle ${vehicle_id}: ${cost.cost_type} - ${cost.amount}`);

      sendSuccess(res, {
        statusCode: 201,
        message: 'Vehicle cost added successfully',
        data: { cost },
      });
    } catch (error) {
      console.error('ðŸ’¥ Add vehicle cost error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to add vehicle cost',
        details: error.message,
      });
    }
  },
];

// ============================================
// GET /api/vehicles/:id/costs - Get cost history
// ============================================
const getVehicleCosts = async (req, res) => {
  try {
    const { id: vehicle_id } = req.params;
    const { cost_type, start_date, end_date, page = 1, limit = 20 } = req.query;

    // Check if vehicle exists and belongs to company
    const vehicle = await Vehicle.findOne({
      where: applyTenantFilter(req, { id: vehicle_id }),
    });

    if (!vehicle) {
      return sendError(res, {
        statusCode: 404,
        message: 'Vehicle not found',
      });
    }

    // Build filter
    const whereClause = { vehicle_id };

    if (cost_type) {
      whereClause.cost_type = cost_type;
    }

    if (start_date || end_date) {
      whereClause.incurred_date = {};
      if (start_date) whereClause.incurred_date[Op.gte] = start_date;
      if (end_date) whereClause.incurred_date[Op.lte] = end_date;
    }

    // Pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);

    const { count, rows: costs } = await VehicleCost.findAndCountAll({
      where: whereClause,
      limit: parseInt(limit),
      offset: offset,
      order: [['incurred_date', 'DESC']],
    });

    // Calculate total cost
    const totalCost = costs.reduce((sum, cost) => sum + parseFloat(cost.amount), 0);

    console.log(`ðŸ’° Fetched ${costs.length} costs for vehicle ${vehicle_id}`);

    sendSuccess(res, {
      message: 'Vehicle costs fetched successfully',
      data: { 
        costs,
        total_cost: totalCost,
      },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get vehicle costs error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch vehicle costs',
      details: error.message,
    });
  }
};

module.exports = {
  getAllVehicles,
  getAvailableVehicles,
  getVehicleById,
  createVehicle,
  updateVehicle,
  deleteVehicle,
  addVehicleCost,
  getVehicleCosts,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\controllers\vehicleMaintenance.controller.js
// src/controllers/vehicleMaintenance.controller.js
const { Vehicle, VehicleCost, Notification, sequelize } = require('../models');
const { sendSuccess, sendError } = require('../utils/response.util');
const { body, validationResult } = require('express-validator');
const { applyTenantFilter } = require('../middleware/tenantIsolation.middleware');

/**
 * POST /api/vehicles/:id/maintenance/complete
 * Record maintenance completion and update vehicle
 */
const completeMaintenanceService = [
  body('mileage').isInt({ min: 0 }).withMessage('Valid mileage required'),
  body('service_type')
    .isIn(['oil_change', 'full_service', 'tire_change', 'brake_service', 'general_inspection', 'other'])
    .withMessage('Valid service type required'),
  body('cost').isFloat({ min: 0 }).withMessage('Valid cost required'),
  body('description').optional().trim(),
  body('next_service_km').optional().isInt({ min: 0 }),
  body('performed_date').isISO8601().withMessage('Valid date required'),

  async (req, res) => {
    const transaction = await sequelize.transaction();

    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        await transaction.rollback();
        return sendError(res, {
          statusCode: 422,
          message: 'Validation failed',
          details: errors.array(),
        });
      }

      const { id: vehicle_id } = req.params;
      const {
        mileage,
        service_type,
        cost,
        description,
        next_service_km,
        performed_date,
        parts_replaced,
        technician_name,
        service_center,
      } = req.body;

      // Get vehicle
      const vehicle = await Vehicle.findOne({
        where: applyTenantFilter(req, { id: vehicle_id }),
      });

      if (!vehicle) {
        await transaction.rollback();
        return sendError(res, { statusCode: 404, message: 'Vehicle not found' });
      }

      // Record maintenance cost
      const maintenanceCost = await VehicleCost.create(
        {
          vehicle_id: vehicle.id,
          cost_type: 'maintenance',
          amount: cost,
          incurred_date: performed_date,
          description: `${service_type.replace('_', ' ').toUpperCase()}: ${description || 'Maintenance service'}`,
          created_by: req.user.id,
          metadata: {
            service_type,
            parts_replaced,
            technician_name,
            service_center,
            mileage_at_service: mileage,
          },
        },
        { transaction }
      );

      // Update vehicle maintenance tracking
      const updateData = {
        mileage: Math.max(mileage, vehicle.mileage), // Use higher value
        last_maintenance_mileage: mileage,
        last_maintenance_date: performed_date,
        maintenance_count: vehicle.maintenance_count + 1,
        total_maintenance_costs: parseFloat(vehicle.total_maintenance_costs || 0) + parseFloat(cost),
        last_maintenance_alert_mileage: mileage, // Reset alert counter
      };

      // Calculate next maintenance mileage
      if (next_service_km) {
        updateData.next_maintenance_mileage = mileage + next_service_km;
      } else {
        updateData.next_maintenance_mileage = mileage + vehicle.maintenance_interval_km;
      }

      // Update specific service dates
      if (service_type === 'oil_change') {
        updateData.last_oil_change_mileage = mileage;
        updateData.last_oil_change_date = performed_date;
      }

      // If vehicle was in maintenance, return to available
      if (vehicle.status === 'maintenance') {
        updateData.status = 'available';
      }

      await vehicle.update(updateData, { transaction });

      // Create notification
      await Notification.create(
        {
          company_id: vehicle.company_id,
          type: 'vehicle_maintenance',
          priority: 'low',
          title: `Maintenance Completed: ${vehicle.brand} ${vehicle.model}`,
          message: `${service_type.replace('_', ' ')} completed at ${mileage}km. Next service due at ${updateData.next_maintenance_mileage}km.`,
          data: {
            vehicle_id: vehicle.id,
            registration: vehicle.registration_number,
            service_type,
            cost,
            mileage,
            next_maintenance: updateData.next_maintenance_mileage,
          },
          action_url: `/vehicles/${vehicle.id}`,
        },
        { transaction }
      );

      await transaction.commit();

      console.log(`ðŸ”§ Maintenance completed for ${vehicle.registration_number}`);

      sendSuccess(res, {
        message: 'Maintenance service recorded successfully',
        data: {
          vehicle,
          maintenance_cost: maintenanceCost,
        },
      });
    } catch (error) {
      await transaction.rollback();
      console.error('ðŸ’¥ Complete maintenance error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to record maintenance',
        details: error.message,
      });
    }
  },
];

/**
 * GET /api/vehicles/:id/maintenance/history
 * Get maintenance history for a vehicle
 */
const getMaintenanceHistory = async (req, res) => {
  try {
    const { id: vehicle_id } = req.params;
    const { page = 1, limit = 20 } = req.query;

    const vehicle = await Vehicle.findOne({
      where: applyTenantFilter(req, { id: vehicle_id }),
    });

    if (!vehicle) {
      return sendError(res, { statusCode: 404, message: 'Vehicle not found' });
    }

    const offset = (parseInt(page) - 1) * parseInt(limit);

    const { count, rows: maintenanceRecords } = await VehicleCost.findAndCountAll({
      where: {
        vehicle_id,
        cost_type: 'maintenance',
      },
      limit: parseInt(limit),
      offset,
      order: [['incurred_date', 'DESC']],
    });

    // Calculate maintenance statistics
    const stats = {
      total_maintenance_count: vehicle.maintenance_count,
      total_maintenance_costs: parseFloat(vehicle.total_maintenance_costs || 0),
      average_cost_per_service:
        vehicle.maintenance_count > 0
          ? parseFloat(vehicle.total_maintenance_costs) / vehicle.maintenance_count
          : 0,
      last_maintenance_date: vehicle.last_maintenance_date,
      last_maintenance_mileage: vehicle.last_maintenance_mileage,
      next_maintenance_mileage: vehicle.next_maintenance_mileage,
      km_until_next_maintenance: vehicle.next_maintenance_mileage - vehicle.mileage,
      maintenance_interval_km: vehicle.maintenance_interval_km,
    };

    sendSuccess(res, {
      message: 'Maintenance history fetched successfully',
      data: {
        vehicle: {
          id: vehicle.id,
          brand: vehicle.brand,
          model: vehicle.model,
          registration: vehicle.registration_number,
          current_mileage: vehicle.mileage,
        },
        maintenance_records: maintenanceRecords,
        stats,
      },
      meta: {
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit)),
        },
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get maintenance history error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch maintenance history',
      details: error.message,
    });
  }
};

/**
 * GET /api/vehicles/maintenance/due
 * Get all vehicles that need maintenance
 */
const getVehiclesDueMaintenance = async (req, res) => {
  try {
    const companyFilter = applyTenantFilter(req);
    const { status = 'all' } = req.query;

    // Build query based on status
    let whereClause = { ...companyFilter };

    if (status === 'overdue') {
      // Vehicles overdue for maintenance
      whereClause = {
        ...whereClause,
        [sequelize.Op.or]: [
          sequelize.literal('mileage >= next_maintenance_mileage'),
          sequelize.literal('mileage - last_maintenance_mileage >= maintenance_interval_km'),
        ],
      };
    } else if (status === 'upcoming') {
      // Vehicles approaching maintenance (within 500km)
      whereClause = {
        ...whereClause,
        [sequelize.Op.and]: [
          sequelize.literal('mileage < next_maintenance_mileage'),
          sequelize.literal('next_maintenance_mileage - mileage <= 500'),
        ],
      };
    }

    const vehicles = await Vehicle.findAll({
      where: whereClause,
      attributes: [
        'id',
        'brand',
        'model',
        'registration_number',
        'mileage',
        'last_maintenance_mileage',
        'next_maintenance_mileage',
        'last_maintenance_date',
        'maintenance_interval_km',
        'status',
        [
          sequelize.literal('mileage - last_maintenance_mileage'),
          'km_since_last_maintenance',
        ],
        [
          sequelize.literal('next_maintenance_mileage - mileage'),
          'km_until_maintenance',
        ],
      ],
      order: [
        [sequelize.literal('next_maintenance_mileage - mileage'), 'ASC'],
      ],
    });

    // Categorize vehicles
    const categorized = {
      critical_overdue: vehicles.filter(
        (v) => v.mileage - v.last_maintenance_mileage > v.maintenance_interval_km + 1000
      ),
      overdue: vehicles.filter(
        (v) =>
          v.mileage >= v.next_maintenance_mileage &&
          v.mileage - v.last_maintenance_mileage <= v.maintenance_interval_km + 1000
      ),
      upcoming: vehicles.filter(
        (v) => v.mileage < v.next_maintenance_mileage && v.next_maintenance_mileage - v.mileage <= 500
      ),
    };

    sendSuccess(res, {
      message: 'Vehicles maintenance status fetched successfully',
      data: {
        summary: {
          total: vehicles.length,
          critical_overdue: categorized.critical_overdue.length,
          overdue: categorized.overdue.length,
          upcoming: categorized.upcoming.length,
        },
        vehicles: categorized,
      },
    });
  } catch (error) {
    console.error('ðŸ’¥ Get vehicles due maintenance error:', error);
    sendError(res, {
      statusCode: 500,
      message: 'Failed to fetch vehicles due maintenance',
      details: error.message,
    });
  }
};

module.exports = {
  completeMaintenanceService,
  getMaintenanceHistory,
  getVehiclesDueMaintenance,
};


//   [Folder] jobs


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\jobs\analytics.job.js


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\jobs\kmLimitMonitoring.job.js
// src/jobs/kmLimitMonitoring.job.js
const cron = require('node-cron');
const { Contract, Customer, Vehicle, Notification, sequelize } = require('../models');
const { Op } = require('sequelize');
const { sendEmail } = require('../services/email.service');
const { calculateAllowedKm } = require('../services/customerTier.service');

/**
 * Check active contracts for km limit warnings
 */
const checkKmLimitAlerts = async () => {
  try {
    console.log('ðŸ“ Starting KM limit check for active contracts...');

    // Get all active contracts with vehicle and customer
    const activeContracts = await Contract.findAll({
      where: {
        status: 'active',
        start_mileage: { [Op.ne]: null },
      },
      include: [
        {
          model: Vehicle,
          as: 'vehicle',
          attributes: ['id', 'brand', 'model', 'registration_number', 'mileage'],
        },
        {
          model: Customer,
          as: 'customer',
          attributes: ['id', 'full_name', 'email', 'phone', 'total_rentals', 'apply_tier_discount'],
        },
      ],
    });

    console.log(`ðŸ“‹ Checking ${activeContracts.length} active contracts...`);

    let alertsCreated = 0;

    for (const contract of activeContracts) {
      // Calculate current km driven
      const currentVehicleMileage = contract.vehicle.mileage;
      const kmDriven = currentVehicleMileage - contract.start_mileage;

      // Get allowed km with tier bonuses (respect customer apply_tier_discount)
      const applyTier = contract.customer.apply_tier_discount !== false;
      const allowedKmInfo = calculateAllowedKm(
        contract.daily_km_limit || 300,
        contract.total_days,
        contract.customer.total_rentals,
        { applyTierBonus: applyTier }
      );

      const totalAllowed = allowedKmInfo.total_km_allowed;
      const kmRemaining = totalAllowed - kmDriven;
      const percentageUsed = (kmDriven / totalAllowed) * 100;

      // Check thresholds
      if (kmDriven >= totalAllowed) {
        // Already exceeded limit
        await sendLimitExceededAlert(contract, kmDriven - totalAllowed, allowedKmInfo);
        alertsCreated++;
      } else if (percentageUsed >= 90) {
        // 90% of limit used (critical warning)
        await sendCriticalKmWarning(contract, kmRemaining, percentageUsed, allowedKmInfo);
        alertsCreated++;
      } else if (percentageUsed >= 75) {
        // 75% of limit used (warning)
        await sendKmWarning(contract, kmRemaining, percentageUsed, allowedKmInfo);
        alertsCreated++;
      }
    }

    console.log(`âœ… KM limit check completed - ${alertsCreated} alerts created`);
  } catch (error) {
    console.error('âŒ KM limit check error:', error);
  }
};

/**
 * Send warning when 75% of km limit is used
 */
const sendKmWarning = async (contract, kmRemaining, percentageUsed, allowedKmInfo) => {
  // Check if we already sent this alert recently (within 24 hours)
  const recentAlert = await Notification.findOne({
    where: {
      company_id: contract.company_id,
      type: 'km_limit_warning',
      'data.contract_id': contract.id,
      created_at: {
        [Op.gte]: new Date(Date.now() - 24 * 60 * 60 * 1000),
      },
    },
  });

  if (recentAlert) return; // Don't spam

  await Notification.create({
    company_id: contract.company_id,
    type: 'km_limit_warning',
    priority: 'medium',
    title: `âš ï¸ KM Limit Warning: ${contract.contract_number}`,
    message: `Vehicle ${contract.vehicle.brand} ${contract.vehicle.model} has ${kmRemaining}km remaining (${percentageUsed.toFixed(0)}% used). Customer: ${contract.customer.full_name}`,
    data: {
      contract_id: contract.id,
      contract_number: contract.contract_number,
      customer_id: contract.customer_id,
      vehicle_id: contract.vehicle_id,
      km_remaining: kmRemaining,
      percentage_used: percentageUsed,
      total_allowed: allowedKmInfo.total_km_allowed,
      tier: allowedKmInfo.tier_name,
    },
    action_url: `/contracts/${contract.id}`,
  });

  console.log(`âš ï¸ KM warning: ${contract.contract_number} - ${kmRemaining}km remaining`);
};

/**
 * Send critical warning when 90% of km limit is used
 */
const sendCriticalKmWarning = async (contract, kmRemaining, percentageUsed, allowedKmInfo) => {
  const recentAlert = await Notification.findOne({
    where: {
      company_id: contract.company_id,
      type: 'km_limit_critical',
      'data.contract_id': contract.id,
      created_at: {
        [Op.gte]: new Date(Date.now() - 12 * 60 * 60 * 1000), // Last 12 hours
      },
    },
  });

  if (recentAlert) return;

  await Notification.create({
    company_id: contract.company_id,
    type: 'km_limit_critical',
    priority: 'high',
    title: `ðŸš¨ URGENT: KM Limit Almost Reached`,
    message: `Contract ${contract.contract_number}: Only ${kmRemaining}km remaining! Customer ${contract.customer.full_name} should be notified immediately.`,
    data: {
      contract_id: contract.id,
      contract_number: contract.contract_number,
      customer_name: contract.customer.full_name,
      customer_phone: contract.customer.phone,
      vehicle: `${contract.vehicle.brand} ${contract.vehicle.model}`,
      registration: contract.vehicle.registration_number,
      km_remaining: kmRemaining,
      percentage_used: percentageUsed,
      total_allowed: allowedKmInfo.total_km_allowed,
      alert_type: 'critical',
    },
    action_url: `/contracts/${contract.id}`,
  });

  // TODO: Send SMS to customer
  console.log(`ðŸš¨ CRITICAL: ${contract.contract_number} - Only ${kmRemaining}km left!`);
  console.log(`   Contact customer: ${contract.customer.full_name} (${contract.customer.phone})`);
};

/**
 * Send alert when km limit is exceeded
 */
const sendLimitExceededAlert = async (contract, kmOver, allowedKmInfo) => {
  const recentAlert = await Notification.findOne({
    where: {
      company_id: contract.company_id,
      type: 'km_limit_exceeded',
      'data.contract_id': contract.id,
      created_at: {
        [Op.gte]: new Date(Date.now() - 6 * 60 * 60 * 1000), // Last 6 hours
      },
    },
  });

  if (recentAlert) return;

  const currentMileage = contract.vehicle.mileage;
  const kmDriven = currentMileage - contract.start_mileage;

  await Notification.create({
    company_id: contract.company_id,
    type: 'km_limit_exceeded',
    priority: 'critical',
    title: `ðŸ›‘ KM Limit EXCEEDED: ${contract.contract_number}`,
    message: `Customer ${contract.customer.full_name} has exceeded km limit by ${kmOver}km! Current overage charges will apply. Contact customer immediately.`,
    data: {
      contract_id: contract.id,
      contract_number: contract.contract_number,
      customer_name: contract.customer.full_name,
      customer_phone: contract.customer.phone,
      customer_email: contract.customer.email,
      vehicle: `${contract.vehicle.brand} ${contract.vehicle.model}`,
      registration: contract.vehicle.registration_number,
      km_driven: kmDriven,
      km_allowed: allowedKmInfo.total_km_allowed,
      km_exceeded: kmOver,
      overage_rate: contract.overage_rate_per_km,
      estimated_charges: kmOver * parseFloat(contract.overage_rate_per_km || 0),
      alert_type: 'exceeded',
    },
    action_url: `/contracts/${contract.id}`,
  });

  console.log(`ðŸ›‘ LIMIT EXCEEDED: ${contract.contract_number}`);
  console.log(`   Customer: ${contract.customer.full_name}`);
  console.log(`   Over limit by: ${kmOver}km`);
  console.log(`   Estimated overage: ${kmOver * parseFloat(contract.overage_rate_per_km || 0)} DA`);
};

/**
 * Schedule KM limit monitoring
 */
const scheduleKmLimitMonitoring = () => {
  // Run every 4 hours
  cron.schedule('0 */4 * * *', () => {
    console.log('â° Running KM limit check...');
    checkKmLimitAlerts();
  });

  console.log('âœ… KM limit monitoring scheduled (every 4 hours)');
};

module.exports = {
  scheduleKmLimitMonitoring,
  checkKmLimitAlerts, // For manual execution
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\jobs\notifications.job.js


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\jobs\subscriptions.job.js


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\jobs\vehicleLimitMonitoring.job.js
// src/jobs/vehicleLimitMonitoring.job.js
const cron = require('node-cron');
const { Company, Vehicle, sequelize } = require('../models');
const { Op } = require('sequelize');

// Plan limits configuration
const PLAN_LIMITS = {
  basic: {
    max_vehicles: 20,
    warning_threshold: 0.75, // Alert at 75% (15 vehicles)
    critical_threshold: 0.90, // Alert at 90% (18 vehicles)
  },
  professional: {
    max_vehicles: 150,
    warning_threshold: 0.80, // Alert at 80% (120 vehicles)
    critical_threshold: 0.95, // Alert at 95% (142 vehicles)
  },
  enterprise: {
    max_vehicles: 500,
    warning_threshold: 0.85,
    critical_threshold: 0.95,
  },
};

/**
 * Check vehicle limits for all active companies
 */
const checkVehicleLimits = async () => {
  try {
    console.log('ðŸ” Starting vehicle limit check...');

    // Get all active companies
    const companies = await Company.findAll({
      where: {
        subscription_status: 'active',
      },
      attributes: ['id', 'name', 'email', 'subscription_plan'],
    });

    for (const company of companies) {
      const planConfig = PLAN_LIMITS[company.subscription_plan];
      
      if (!planConfig) {
        console.warn(`âš ï¸ Unknown plan: ${company.subscription_plan} for company ${company.name}`);
        continue;
      }

      // Count active vehicles (exclude retired)
      const vehicleCount = await Vehicle.count({
        where: {
          company_id: company.id,
          status: { [Op.ne]: 'retired' },
        },
      });

      const maxVehicles = planConfig.max_vehicles;
      const usagePercentage = (vehicleCount / maxVehicles) * 100;
      const remainingSlots = maxVehicles - vehicleCount;

      console.log(
        `ðŸ“Š ${company.name}: ${vehicleCount}/${maxVehicles} vehicles (${usagePercentage.toFixed(1)}%)`
      );

      // Check thresholds and send notifications
      if (vehicleCount >= maxVehicles) {
        // Limit reached
        await sendLimitReachedNotification(company, vehicleCount, maxVehicles);
      } else if (usagePercentage >= planConfig.critical_threshold * 100) {
        // Critical threshold (e.g., 90-95%)
        await sendCriticalWarningNotification(
          company,
          vehicleCount,
          maxVehicles,
          remainingSlots
        );
      } else if (usagePercentage >= planConfig.warning_threshold * 100) {
        // Warning threshold (e.g., 75-80%)
        await sendWarningNotification(
          company,
          vehicleCount,
          maxVehicles,
          remainingSlots
        );
      }
    }

    console.log('âœ… Vehicle limit check completed');
  } catch (error) {
    console.error('âŒ Vehicle limit check error:', error);
  }
};

/**
 * Send warning notification (75-80% usage)
 */
const sendWarningNotification = async (company, current, max, remaining) => {
  const message = `
    Your fleet is growing! You currently have ${current} out of ${max} vehicles on your ${company.subscription_plan} plan.
    
    You have ${remaining} vehicle slots remaining. Consider upgrading to ensure uninterrupted service.
  `;

  console.log(`âš ï¸ WARNING: ${company.name} - ${current}/${max} vehicles`);

  // TODO: Send email notification
  await sendEmail({
    to: company.email,
    subject: 'Fleet Capacity Notification - Action Recommended',
    message: message,
    type: 'warning',
  });

  // TODO: Create in-app notification
  await createNotification({
    company_id: company.id,
    type: 'vehicle_limit_warning',
    priority: 'medium',
    title: 'Fleet Capacity Warning',
    message: `You have ${remaining} vehicle slots remaining on your ${company.subscription_plan} plan.`,
    data: { current, max, remaining },
  });
};

/**
 * Send critical warning (90-95% usage)
 */
const sendCriticalWarningNotification = async (company, current, max, remaining) => {
  const message = `
    âš ï¸ URGENT: Your fleet is almost at capacity!
    
    Current vehicles: ${current}/${max} (${remaining} slots remaining)
    Plan: ${company.subscription_plan.toUpperCase()}
    
    To avoid service disruption, please upgrade your plan immediately.
    Upgrade now to unlock more capacity and premium features.
  `;

  console.log(`ðŸš¨ CRITICAL: ${company.name} - ${current}/${max} vehicles`);

  await sendEmail({
    to: company.email,
    subject: 'ðŸš¨ URGENT: Fleet Capacity Almost Reached',
    message: message,
    type: 'critical',
  });

  await createNotification({
    company_id: company.id,
    type: 'vehicle_limit_critical',
    priority: 'high',
    title: 'URGENT: Fleet Almost Full',
    message: `Only ${remaining} vehicle slots left! Upgrade to avoid disruption.`,
    data: { current, max, remaining },
  });
};

/**
 * Send limit reached notification
 */
const sendLimitReachedNotification = async (company, current, max) => {
  const message = `
    ðŸ›‘ FLEET LIMIT REACHED
    
    You have reached your maximum vehicle capacity of ${max} vehicles on the ${company.subscription_plan} plan.
    
    To add more vehicles, please upgrade your subscription plan immediately.
    
    Upgrade benefits:
    - Professional Plan: Up to 150 vehicles
    - Enterprise Plan: Up to 500 vehicles + priority support
    
    Contact us or upgrade through your dashboard.
  `;

  console.log(`ðŸ›‘ LIMIT REACHED: ${company.name} - ${current}/${max} vehicles`);

  await sendEmail({
    to: company.email,
    subject: 'ðŸ›‘ Fleet Limit Reached - Upgrade Required',
    message: message,
    type: 'limit_reached',
  });

  await createNotification({
    company_id: company.id,
    type: 'vehicle_limit_reached',
    priority: 'critical',
    title: 'Fleet Limit Reached',
    message: `You've reached the maximum of ${max} vehicles. Upgrade to add more.`,
    data: { current, max },
  });
};

/**
 * Mock email service (replace with actual implementation)
 */
const sendEmail = async ({ to, subject, message, type }) => {
  // TODO: Integrate with actual email service (Nodemailer, SendGrid, etc.)
  console.log(`ðŸ“§ Email sent to ${to}: ${subject}`);
  console.log(`   Type: ${type}`);
  console.log(`   Message: ${message.trim()}`);
};

/**
 * Mock notification service (replace with actual implementation)
 */
const createNotification = async (notificationData) => {
  try {
    const { Notification } = require('../models');
    await Notification.create(notificationData);
    console.log(`ðŸ”” Notification created:`, notificationData.title);
  } catch (error) {
    console.error('Failed to create notification:', error.message);
  }
};

/**
 * Schedule the cron job
 * Runs daily at 9 AM
 */
const scheduleVehicleLimitCheck = () => {
  // Run every day at 9:00 AM
  cron.schedule('0 9 * * *', () => {
    console.log('â° Running scheduled vehicle limit check...');
    checkVehicleLimits();
  });

  console.log('âœ… Vehicle limit monitoring cron job scheduled (daily at 9 AM)');
};

// Export for manual testing
module.exports = {
  scheduleVehicleLimitCheck,
  checkVehicleLimits, // For manual execution
  PLAN_LIMITS, // For reference
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\jobs\vehicleMaintenanceMonitoring.job.js
// src/jobs/vehicleMaintenanceMonitoring.job.js
const cron = require('node-cron');
const { Vehicle, Company, Notification, sequelize } = require('../models'); // FIXED: Import Company from models (not './Company')
const { Op } = require('sequelize');
const { sendEmail } = require('../services/email.service');

/**
 * Check all vehicles for maintenance alerts based on mileage
 */
const checkMaintenanceAlerts = async () => {
  try {
    console.log('ðŸ”§ Starting vehicle maintenance check...');
    // Get all active vehicles that need checking
    const vehicles = await Vehicle.findAll({
      where: {
        status: { [Op.in]: ['available', 'rented'] },
      },
      include: [
        {
          model: Company, // FIXED: Use imported Company (no require('./Company'))
          as: 'company',
          attributes: ['id', 'name', 'email'],
        },
      ],
    });
    let alertsCreated = 0;
    for (const vehicle of vehicles) {
      const currentMileage = vehicle.mileage;
      const lastAlertMileage = vehicle.last_maintenance_alert_mileage || 0;
      const alertThreshold = vehicle.maintenance_alert_threshold || 100;
     
      // Calculate km since last alert
      const kmSinceLastAlert = currentMileage - lastAlertMileage;
      // Check if we've passed the alert threshold (e.g., every 100km)
      if (kmSinceLastAlert >= alertThreshold) {
        console.log(
          `ðŸ”” Alert: ${vehicle.brand} ${vehicle.model} (${vehicle.registration_number}) - ${kmSinceLastAlert}km since last alert`
        );
        await sendMileageAlert(vehicle, kmSinceLastAlert);
       
        // Update last alert mileage
        await vehicle.update({
          last_maintenance_alert_mileage: currentMileage,
        });
        alertsCreated++;
      }
      // Check if maintenance is due (every 5000km by default)
      const kmSinceLastMaintenance = currentMileage - vehicle.last_maintenance_mileage;
      const maintenanceInterval = vehicle.maintenance_interval_km || 5000;
     
      if (kmSinceLastMaintenance >= maintenanceInterval) {
        console.log(
          `âš ï¸ MAINTENANCE DUE: ${vehicle.brand} ${vehicle.model} - ${kmSinceLastMaintenance}km since last service`
        );
        await sendMaintenanceDueAlert(vehicle, kmSinceLastMaintenance);
        alertsCreated++;
      }
      // Check if approaching maintenance (within 500km)
      const kmUntilMaintenance = maintenanceInterval - kmSinceLastMaintenance;
      if (kmUntilMaintenance > 0 && kmUntilMaintenance <= 500) {
        console.log(
          `ðŸ“‹ Maintenance approaching: ${vehicle.brand} ${vehicle.model} - ${kmUntilMaintenance}km remaining`
        );
        await sendMaintenanceApproachingAlert(vehicle, kmUntilMaintenance);
      }
    }
    console.log(`âœ… Maintenance check completed - ${alertsCreated} alerts created`);
   
  } catch (error) {
    console.error('âŒ Maintenance check error:', error);
  }
};

/**
 * Send mileage milestone alert (every 100km)
 */
const sendMileageAlert = async (vehicle, kmTraveled) => {
  const message = `
    Vehicle ${vehicle.brand} ${vehicle.model} (${vehicle.registration_number}) has traveled ${kmTraveled}km since last check.
   
    Current mileage: ${vehicle.mileage}km
    Last maintenance: ${vehicle.last_maintenance_mileage}km
    Next maintenance due at: ${vehicle.next_maintenance_mileage}km
   
    Please review the vehicle condition and schedule maintenance if needed.
  `;
  // Create in-app notification
  await Notification.create({
    company_id: vehicle.company_id,
    type: 'vehicle_maintenance',
    priority: 'low',
    title: `Mileage Update: ${vehicle.brand} ${vehicle.model}`,
    message: `${kmTraveled}km traveled. Current: ${vehicle.mileage}km`,
    data: {
      vehicle_id: vehicle.id,
      registration: vehicle.registration_number,
      current_mileage: vehicle.mileage,
      km_traveled: kmTraveled,
    },
    action_url: `/vehicles/${vehicle.id}`,
  });
  console.log(`ðŸ“§ Mileage alert created for ${vehicle.registration_number}`);
};

/**
 * Send maintenance due alert (every 5000km or configured interval)
 */
const sendMaintenanceDueAlert = async (vehicle, kmOverdue) => {
  const message = `
    âš ï¸ MAINTENANCE DUE
   
    Vehicle: ${vehicle.brand} ${vehicle.model} (${vehicle.registration_number})
    Current mileage: ${vehicle.mileage}km
    Last maintenance: ${vehicle.last_maintenance_mileage}km
    Km since last maintenance: ${kmOverdue}km
   
    IMMEDIATE ACTION REQUIRED:
    This vehicle is due for maintenance service. Please schedule service as soon as possible to:
    - Perform oil change
    - Check filters
    - Inspect brakes and tires
    - General vehicle inspection
   
    Delaying maintenance may result in:
    - Increased repair costs
    - Vehicle breakdown
    - Safety issues
    - Reduced vehicle lifespan
  `;
  // Create high-priority notification
  await Notification.create({
    company_id: vehicle.company_id,
    type: 'vehicle_maintenance',
    priority: 'high',
    title: `âš ï¸ Maintenance Due: ${vehicle.brand} ${vehicle.model}`,
    message: `${kmOverdue}km since last service. Immediate maintenance required.`,
    data: {
      vehicle_id: vehicle.id,
      registration: vehicle.registration_number,
      current_mileage: vehicle.mileage,
      last_maintenance: vehicle.last_maintenance_mileage,
      km_overdue: kmOverdue,
      maintenance_type: 'regular_service',
    },
    action_url: `/vehicles/${vehicle.id}/maintenance`,
  });
  // Send email to company
  if (vehicle.company && vehicle.company.email) {
    await sendEmail({
      templateType: 'maintenance_due',
      to: vehicle.company.email,
      data: {
        companyName: vehicle.company.name,
        vehicleBrand: vehicle.brand,
        vehicleModel: vehicle.model,
        registration: vehicle.registration_number,
        currentMileage: vehicle.mileage,
        kmOverdue: kmOverdue,
        vehicleUrl: `${process.env.FRONTEND_URL}/vehicles/${vehicle.id}`,
      },
    });
  }
  console.log(`ðŸš¨ Maintenance due alert sent for ${vehicle.registration_number}`);
};

/**
 * Send maintenance approaching alert (within 500km)
 */
const sendMaintenanceApproachingAlert = async (vehicle, kmRemaining) => {
  const nextMaintenanceMileage = vehicle.next_maintenance_mileage ||
    (vehicle.last_maintenance_mileage + vehicle.maintenance_interval_km);
  // Only send if we haven't sent this alert recently
  const recentAlert = await Notification.findOne({
    where: {
      company_id: vehicle.company_id,
      type: 'vehicle_maintenance',
      'data.vehicle_id': vehicle.id,
      'data.alert_type': 'approaching',
      created_at: {
        [Op.gte]: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // Last 7 days
      },
    },
  });
  if (recentAlert) {
    return; // Don't spam with approaching alerts
  }
  await Notification.create({
    company_id: vehicle.company_id,
    type: 'vehicle_maintenance',
    priority: 'medium',
    title: `ðŸ“‹ Maintenance Approaching: ${vehicle.brand} ${vehicle.model}`,
    message: `${kmRemaining}km until maintenance is due. Schedule service soon.`,
    data: {
      vehicle_id: vehicle.id,
      registration: vehicle.registration_number,
      current_mileage: vehicle.mileage,
      next_maintenance: nextMaintenanceMileage,
      km_remaining: kmRemaining,
      alert_type: 'approaching',
    },
    action_url: `/vehicles/${vehicle.id}/maintenance`,
  });
  console.log(`ðŸ“‹ Maintenance approaching alert for ${vehicle.registration_number}`);
};

/**
 * Check for overdue maintenance (vehicles that should be in maintenance status)
 */
const checkOverdueMaintenance = async () => {
  try {
    console.log('ðŸ” Checking for overdue maintenance...');
    // Find vehicles that are overdue but not in maintenance status
    const overdueVehicles = await Vehicle.findAll({
      where: {
        status: { [Op.in]: ['available', 'rented'] },
        [Op.or]: [
          // Mileage-based overdue (more than 1000km overdue)
          sequelize.literal(`mileage - last_maintenance_mileage > maintenance_interval_km + 1000`),
          // Date-based overdue (next maintenance date passed by more than 30 days)
          {
            next_maintenance_date: {
              [Op.lt]: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
            },
          },
        ],
      },
      include: [
        {
          model: Company, // FIXED: Use imported Company
          as: 'company',
          attributes: ['id', 'name', 'email'],
        },
      ],
    });
    for (const vehicle of overdueVehicles) {
      const kmOverdue = vehicle.mileage - vehicle.last_maintenance_mileage - vehicle.maintenance_interval_km;
     
      console.log(
        `ðŸš¨ CRITICAL: ${vehicle.registration_number} is ${kmOverdue}km overdue for maintenance!`
      );
      await Notification.create({
        company_id: vehicle.company_id,
        type: 'vehicle_maintenance',
        priority: 'critical',
        title: `ðŸš¨ CRITICAL: Maintenance Overdue`,
        message: `${vehicle.brand} ${vehicle.model} is ${kmOverdue}km overdue. Take vehicle off service immediately.`,
        data: {
          vehicle_id: vehicle.id,
          registration: vehicle.registration_number,
          km_overdue: kmOverdue,
          alert_type: 'critical_overdue',
        },
        action_url: `/vehicles/${vehicle.id}`,
      });
    }
    console.log(`âœ… Found ${overdueVehicles.length} critically overdue vehicles`);
   
  } catch (error) {
    console.error('âŒ Overdue maintenance check error:', error);
  }
};

/**
 * Schedule maintenance monitoring jobs
 */
const scheduleMaintenanceMonitoring = () => {
  // Run mileage checks every 6 hours
  cron.schedule('0 */6 * * *', () => {
    console.log('â° Running maintenance alert check...');
    checkMaintenanceAlerts();
  });
  // Run overdue check daily at 8 AM
  cron.schedule('0 8 * * *', () => {
    console.log('â° Running overdue maintenance check...');
    checkOverdueMaintenance();
  });
  console.log('âœ… Maintenance monitoring cron jobs scheduled');
  console.log(' - Maintenance alerts: Every 6 hours');
  console.log(' - Overdue check: Daily at 8 AM');
};

module.exports = {
  scheduleMaintenanceMonitoring,
  checkMaintenanceAlerts,
  checkOverdueMaintenance,
};


//   [Folder] middleware


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\middleware\auth.middleware.js
// src/middleware/auth.middleware.js
const { verifyAccessToken } = require('../utils/jwt.util');
const { sendError } = require('../utils/response.util');

/**
 * Middleware to authenticate JWT access token
 * Expects: Authorization header as 'Bearer <token>'
 * Sets: req.user = { id, email, role, company_id }
 * Throws: 401 error if invalid/missing
 */
const authenticateToken = (req, res, next) => {
  try {
    // Extract token from Authorization header
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
      return sendError(res, {
        statusCode: 401,
        message: 'Access token required',
        code: 'NO_TOKEN',
      });
    }

    // Verify token
    const decoded = verifyAccessToken(token);
    req.user = decoded; // Attach to req for downstream use
    next();
  } catch (error) {
    return sendError(res, {
      statusCode: 401,
      message: error.message || 'Invalid token',
      code: 'INVALID_TOKEN',
    });
  }
};

/**
 * Optional: Middleware for optional auth (e.g., public routes with user info if logged in)
 */
const authenticateTokenOptional = (req, res, next) => {
  try {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token) {
      const decoded = verifyAccessToken(token);
      req.user = decoded;
    }
    // If no token, req.user remains undefined
    next();
  } catch (error) {
    // Silently ignore invalid tokens; treat as unauthenticated
    next();
  }
};

module.exports = {
  authenticateToken,
  authenticateTokenOptional,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\middleware\error.middleware.js
// src/middleware/error.middleware.js
export const errorHandler = (err, req, res, next) => {
  console.error(err.stack);
  res.status(err.status || 500).json({
    success: false,
    message: err.message || 'Internal Server Error',
  });
};


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\middleware\logging.middleware.js


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\middleware\permissions.middleware.js
// src/middleware/permissions.middleware.js
const { sendError } = require('../utils/response.util');

/**
 * Middleware factory: Check if user has required role(s)
 * Usage: permissionsMiddleware('admin') or permissionsMiddleware(['admin', 'owner'])
 * Assumes: req.user from auth.middleware.js
 * Throws: 403 if unauthorized
 */
const requireRole = (allowedRoles) => {
  return (req, res, next) => {
    if (!req.user) {
      return sendError(res, {
        statusCode: 401,
        message: 'Authentication required',
        code: 'UNAUTHENTICATED',
      });
    }

    const userRole = req.user.role;
    const rolesArray = Array.isArray(allowedRoles) ? allowedRoles : [allowedRoles];

    if (!rolesArray.includes(userRole)) {
      return sendError(res, {
        statusCode: 403,
        message: `Insufficient permissions. Required: ${rolesArray.join(', ')}`,
        code: 'FORBIDDEN',
      });
    }

    // Optional: Attach allowed roles to req for logging/auditing
    req.allowedRoles = rolesArray;
    next();
  };
};

/**
 * Higher-order: Combine auth + permissions (e.g., requireRole('owner'))
 * Usage: requireAuthAndRole('owner')
 */
const requireAuthAndRole = (allowedRoles) => {
  const auth = require('../middleware/auth.middleware').authenticateToken;
  const perm = requireRole(allowedRoles);
  return [auth, perm];
};

module.exports = {
  requireRole,
  requireAuthAndRole,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\middleware\rbac.middleware.js
// src/middleware/rbac.middleware.js (FIXED - Stable Employee Lookup)
const { Employee } = require('../models');
const { sendError } = require('../utils/response.util');
const { ROLES, hasPermission } = require('../controllers/employee.controller');

/**
 * RBAC Middleware - Permission-based access control
 */

// Define all possible permissions
const PERMISSIONS = {
  VIEW_DASHBOARD: 'view_dashboard',
  VIEW_ANALYTICS: 'view_analytics',
  CREATE_EMPLOYEES: 'create_employees',
  UPDATE_EMPLOYEES: 'update_employees',
  DELETE_EMPLOYEES: 'delete_employees',
  VIEW_EMPLOYEES: 'view_employees',
  CREATE_VEHICLES: 'create_vehicles',
  UPDATE_VEHICLES: 'update_vehicles',
  DELETE_VEHICLES: 'delete_vehicles',
  VIEW_VEHICLES: 'view_vehicles',
  ADD_VEHICLE_COSTS: 'add_vehicle_costs',
  VIEW_VEHICLE_COSTS: 'view_vehicle_costs',
  CREATE_CUSTOMERS: 'create_customers',
  UPDATE_CUSTOMERS: 'update_customers',
  DELETE_CUSTOMERS: 'delete_customers',
  VIEW_CUSTOMERS: 'view_customers',
  CREATE_CONTRACTS: 'create_contracts',
  UPDATE_CONTRACTS: 'update_contracts',
  COMPLETE_CONTRACTS: 'complete_contracts',
  CANCEL_CONTRACTS: 'cancel_contracts',
  VIEW_CONTRACTS: 'view_contracts',
  CREATE_PAYMENTS: 'create_payments',
  UPDATE_PAYMENTS: 'update_payments',
  VIEW_PAYMENTS: 'view_payments',
  MANAGE_SETTINGS: 'manage_settings',
  MANAGE_BILLING: 'manage_billing',
  CREATE_ATTENDANCE: 'create_attendance',
  VIEW_ATTENDANCE: 'view_attendance',
  MANAGE_PAYROLL: 'manage_payroll',
  VIEW_PAYROLL: 'view_payroll',
  APPROVE_PAYROLL: 'approve_payroll',
};

/**
 * Fallback: Check permission using role only (no DB)
 */
const hasRoleOnlyPermission = (userRole, requiredPermission) => {
  const rolePerms = ROLES[userRole]?.permissions || [];
  if (rolePerms.includes('*')) return true;
  return rolePerms.includes(requiredPermission);
};

/**
 * âœ… FIXED: Middleware factory for permission checking
 */
const requirePermission = (requiredPermission) => {
  return async (req, res, next) => {
    try {
      if (!req.user) {
        return sendError(res, {
          statusCode: 401,
          message: 'Authentication required',
          code: 'UNAUTHENTICATED',
        });
      }

      // Owner always passes
      if (req.user.role === 'owner') {
        console.log(`âœ… Owner ${req.user.email} auto-granted ${requiredPermission}`);
        return next();
      }

      // âœ… CRITICAL FIX: Try fetching employee with EXACT user_id match
      let employee = null;
      try {
        employee = await Employee.findOne({
          where: {
            user_id: req.user.id, // âœ… Must match JWT user.id exactly
            company_id: req.companyId,
            status: 'active',
          },
        });

        console.log(
          `ðŸ” RBAC - User: ${req.user.email}, UserID: ${req.user.id}, CompanyID: ${req.companyId}, Found Employee: ${
            employee ? `${employee.id} (${employee.role})` : 'NULL'
          }`
        );

        if (!employee) {
          console.warn(
            `âš ï¸ No employee found for user_id=${req.user.id}, company_id=${req.companyId}. Using fallback role check.`
          );
        }
      } catch (fetchErr) {
        console.error(`âŒ Employee fetch error for ${req.user.email}:`, fetchErr.message);
      }

      let hasPerm = false;

      if (employee) {
        // âœ… Use full permission check with custom permissions
        hasPerm = hasPermission(employee, requiredPermission);
        console.log(
          `ðŸ” Full Perm Check - Employee ${employee.full_name} (${employee.role}) has '${requiredPermission}': ${hasPerm}`
        );
      } else {
        // âœ… Fallback to role-only check from JWT
        hasPerm = hasRoleOnlyPermission(req.user.role, requiredPermission);
        console.log(
          `ðŸ”„ Fallback Role Check - ${req.user.role} has '${requiredPermission}': ${hasPerm}`
        );
      }

      if (hasPerm) {
        if (employee) req.employee = employee; // Attach employee if found
        return next();
      }

      console.warn(
        `ðŸš« Permission denied: ${req.user.email} (${req.user.role}) lacks ${requiredPermission}${
          !employee ? ' (no employee record, used fallback)' : ''
        }`
      );

      return sendError(res, {
        statusCode: 403,
        message: `Insufficient permissions. Required: ${requiredPermission}`,
        code: 'FORBIDDEN',
      });
    } catch (error) {
      console.error('ðŸ’¥ Permission check error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to verify permissions',
        details: error.message,
      });
    }
  };
};

/**
 * Middleware: Check if user has ANY of the given permissions
 */
const requireAnyPermission = (permissions) => {
  return async (req, res, next) => {
    try {
      if (!req.user) {
        return sendError(res, {
          statusCode: 401,
          message: 'Authentication required',
          code: 'UNAUTHENTICATED',
        });
      }

      if (req.user.role === 'owner') {
        return next();
      }

      let employee = null;
      try {
        employee = await Employee.findOne({
          where: {
            user_id: req.user.id,
            company_id: req.companyId,
            status: 'active',
          },
        });

        console.log(
          `ðŸ” RBAC (ANY) - User: ${req.user.email}, UserID: ${req.user.id}, Found: ${
            employee ? `${employee.id} (${employee.role})` : 'NULL'
          }`
        );
      } catch (fetchErr) {
        console.warn(`âš ï¸ Employee fetch error:`, fetchErr.message);
      }

      let hasAny = false;

      if (employee) {
        hasAny = permissions.some((perm) => {
          const hasPerm = hasPermission(employee, perm);
          console.log(`ðŸ” Perm Check (ANY) - ${employee.full_name} has '${perm}': ${hasPerm}`);
          return hasPerm;
        });
      } else {
        hasAny = permissions.some((perm) => hasRoleOnlyPermission(req.user.role, perm));
        console.log(`ðŸ”„ Fallback (ANY) - ${req.user.role} => ${hasAny} for [${permissions.join(', ')}]`);
      }

      if (hasAny) {
        if (employee) req.employee = employee;
        return next();
      }

      return sendError(res, {
        statusCode: 403,
        message: `Insufficient permissions. Required one of: ${permissions.join(', ')}`,
        code: 'FORBIDDEN',
      });
    } catch (error) {
      console.error('ðŸ’¥ Any permission check error:', error);
      sendError(res, {
        statusCode: 500,
        message: 'Failed to verify permissions',
        details: error.message,
      });
    }
  };
};

/**
 * Middleware: Inject employee permissions into request
 */
const injectPermissions = async (req, res, next) => {
  try {
    if (!req.user) {
      return next();
    }

    if (req.user.role === 'owner') {
      req.permissions = Object.values(PERMISSIONS);
      return next();
    }

    const employee = await Employee.findOne({
      where: {
        user_id: req.user.id,
        company_id: req.companyId,
        status: 'active',
      },
    });

    if (employee) {
      const rolePermissions = ROLES[employee.role]?.permissions || [];
      const customPermissions = Object.keys(employee.custom_permissions || {}).filter(
        (key) => employee.custom_permissions[key] === true
      );

      req.permissions = [...new Set([...rolePermissions, ...customPermissions])];
      req.employee = employee;
    }

    next();
  } catch (error) {
    console.error('ðŸ’¥ Inject permissions error:', error);
    next();
  }
};

module.exports = {
  requirePermission,
  requireAnyPermission,
  injectPermissions,
  PERMISSIONS,
  ROLES,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\middleware\tenantIsolation.middleware.js
// src/middleware/tenantIsolation.middleware.js
/**
 * Tenant Isolation Middleware
 * Ensures all database queries are scoped to the authenticated user's company
 * This middleware MUST be used after authenticate.middleware.js
 */

const { sendError } = require('../utils/response.util');

/**
 * Injects company_id from JWT into req for easy access
 * Usage: Apply this after authenticate middleware on all protected routes
 */
const injectCompanyId = (req, res, next) => {
  try {
    // req.user comes from authenticate.middleware.js
    if (!req.user || !req.user.company_id) {
      console.error('ðŸš« Tenant isolation failed: No company_id in token');
      return sendError(res, { 
        statusCode: 403, 
        message: 'Access denied: Invalid company context' 
      });
    }

    // Make company_id easily accessible throughout the request
    req.companyId = req.user.company_id;
    
    console.log(`ðŸ¢ Tenant context set: company_id=${req.companyId}, user_id=${req.user.id}`);
    next();
  } catch (error) {
    console.error('ðŸ’¥ Tenant injection error:', error);
    sendError(res, { 
      statusCode: 500, 
      message: 'Failed to set tenant context', 
      details: error.message 
    });
  }
};

/**
 * Validates that a resource belongs to the user's company
 * Usage: validateTenantOwnership('company_id') or validateTenantOwnership('companyId')
 * 
 * @param {string} fieldName - The field name in the resource to check (default: 'company_id')
 * @returns {Function} Express middleware
 */
const validateTenantOwnership = (fieldName = 'company_id') => {
  return (req, res, next) => {
    try {
      const resourceCompanyId = req.body[fieldName] || req.params[fieldName] || req.query[fieldName];
      
      if (!resourceCompanyId) {
        // If no company_id in request, that's OK - it will be injected
        return next();
      }

      // If company_id is provided, it MUST match the authenticated user's company
      if (resourceCompanyId !== req.user.company_id) {
        console.warn(`ðŸš« Tenant violation attempt: user=${req.user.id} tried to access company=${resourceCompanyId}`);
        return sendError(res, { 
          statusCode: 403, 
          message: 'Access denied: Cannot access resources from another company' 
        });
      }

      next();
    } catch (error) {
      console.error('ðŸ’¥ Tenant validation error:', error);
      sendError(res, { 
        statusCode: 500, 
        message: 'Failed to validate tenant ownership', 
        details: error.message 
      });
    }
  };
};

/**
 * Automatically adds company_id to query parameters for Sequelize
 * Usage: Use in controllers before database queries
 * 
 * Example:
 *   const whereClause = applyTenantFilter(req, { status: 'active' });
 *   // Returns: { company_id: 'xxx', status: 'active' }
 */
const applyTenantFilter = (req, additionalFilters = {}) => {
  if (!req.companyId) {
    throw new Error('Tenant context not set - apply injectCompanyId middleware first');
  }
  
  return {
    company_id: req.companyId,
    ...additionalFilters,
  };
};

/**
 * Helper to ensure created resources have company_id
 * Usage: Use in controllers before create operations
 * 
 * Example:
 *   const data = applyTenantData(req, req.body);
 *   await Vehicle.create(data);
 */
const applyTenantData = (req, data = {}) => {
  if (!req.companyId) {
    throw new Error('Tenant context not set - apply injectCompanyId middleware first');
  }
  
  return {
    ...data,
    company_id: req.companyId,
  };
};

/**
 * Middleware to prevent cross-tenant data leaks in bulk operations
 * Validates that all items in req.body.items have matching company_id
 */
const validateBulkTenantOwnership = (req, res, next) => {
  try {
    const items = req.body.items || req.body;
    
    if (!Array.isArray(items)) {
      return next(); // Not a bulk operation
    }

    const invalidItems = items.filter(item => 
      item.company_id && item.company_id !== req.user.company_id
    );

    if (invalidItems.length > 0) {
      console.warn(`ðŸš« Bulk tenant violation: ${invalidItems.length} items don't match company_id`);
      return sendError(res, { 
        statusCode: 403, 
        message: 'Access denied: Cannot perform bulk operations across companies' 
      });
    }

    next();
  } catch (error) {
    console.error('ðŸ’¥ Bulk tenant validation error:', error);
    sendError(res, { 
      statusCode: 500, 
      message: 'Failed to validate bulk tenant ownership', 
      details: error.message 
    });
  }
};

module.exports = {
  injectCompanyId,
  validateTenantOwnership,
  applyTenantFilter,
  applyTenantData,
  validateBulkTenantOwnership,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\middleware\validation.middleware.js
// src/middleware/validation.middleware.js
const { body, param, query, validationResult } = require('express-validator');
const { sendError } = require('../utils/response.util');

/**
 * Middleware to check validation results
 * Use this after validation chains in routes
 */
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return sendError(res, {
      statusCode: 422,
      message: 'Validation failed',
      code: 'VALIDATION_ERROR',
      details: errors.array(),
    });
  }
  next();
};

/**
 * Common validation chains for reuse
 */
const validations = {
  // UUID validation
  uuid: (field = 'id') => 
    param(field).isUUID().withMessage(`${field} must be a valid UUID`),

  // Pagination
  pagination: [
    query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
    query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'),
  ],

  // Date range
  dateRange: [
    query('start_date').optional().isISO8601().withMessage('Valid start date required (ISO 8601)'),
    query('end_date').optional().isISO8601().withMessage('Valid end date required (ISO 8601)'),
  ],

  // Vehicle fields
  vehicle: {
    brand: body('brand').notEmpty().withMessage('Brand is required').trim(),
    model: body('model').notEmpty().withMessage('Model is required').trim(),
    year: body('year')
      .isInt({ min: 1900, max: new Date().getFullYear() + 1 })
      .withMessage('Valid year required'),
    registration: body('registration_number')
      .notEmpty()
      .withMessage('Registration number is required')
      .trim(),
    transmission: body('transmission')
      .isIn(['manual', 'automatic'])
      .withMessage('Transmission must be manual or automatic'),
    fuel_type: body('fuel_type')
      .isIn(['petrol', 'diesel', 'electric', 'hybrid'])
      .withMessage('Valid fuel type required'),
    seats: body('seats')
      .isInt({ min: 1, max: 50 })
      .withMessage('Seats must be between 1 and 50'),
    daily_rate: body('daily_rate')
      .isFloat({ min: 0 })
      .withMessage('Daily rate must be a positive number'),
    status: body('status')
      .optional()
      .isIn(['available', 'rented', 'maintenance', 'retired'])
      .withMessage('Invalid status'),
  },

  // Customer fields
  customer: {
    full_name: body('full_name').notEmpty().withMessage('Full name is required').trim(),
    email: body('email')
      .optional()
      .isEmail()
      .withMessage('Valid email required')
      .normalizeEmail(),
    phone: body('phone')
      .notEmpty()
      .withMessage('Phone is required')
      .matches(/^[+]?[0-9\s-()]+$/)
      .withMessage('Valid phone number required'),
    customer_type: body('customer_type')
      .isIn(['individual', 'corporate'])
      .withMessage('Customer type must be individual or corporate'),
    license: body('drivers_license_number')
      .optional()
      .trim()
      .isLength({ min: 5, max: 50 })
      .withMessage('License number must be 5-50 characters'),
  },

  // Contract fields
  contract: {
    customer_id: body('customer_id').isUUID().withMessage('Valid customer ID required'),
    vehicle_id: body('vehicle_id').isUUID().withMessage('Valid vehicle ID required'),
    start_date: body('start_date').isISO8601().withMessage('Valid start date required'),
    end_date: body('end_date').isISO8601().withMessage('Valid end date required'),
    daily_rate: body('daily_rate')
      .isFloat({ min: 0 })
      .withMessage('Daily rate must be positive'),
  },

  // Payment fields
  payment: {
    amount: body('amount').isFloat({ min: 0 }).withMessage('Amount must be positive'),
    payment_method: body('payment_method')
      .isIn(['cash', 'card', 'bank_transfer', 'check', 'mobile_payment'])
      .withMessage('Invalid payment method'),
    payment_date: body('payment_date')
      .optional()
      .isISO8601()
      .withMessage('Valid payment date required'),
  },
};

/**
 * Validate that end_date is after start_date
 */
const validateDateRange = (req, res, next) => {
  const { start_date, end_date } = req.body;
  
  if (start_date && end_date) {
    const start = new Date(start_date);
    const end = new Date(end_date);
    
    if (end <= start) {
      return sendError(res, {
        statusCode: 422,
        message: 'End date must be after start date',
        code: 'INVALID_DATE_RANGE',
      });
    }
  }
  
  next();
};

/**
 * Sanitize input to prevent XSS
 */
const sanitizeInput = (req, res, next) => {
  // Remove any HTML tags from string inputs
  const sanitize = (obj) => {
    for (let key in obj) {
      if (typeof obj[key] === 'string') {
        obj[key] = obj[key].replace(/<[^>]*>/g, '');
      } else if (typeof obj[key] === 'object' && obj[key] !== null) {
        sanitize(obj[key]);
      }
    }
  };

  if (req.body) sanitize(req.body);
  if (req.query) sanitize(req.query);
  if (req.params) sanitize(req.params);

  next();
};

/**
 * Validate file upload
 */
const validateFileUpload = (allowedTypes = [], maxSize = 5 * 1024 * 1024) => {
  return (req, res, next) => {
    if (!req.file) {
      return next(); // No file, skip validation
    }

    const file = req.file;

    // Check file type
    if (allowedTypes.length > 0 && !allowedTypes.includes(file.mimetype)) {
      return sendError(res, {
        statusCode: 422,
        message: `Invalid file type. Allowed: ${allowedTypes.join(', ')}`,
        code: 'INVALID_FILE_TYPE',
      });
    }

    // Check file size
    if (file.size > maxSize) {
      return sendError(res, {
        statusCode: 422,
        message: `File too large. Maximum size: ${maxSize / (1024 * 1024)}MB`,
        code: 'FILE_TOO_LARGE',
      });
    }

    next();
  };
};

module.exports = {
  handleValidationErrors,
  validations,
  validateDateRange,
  sanitizeInput,
  validateFileUpload,
};


//   [Folder] models


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\Attendance.js
// src/models/Attendance.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

/**
 * Attendance model
 * NOTE: This model is aligned with the SQL migration in
 * `migrations/attendance-payroll-migration.sql`
 */
const Attendance = sequelize.define('Attendance', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  employee_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'employees',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  // Date of attendance
  date: {
    type: DataTypes.DATEONLY,
    allowNull: false,
  },
  // We store full timestamp in DB, map as DATE to keep it simple
  check_in_time: {
    type: DataTypes.DATE,
    allowNull: true,
    comment: 'Clock in time',
  },
  check_out_time: {
    type: DataTypes.DATE,
    allowNull: true,
    comment: 'Clock out time',
  },
  status: {
    type: DataTypes.STRING, // matches VARCHAR(50) in SQL
    allowNull: false,
    defaultValue: 'present',
    comment: "present, absent, late, half_day, leave, holiday, weekend",
  },
  // Leave details
  leave_type: {
    type: DataTypes.STRING,
    allowNull: true,
    comment: 'Type of leave if status is leave',
  },
  leave_reason: {
    type: DataTypes.TEXT,
    allowNull: true,
  },
  leave_approved_by: {
    type: DataTypes.UUID,
    allowNull: true,
    references: {
      model: 'users',
      key: 'id',
    },
  },
  // Working hours
  total_hours: {
    type: DataTypes.DECIMAL(4, 2),
    allowNull: true,
    comment: 'Total hours worked',
  },
  overtime_hours: {
    type: DataTypes.DECIMAL(4, 2),
    allowNull: true,
    defaultValue: 0,
    comment: 'Overtime hours',
  },
  break_hours: {
    type: DataTypes.DECIMAL(4, 2),
    allowNull: true,
    defaultValue: 0,
  },
  // Location tracking
  check_in_location: {
    type: DataTypes.JSONB,
    allowNull: true,
  },
  check_out_location: {
    type: DataTypes.JSONB,
    allowNull: true,
  },
  // Notes and approval
  notes: {
    type: DataTypes.TEXT,
    allowNull: true,
  },
  recorded_by: {
    type: DataTypes.UUID,
    allowNull: true,
    references: {
      model: 'users',
      key: 'id',
    },
    comment: 'User who recorded attendance',
  },
  approved_by: {
    type: DataTypes.UUID,
    allowNull: true,
    references: {
      model: 'users',
      key: 'id',
    },
    comment: 'Manager who approved special cases',
  },
}, {
  tableName: 'attendance',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['company_id'] },
    { fields: ['employee_id'] },
    { fields: ['date'] },
    { unique: true, fields: ['employee_id', 'date'] }, // One record per employee per day
  ],
});

module.exports = Attendance;



// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\Company.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Company = sequelize.define('Company', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  name: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING(255),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true,
    },
  },
  phone: {
    type: DataTypes.STRING(50),
  },
  address: {
    type: DataTypes.TEXT,
  },
  tax_id: {
    type: DataTypes.STRING(100),
  },
  logo_url: {
    type: DataTypes.TEXT,
  },
  subscription_plan: {
    type: DataTypes.ENUM('basic', 'professional', 'enterprise'),
    defaultValue: 'basic',
  },
  subscription_status: {
    type: DataTypes.ENUM('active', 'inactive', 'trial', 'suspended'),
    defaultValue: 'trial',
  },
  subscription_start_date: {
    type: DataTypes.DATE,
  },
  subscription_end_date: {
    type: DataTypes.DATE,
  },
  trial_ends_at: {
    type: DataTypes.DATE,
  },
  monthly_recurring_revenue: {
    type: DataTypes.DECIMAL(12, 2),
    defaultValue: 0,
  },
  settings: {
    type: DataTypes.JSONB,
    defaultValue: {},
  },
}, {
  tableName: 'companies',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
});

module.exports = Company;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\Contract.js
// src/models/Contract.js (UPDATED WITH KM LIMITS & OVERAGE)
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Contract = sequelize.define('Contract', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  contract_number: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  customer_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'customers',
      key: 'id',
    },
    onDelete: 'RESTRICT',
  },
  vehicle_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'vehicles',
      key: 'id',
    },
    onDelete: 'RESTRICT',
  },
  created_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
  start_date: {
    type: DataTypes.DATE,
    allowNull: false,
  },
  end_date: {
    type: DataTypes.DATE,
    allowNull: false,
  },
  actual_return_date: {
    type: DataTypes.DATE,
  },
  daily_rate: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  total_days: {
    type: DataTypes.INTEGER,
    allowNull: false,
  },
  base_amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  additional_charges: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
  },
  discount_amount: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
  },
  tax_amount: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
  },
  total_amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  
  // ============================================
  // MILEAGE TRACKING & LIMITS
  // ============================================
  start_mileage: {
    type: DataTypes.INTEGER,
    comment: 'Vehicle mileage at pickup',
  },
  end_mileage: {
    type: DataTypes.INTEGER,
    comment: 'Vehicle mileage at return',
  },
  actual_km_driven: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    comment: 'Calculated: end_mileage - start_mileage',
  },
  
  // Daily KM limits
  daily_km_limit: {
    type: DataTypes.INTEGER,
    defaultValue: 300,
    comment: 'Maximum km allowed per day (default: 300km/day)',
  },
  total_km_allowed: {
    type: DataTypes.INTEGER,
    comment: 'Total km allowed: daily_km_limit * total_days',
  },
  
  // Overage tracking
  km_overage: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    comment: 'Km driven beyond allowed limit',
  },
  overage_rate_per_km: {
    type: DataTypes.DECIMAL(5, 2),
    comment: 'Rate per km for overage (DZD)',
  },
  overage_charges: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
    comment: 'Total charges for km overage',
  },
  
  // Legacy fields (kept for backward compatibility)
  mileage_limit: {
    type: DataTypes.INTEGER,
    comment: 'DEPRECATED: Use daily_km_limit instead',
  },
  mileage_charge_per_km: {
    type: DataTypes.DECIMAL(5, 2),
    comment: 'DEPRECATED: Use overage_rate_per_km instead',
  },
  
  // ============================================
  // EXISTING FIELDS
  // ============================================
  status: {
    type: DataTypes.ENUM('draft', 'active', 'completed', 'cancelled', 'extended'),
    defaultValue: 'active',
  },
  extras: {
    type: DataTypes.JSONB,
    defaultValue: {},
  },
  contract_pdf_url: {
    type: DataTypes.TEXT,
  },
  contract_signed_date: {
    type: DataTypes.DATE,
  },
  deposit_amount: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
  },
  deposit_returned: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
  },
  notes: {
    type: DataTypes.TEXT,
  },
}, {
  tableName: 'contracts',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['company_id'] },
    { fields: ['customer_id'] },
    { fields: ['vehicle_id'] },
    { fields: ['status'] },
    { fields: ['start_date', 'end_date'] },
  ],
  hooks: {
    beforeCreate: (contract) => {
      // Auto-calculate total km allowed
      if (contract.daily_km_limit && contract.total_days) {
        contract.total_km_allowed = contract.daily_km_limit * contract.total_days;
      }
    },
    beforeUpdate: (contract) => {
      // Recalculate if days or daily limit changed
      if (contract.changed('daily_km_limit') || contract.changed('total_days')) {
        contract.total_km_allowed = contract.daily_km_limit * contract.total_days;
      }
      
      // Calculate actual km driven and overage when mileages are set
      if (contract.end_mileage && contract.start_mileage) {
        contract.actual_km_driven = contract.end_mileage - contract.start_mileage;
        
        // Calculate overage
        if (contract.total_km_allowed) {
          contract.km_overage = Math.max(0, contract.actual_km_driven - contract.total_km_allowed);
        }
        
        // Calculate overage charges if rate is set
        if (contract.km_overage > 0 && contract.overage_rate_per_km) {
          contract.overage_charges = contract.km_overage * parseFloat(contract.overage_rate_per_km);
        }
      }
    },
  },
});

module.exports = Contract;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\Customer.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Customer = sequelize.define('Customer', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  customer_type: {
    type: DataTypes.ENUM('individual', 'corporate'),
    defaultValue: 'individual',
  },
  full_name: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  company_name: {
    type: DataTypes.STRING(255),
  },
  email: {
    type: DataTypes.STRING(255),
    validate: {
      isEmail: true,
    },
  },
  phone: {
    type: DataTypes.STRING(50),
    allowNull: false,
  },
  address: {
    type: DataTypes.TEXT,
  },
  city: {
    type: DataTypes.STRING(100),
  },
  date_of_birth: {
    type: DataTypes.DATEONLY,
  },
  id_card_number: {
    type: DataTypes.STRING(50),
  },
  drivers_license_number: {
    type: DataTypes.STRING(50),
    unique: true,
  },
  license_expiry_date: {
    type: DataTypes.DATEONLY,
  },
  id_card_photo_url: {
    type: DataTypes.TEXT,
  },
  license_photo_url: {
    type: DataTypes.TEXT,
  },
  emergency_contact_name: {
    type: DataTypes.STRING(255),
  },
  emergency_contact_phone: {
    type: DataTypes.STRING(50),
  },
  notes: {
    type: DataTypes.TEXT,
  },
  is_blacklisted: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
  },
  total_rentals: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
  lifetime_value: {
    type: DataTypes.DECIMAL(12, 2),
    defaultValue: 0,
  },
  apply_tier_discount: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
    allowNull: false,
  },
}, {
  tableName: 'customers',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    {
      fields: ['company_id'],
    },
    {
      fields: ['phone'],
    },
    {
      fields: ['drivers_license_number'],
    },
  ],
});

module.exports = Customer;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\Employee.js
// src/models/Employee.js (ENHANCED VERSION)
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Employee = sequelize.define('Employee', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  user_id: {
    type: DataTypes.UUID,
    unique: true,
    references: {
      model: 'users',
      key: 'id',
    },
    onDelete: 'SET NULL',
  },
  full_name: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING(255),
    allowNull: false,
    validate: {
      isEmail: true,
    },
  },
  phone: {
    type: DataTypes.STRING(50),
    allowNull: false,
  },
  position: {
    type: DataTypes.STRING(100),
  },
  department: {
    type: DataTypes.ENUM(
      'management',
      'sales',
      'fleet',
      'finance',
      'customer_service',
      'operations'
    ),
    defaultValue: 'operations',
  },
  // Role determines system permissions
  role: {
    type: DataTypes.ENUM(
      'owner',
      'admin',
      'manager',
      'sales_agent',
      'fleet_coordinator',
      'accountant',
      'receptionist'
    ),
    allowNull: false,
    defaultValue: 'receptionist',
  },
  salary_type: {
    type: DataTypes.ENUM('hourly', 'monthly', 'commission', 'fixed_plus_commission'),
    defaultValue: 'monthly',
  },
  salary: {
    type: DataTypes.DECIMAL(10, 2),
  },
  commission_rate: {
    type: DataTypes.DECIMAL(5, 2),
    comment: 'Percentage (e.g., 5.00 for 5%)',
  },
  hire_date: {
    type: DataTypes.DATEONLY,
    allowNull: false,
  },
  termination_date: {
    type: DataTypes.DATEONLY,
  },
  status: {
    type: DataTypes.ENUM('active', 'on_leave', 'suspended', 'terminated'),
    defaultValue: 'active',
  },
  id_card_number: {
    type: DataTypes.STRING(50),
  },
  address: {
    type: DataTypes.TEXT,
  },
  emergency_contact_name: {
    type: DataTypes.STRING(255),
  },
  emergency_contact_phone: {
    type: DataTypes.STRING(50),
  },
  // Permissions - custom overrides beyond role defaults
  custom_permissions: {
    type: DataTypes.JSONB,
    defaultValue: {},
    comment: 'Override specific permissions: { "can_delete_vehicles": true }',
  },
  // Work schedule
  work_schedule: {
    type: DataTypes.JSONB,
    defaultValue: {},
    comment: 'Weekly schedule: { "monday": { "start": "09:00", "end": "17:00" } }',
  },
  notes: {
    type: DataTypes.TEXT,
  },
  avatar_url: {
    type: DataTypes.TEXT,
  },
  // Performance tracking
  total_contracts_created: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
  total_revenue_generated: {
    type: DataTypes.DECIMAL(12, 2),
    defaultValue: 0,
  },
}, {
  tableName: 'employees',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['company_id'] },
    { fields: ['status'] },
    { fields: ['role'] },
    { fields: ['email'] },
  ],
});

module.exports = Employee;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\index.js
// src/models/index.js (UPDATED WITH NOTIFICATION)
const { sequelize } = require('../config/database');

// Import all models
const Company = require('./Company');
const User = require('./User');
const Vehicle = require('./Vehicle');
const Customer = require('./Customer');
const Contract = require('./Contract');
const Payment = require('./Payment');
const VehicleCost = require('./VehicleCost');
const Employee = require('./Employee');
const Notification = require('./Notification');
const Attendance = require('./Attendance');
const { Payroll } = require('./Payroll');

// ============================================
// COMPANY RELATIONSHIPS
// ============================================
Company.hasMany(User, { foreignKey: 'company_id', as: 'users' });
User.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Vehicle, { foreignKey: 'company_id', as: 'vehicles' });
Vehicle.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Customer, { foreignKey: 'company_id', as: 'customers' });
Customer.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Contract, { foreignKey: 'company_id', as: 'contracts' });
Contract.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Employee, { foreignKey: 'company_id', as: 'employees' });
Employee.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Payment, { foreignKey: 'company_id', as: 'payments' });
Payment.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Notification, { foreignKey: 'company_id', as: 'notifications' });
Notification.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

// ============================================
// CONTRACT RELATIONSHIPS
// ============================================
Customer.hasMany(Contract, { foreignKey: 'customer_id', as: 'contracts' });
Contract.belongsTo(Customer, { foreignKey: 'customer_id', as: 'customer' });

Vehicle.hasMany(Contract, { foreignKey: 'vehicle_id', as: 'contracts' });
Contract.belongsTo(Vehicle, { foreignKey: 'vehicle_id', as: 'vehicle' });

User.hasMany(Contract, { foreignKey: 'created_by', as: 'created_contracts' });
Contract.belongsTo(User, { foreignKey: 'created_by', as: 'creator' });

// ============================================
// PAYMENT RELATIONSHIPS
// ============================================
Contract.hasMany(Payment, { foreignKey: 'contract_id', as: 'payments' });
Payment.belongsTo(Contract, { foreignKey: 'contract_id', as: 'contract' });

Customer.hasMany(Payment, { foreignKey: 'customer_id', as: 'payments' });
Payment.belongsTo(Customer, { foreignKey: 'customer_id', as: 'customer' });

User.hasMany(Payment, { foreignKey: 'processed_by', as: 'processed_payments' });
Payment.belongsTo(User, { foreignKey: 'processed_by', as: 'processor' });

// ============================================
// VEHICLE COST RELATIONSHIPS
// ============================================
Vehicle.hasMany(VehicleCost, { foreignKey: 'vehicle_id', as: 'costs' });
VehicleCost.belongsTo(Vehicle, { foreignKey: 'vehicle_id', as: 'vehicle' });

User.hasMany(VehicleCost, { foreignKey: 'created_by', as: 'vehicle_costs' });
VehicleCost.belongsTo(User, { foreignKey: 'created_by', as: 'creator' });

// ============================================
// EMPLOYEE RELATIONSHIPS
// ============================================
User.hasOne(Employee, { foreignKey: 'user_id', as: 'employee_profile' });
Employee.belongsTo(User, { foreignKey: 'user_id', as: 'user' });

Employee.hasMany(Contract, { 
  foreignKey: 'created_by', 
  sourceKey: 'user_id',
  as: 'created_contracts' 
});

Employee.hasMany(Payment, { 
  foreignKey: 'processed_by',
  sourceKey: 'user_id', 
  as: 'processed_payments' 
});

// ============================================
// NOTIFICATION RELATIONSHIPS
// ============================================
User.hasMany(Notification, { foreignKey: 'user_id', as: 'notifications' });
Notification.belongsTo(User, { foreignKey: 'user_id', as: 'user' });




Employee.hasMany(Attendance, { foreignKey: 'employee_id', as: 'attendance_records' });
Attendance.belongsTo(Employee, { foreignKey: 'employee_id', as: 'employee' });

Employee.hasMany(Payroll, { foreignKey: 'employee_id', as: 'payroll_records' });
Payroll.belongsTo(Employee, { foreignKey: 'employee_id', as: 'employee' });

Company.hasMany(Attendance, { foreignKey: 'company_id', as: 'attendance_records' });
Attendance.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

Company.hasMany(Payroll, { foreignKey: 'company_id', as: 'payroll_records' });
Payroll.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });

// ============================================
// EXPORT ALL MODELS
// ============================================
module.exports = {
  sequelize,
  Company,
  User,
  Vehicle,
  Customer,
  Contract,
  Payment,
  VehicleCost,
  Employee,
  Notification,
  Attendance,
  Payroll,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\Notification.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');
const Notification = sequelize.define('Notification', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  user_id: {
    type: DataTypes.UUID,
    allowNull: true,
    references: {
      model: 'users',
      key: 'id',
    },
    onDelete: 'SET NULL',
    comment: 'Specific user recipient (null = all company users)',
  },
  type: {
    type: DataTypes.ENUM(
      'vehicle_limit_warning',
      'vehicle_limit_critical',
      'vehicle_limit_reached',
      'vehicle_maintenance',
      'km_limit_warning',
      'km_limit_critical',
      'km_limit_exceeded',
      'contract_overage',
      'contract_expiring',
      'payment_due',
      'system_alert',
      'general'
    ),
    allowNull: false,
  },
  priority: {
    type: DataTypes.ENUM('low', 'medium', 'high', 'critical'),
    defaultValue: 'medium',
  },
  title: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  message: {
    type: DataTypes.TEXT,
    allowNull: false,
  },
  data: {
    type: DataTypes.JSONB,
    defaultValue: {},
    comment: 'Additional structured data',
  },
  is_read: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
  },
  read_at: {
    type: DataTypes.DATE,
  },
  // UPDATED: New fields for reversible dismissal
  dismissed: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
  },
  dismissed_at: {
    type: DataTypes.DATE,
  },
  action_url: {
    type: DataTypes.TEXT,
    comment: 'Optional URL for "Take Action" button',
  },
}, {
  tableName: 'notifications',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['company_id'] },
    { fields: ['user_id'] },
    { fields: ['is_read'] },
    { fields: ['type'] },
    { fields: ['priority'] },
    { fields: ['created_at'] },
    // UPDATED: Index for dismissed filtering
    { fields: ['dismissed'] },
  ],
});
module.exports = Notification;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\Payment.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Payment = sequelize.define('Payment', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  contract_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'contracts',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  customer_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'customers',
      key: 'id',
    },
    onDelete: 'RESTRICT',
  },
  amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  payment_method: {
    type: DataTypes.ENUM('cash', 'card', 'bank_transfer', 'check', 'mobile_payment'),
    allowNull: false,
  },
  payment_date: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
  reference_number: {
    type: DataTypes.STRING(100),
  },
  status: {
    type: DataTypes.ENUM('pending', 'completed', 'failed', 'refunded'),
    defaultValue: 'completed',
  },
  notes: {
    type: DataTypes.TEXT,
  },
  receipt_url: {
    type: DataTypes.TEXT,
  },
  processed_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
}, {
  tableName: 'payments',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: false,
  indexes: [
    {
      fields: ['contract_id'],
    },
    {
      fields: ['payment_date'],
    },
    {
      fields: ['company_id'],
    },
  ],
});

module.exports = Payment;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\Payroll.js
// src/models/Payroll.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Payroll = sequelize.define('Payroll', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  employee_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'employees',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  pay_period_start: {
    type: DataTypes.DATEONLY,
    allowNull: false,
  },
  pay_period_end: {
    type: DataTypes.DATEONLY,
    allowNull: false,
  },
  payment_date: {
    type: DataTypes.DATEONLY,
  },
  base_salary: {
    type: DataTypes.DECIMAL(12, 2),
    allowNull: false,
  },
  gross_salary: {
    type: DataTypes.DECIMAL(12, 2),
    allowNull: false,
  },
  net_salary: {
    type: DataTypes.DECIMAL(12, 2),
    allowNull: false,
  },
  total_days_in_period: {
    type: DataTypes.INTEGER,
    allowNull: false,
  },
  days_present: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
  days_absent: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
  days_on_leave: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
  total_hours_worked: {
    type: DataTypes.DECIMAL(8, 2),
    defaultValue: 0,
  },
  overtime_hours: {
    type: DataTypes.DECIMAL(8, 2),
    defaultValue: 0,
  },
  earnings: {
    type: DataTypes.JSONB,
    defaultValue: {},
  },
  deductions: {
    type: DataTypes.JSONB,
    defaultValue: {},
  },
  payment_method: {
    type: DataTypes.ENUM('bank_transfer', 'cash', 'check'),
  },
  payment_reference: {
    type: DataTypes.STRING(100),
  },
  payment_status: {
    type: DataTypes.ENUM('pending', 'approved', 'paid', 'cancelled'),
    defaultValue: 'pending',
  },
  calculated_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
  approved_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
  paid_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
  notes: {
    type: DataTypes.TEXT,
  },
  payslip_url: {
    type: DataTypes.TEXT,
  },
}, {
  tableName: 'payroll',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['company_id'] },
    { fields: ['employee_id'] },
    { fields: ['pay_period_start', 'pay_period_end'] },
    { fields: ['payment_status'] },
    { unique: true, fields: ['employee_id', 'pay_period_start', 'pay_period_end'] },
  ],
});

// ============================================
// Leave Request Model
// ============================================
const LeaveRequest = sequelize.define('LeaveRequest', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  employee_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'employees',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  leave_type: {
    type: DataTypes.ENUM(
      'sick',
      'vacation',
      'personal',
      'unpaid',
      'maternity',
      'paternity',
      'emergency'
    ),
    allowNull: false,
  },
  start_date: {
    type: DataTypes.DATEONLY,
    allowNull: false,
  },
  end_date: {
    type: DataTypes.DATEONLY,
    allowNull: false,
  },
  total_days: {
    type: DataTypes.INTEGER,
    allowNull: false,
  },
  reason: {
    type: DataTypes.TEXT,
    allowNull: false,
  },
  status: {
    type: DataTypes.ENUM('pending', 'approved', 'rejected', 'cancelled'),
    defaultValue: 'pending',
  },
  requested_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
  reviewed_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
  review_notes: {
    type: DataTypes.TEXT,
  },
  review_date: {
    type: DataTypes.DATE,
  },
  attachment_urls: {
    type: DataTypes.JSONB,
    defaultValue: [],
  },
}, {
  tableName: 'leave_requests',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['company_id'] },
    { fields: ['employee_id'] },
    { fields: ['status'] },
    { fields: ['start_date', 'end_date'] },
  ],
});

// ============================================
// Leave Balance Model
// ============================================
const LeaveBalance = sequelize.define('LeaveBalance', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  employee_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'employees',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  leave_type: {
    type: DataTypes.STRING(50),
    allowNull: false,
  },
  year: {
    type: DataTypes.INTEGER,
    allowNull: false,
  },
  total_allocated: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
  used: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
  pending: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
}, {
  tableName: 'leave_balances',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['company_id'] },
    { fields: ['employee_id'] },
    { unique: true, fields: ['employee_id', 'leave_type', 'year'] },
  ],
});

module.exports = {
  Payroll,
  LeaveRequest,
  LeaveBalance,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\User.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');
const bcrypt = require('bcryptjs');

const User = sequelize.define('User', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  full_name: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING(255),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true,
    },
  },
  password_hash: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  // Virtual field for setting password
  password: {
    type: DataTypes.VIRTUAL,
    set(value) {
      // Store the plain password temporarily
      this.setDataValue('password', value);
      // Hash it and set password_hash
      const hash = bcrypt.hashSync(value, 10);
      this.setDataValue('password_hash', hash);
    },
  },
  phone: {
    type: DataTypes.STRING(50),
  },
  avatar_url: {
    type: DataTypes.TEXT,
  },
  role: {
    type: DataTypes.ENUM('owner', 'admin', 'manager', 'staff', 'viewer'),
    defaultValue: 'staff',
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
  },
  last_login_at: {
    type: DataTypes.DATE,
  },
}, {
  tableName: 'users',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    {
      fields: ['company_id'],
    },
    {
      fields: ['email'],
    },
  ],
  hooks: {
    beforeCreate: async (user) => {
      if (user.password) {
        user.password_hash = await bcrypt.hash(user.password, 10);
      }
    },
    beforeUpdate: async (user) => {
      if (user.password) {
        user.password_hash = await bcrypt.hash(user.password, 10);
      }
    },
  },
});

module.exports = User;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\Vehicle.js
// src/models/Vehicle.js - Compatible with your existing index.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const Vehicle = sequelize.define('Vehicle', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  company_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'companies',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  brand: {
    type: DataTypes.STRING(100),
    allowNull: false,
  },
  model: {
    type: DataTypes.STRING(100),
    allowNull: false,
  },
  year: {
    type: DataTypes.INTEGER,
    allowNull: false,
  },
  registration_number: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true,
  },
  vin: {
    type: DataTypes.STRING(17),
    unique: true,
  },
  color: {
    type: DataTypes.STRING(50),
  },
  transmission: {
    type: DataTypes.ENUM('manual', 'automatic'),
    defaultValue: 'manual',
  },
  fuel_type: {
    type: DataTypes.ENUM('petrol', 'diesel', 'electric', 'hybrid'),
    defaultValue: 'petrol',
  },
  seats: {
    type: DataTypes.INTEGER,
    defaultValue: 5,
  },
  daily_rate: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  status: {
    type: DataTypes.ENUM('available', 'rented', 'maintenance', 'retired'),
    defaultValue: 'available',
  },
  
  // ============================================
  // MILEAGE TRACKING FIELDS
  // ============================================
  mileage: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    comment: 'Current total mileage in kilometers',
  },
  last_maintenance_mileage: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    comment: 'Mileage at last maintenance',
  },
  next_maintenance_mileage: {
    type: DataTypes.INTEGER,
    comment: 'Mileage when next maintenance is due',
  },
  maintenance_interval_km: {
    type: DataTypes.INTEGER,
    defaultValue: 5000,
    comment: 'Maintenance interval in km (default: 5000km)',
  },
  
  // ============================================
  // MAINTENANCE ALERTS
  // ============================================
  maintenance_alert_threshold: {
    type: DataTypes.INTEGER,
    defaultValue: 100,
    comment: 'Send alert every X km (default: 100km)',
  },
  last_maintenance_alert_mileage: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    comment: 'Last mileage when alert was sent',
  },
  last_maintenance_date: {
    type: DataTypes.DATEONLY,
    comment: 'Date of last maintenance service',
  },
  next_maintenance_date: {
    type: DataTypes.DATEONLY,
    comment: 'Scheduled date for next maintenance',
  },
  
  // ============================================
  // MAINTENANCE HISTORY SUMMARY
  // ============================================
  total_maintenance_costs: {
    type: DataTypes.DECIMAL(12, 2),
    defaultValue: 0,
    comment: 'Lifetime maintenance costs',
  },
  maintenance_count: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    comment: 'Number of maintenance services performed',
  },
  last_oil_change_mileage: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
  },
  last_oil_change_date: {
    type: DataTypes.DATEONLY,
  },
  
  // ============================================
  // EXISTING FIELDS
  // ============================================
  purchase_price: {
    type: DataTypes.DECIMAL(12, 2),
  },
  purchase_date: {
    type: DataTypes.DATEONLY,
  },
  photos: {
    type: DataTypes.JSONB,
    defaultValue: [],
  },
  features: {
    type: DataTypes.JSONB,
    defaultValue: {},
  },
  notes: {
    type: DataTypes.TEXT,
  },
}, {
  tableName: 'vehicles',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  indexes: [
    { fields: ['company_id'] },
    { fields: ['status'] },
    { fields: ['mileage'] },
    { fields: ['next_maintenance_mileage'] },
  ],
  hooks: {
    // Auto-calculate next maintenance when vehicle is created/updated
    beforeSave: async (vehicle) => {
      if (vehicle.changed('mileage') || vehicle.changed('last_maintenance_mileage')) {
        if (!vehicle.next_maintenance_mileage || vehicle.mileage > vehicle.next_maintenance_mileage) {
          vehicle.next_maintenance_mileage = 
            vehicle.last_maintenance_mileage + vehicle.maintenance_interval_km;
        }
      }
    },
  },
});

module.exports = Vehicle;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\models\VehicleCost.js
// src/models/VehicleCost.js - Compatible with your existing index.js
const { DataTypes } = require('sequelize');
const { sequelize } = require('../config/database');

const VehicleCost = sequelize.define('VehicleCost', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  vehicle_id: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'vehicles',
      key: 'id',
    },
    onDelete: 'CASCADE',
  },
  cost_type: {
    type: DataTypes.ENUM('fuel', 'maintenance', 'insurance', 'registration', 'cleaning', 'repair', 'other'),
    allowNull: false,
  },
  amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
  },
  incurred_date: {
    type: DataTypes.DATEONLY,
    allowNull: false,
  },
  description: {
    type: DataTypes.TEXT,
  },
  receipt_url: {
    type: DataTypes.TEXT,
  },
  created_by: {
    type: DataTypes.UUID,
    references: {
      model: 'users',
      key: 'id',
    },
  },
  metadata: {
    type: DataTypes.JSONB,
    defaultValue: {},
    comment: 'Additional metadata like service_type, parts_replaced, technician_name, etc.',
  },
}, {
  tableName: 'vehicle_costs',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: false,
  indexes: [
    {
      fields: ['vehicle_id', 'incurred_date'],
    },
    {
      fields: ['cost_type'],
    },
  ],
});

module.exports = VehicleCost;


//   [Folder] routes


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\admin.routes.js
const express = require('express');
const router = express.Router();

const adminController = require('../controllers/admin.controller');

// ============================================
// Platform Stats
// ============================================
router.get('/stats', adminController.getPlatformStats);

// ============================================
// Companies
// ============================================
router.get('/companies', adminController.getAllCompanies);
router.get('/companies/:id', adminController.getCompanyById);
router.put('/companies/:id/subscription', adminController.updateSubscription);
router.put('/companies/:id/suspend', adminController.suspendCompany);
router.put('/companies/:id/reactivate', adminController.reactivateCompany);

// ============================================
// Users
// ============================================
router.get('/users', adminController.getAllUsers);

// ============================================
// Analytics
// ============================================
router.get('/analytics/growth', adminController.getGrowthAnalytics);
router.get('/analytics/revenue-by-plan', adminController.getRevenueByPlan);
router.get('/analytics/feature-usage', adminController.getFeatureUsage);
router.get('/analytics/trending-vehicles', adminController.getTrendingVehicles);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\analytics.routes.js
// src/routes/analytics.routes.js
const express = require('express');
const router = express.Router();
const {
  getDashboard,
  getRevenue,
  getVehiclePerformance,
  getVehicleUtilization,
  getVehicleProfitLoss,
  getCustomerAnalytics,
  getCustomerSegmentation,
  getCustomerRetention,
} = require('../controllers/analytics.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// DASHBOARD & OVERVIEW
// ============================================

/**
 * GET /api/analytics/dashboard
 * Get comprehensive dashboard KPIs
 * Query params:
 *   - period: 'today' | 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 * 
 * Access: All authenticated users
 */
router.get('/dashboard', getDashboard);

// ============================================
// REVENUE ANALYTICS
// ============================================

/**
 * GET /api/analytics/revenue
 * Get detailed revenue analytics
 * Query params:
 *   - period: 'today' | 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 *   - compare: boolean (compare with previous period)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/revenue',
  requireRole(['owner', 'admin', 'manager']),
  getRevenue
);

// ============================================
// VEHICLE ANALYTICS
// ============================================

/**
 * GET /api/analytics/vehicles
 * Get vehicle performance overview
 * Query params:
 *   - period: 'today' | 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 *   - metric: 'utilization' | 'revenue' | 'profit'
 *   - limit: number (default 10)
 * 
 * Access: All authenticated users
 */
router.get('/vehicles', getVehiclePerformance);

/**
 * GET /api/analytics/vehicles/utilization
 * Get detailed vehicle utilization rates
 * Query params:
 *   - period: 'today' | 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 *   - vehicle_id: UUID (filter by specific vehicle)
 * 
 * Access: All authenticated users
 */
router.get('/vehicles/utilization', getVehicleUtilization);

/**
 * GET /api/analytics/vehicles/profit-loss
 * Get vehicle profit & loss analysis
 * Query params:
 *   - period: 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/vehicles/profit-loss',
  requireRole(['owner', 'admin', 'manager']),
  getVehicleProfitLoss
);

// ============================================
// CUSTOMER ANALYTICS
// ============================================

/**
 * GET /api/analytics/customers
 * Get comprehensive customer analytics (segmentation + retention)
 * Query params:
 *   - period: 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/customers',
  requireRole(['owner', 'admin', 'manager']),
  getCustomerAnalytics
);

/**
 * GET /api/analytics/customers/segmentation
 * Get customer segmentation by value
 * No query params (uses all-time data)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/customers/segmentation',
  requireRole(['owner', 'admin', 'manager']),
  getCustomerSegmentation
);

/**
 * GET /api/analytics/customers/retention
 * Get customer retention metrics
 * Query params:
 *   - period: 'week' | 'month' | 'quarter' | 'year'
 *   - start_date: ISO date string (optional)
 *   - end_date: ISO date string (optional)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/customers/retention',
  requireRole(['owner', 'admin', 'manager']),
  getCustomerRetention
);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\attendance.routes.js
// src/routes/attendance.routes.js
const express = require('express');
const router = express.Router();
const {
  checkIn,
  checkOut,
  markAttendance,
  getAttendance,
  getAttendanceSummary,
  getTodayAttendance,
} = require('../controllers/attendance.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// ATTENDANCE ROUTES
// ============================================

/**
 * GET /api/attendance/today
 * Get today's attendance for all employees
 * Access: All authenticated users
 */
router.get('/today', getTodayAttendance);

/**
 * GET /api/attendance/summary
 * Get attendance summary for a period
 * Query params:
 *   - employee_id: UUID (optional)
 *   - month: YYYY-MM (optional)
 *   - start_date: ISO date (optional)
 *   - end_date: ISO date (optional)
 * Access: Owner, Admin, Manager, Receptionist
 */
router.get('/summary', requireRole(['owner', 'admin', 'manager', 'receptionist']), getAttendanceSummary);

/**
 * GET /api/attendance
 * Get attendance records with filters
 * Query params:
 *   - employee_id: UUID (optional)
 *   - start_date: ISO date (optional)
 *   - end_date: ISO date (optional)
 *   - status: Attendance status (optional)
 *   - page: Page number (default: 1)
 *   - limit: Items per page (default: 20)
 * Access: All authenticated users
 */
router.get('/', getAttendance);

/**
 * POST /api/attendance/check-in
 * Mark employee check-in
 * Body:
 *   - employee_id: UUID
 *   - check_in_time: ISO timestamp (optional, defaults to now)
 *   - location: Object {lat, lng, address} (optional)
 *   - notes: String (optional)
 * Access: Receptionist, Manager, Admin, Owner
 */
router.post('/check-in', requireRole(['owner', 'admin', 'manager', 'receptionist']), checkIn);

/**
 * POST /api/attendance/check-out
 * Mark employee check-out
 * Body:
 *   - employee_id: UUID
 *   - check_out_time: ISO timestamp (optional, defaults to now)
 *   - location: Object {lat, lng, address} (optional)
 *   - notes: String (optional)
 * Access: Receptionist, Manager, Admin, Owner
 */
router.post('/check-out', requireRole(['owner', 'admin', 'manager', 'receptionist']), checkOut);

/**
 * POST /api/attendance/mark
 * Manually mark attendance (for historical records or corrections)
 * Body:
 *   - employee_id: UUID
 *   - date: ISO date
 *   - status: Attendance status
 *   - check_in_time: ISO timestamp (optional)
 *   - check_out_time: ISO timestamp (optional)
 *   - leave_type: String (optional, required if status is 'leave')
 *   - notes: String (optional)
 * Access: Owner, Admin, Manager, Receptionist
 */
router.post('/mark', requireRole(['owner', 'admin', 'manager', 'receptionist']), markAttendance);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\auth.routes.js
// src/routes/auth.routes.js
const express = require('express');
const router = express.Router();
const {
  register,
  login,
  getMe,
  logout,
  refresh,
} = require('../controllers/auth.controller');
const { authenticateToken } = require('../middleware/auth.middleware');

// Public routes (no auth)
router.post('/register', register);
router.post('/login', login);
router.post('/refresh', refresh);

// Protected routes: Auth only (NO RBAC/requireRoleâ€”skip employee fetch)
router.get('/me', authenticateToken, getMe); // Token verify onlyâ€”no role/permission check
router.post('/logout', authenticateToken, logout); // Logout after auth

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\company.routes.js
// src/routes/company.routes.js
const express = require('express');
const router = express.Router();

const { createCompany } = require('../controllers/company.controller');

// Public: Create company for signup (no auth)
router.post('/', createCompany);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\companyProfile.routes.js
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth.middleware'); // Your auth middleware
const { getProfile, updateProfile, updateSettings } = require('../controllers/company.controller');

const { injectCompanyId, validateTenantOwnership } = require('../middleware/tenantIsolation.middleware');



// Apply authentication + tenant isolation to ALL routes in this router
router.use(authenticateToken);
router.use(injectCompanyId);

// GET /api/company/profile
router.get('/profile', getProfile);


// PUT /api/company/profile - Update company profile
// Validates that user isn't trying to update another company's data
router.put('/profile', validateTenantOwnership('company_id'), updateProfile);

// PUT /api/company/settings
router.put('/settings', updateSettings);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\contract.routes.js
// src/routes/contract.routes.js - UNIFIED VERSION
const express = require('express');
const router = express.Router();

// Import contract controllers
const {
  getAllContracts,
  getContractById,
  createContract,
  updateContract,
  completeContract,
  cancelContract,
  extendContract,
  getContractStats,
} = require('../controllers/contract.controller');

// Import KM & overage controllers
const {
  completeContractWithMileage,
  estimateOverageCharges,
  getCustomerTierInfoEndpoint,
} = require('../controllers/contractKm.controller');

// Import payment controller
const { getContractPayments } = require('../controllers/payment.controller');

// Import middleware
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// ============================================
// APPLY MIDDLEWARE TO ALL ROUTES
// ============================================
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// GLOBAL CONTRACT ROUTES (MUST BE FIRST)
// ============================================

/**
 * GET /api/contracts/stats
 * Get contract statistics
 * MUST be before /:id to avoid matching 'stats' as an ID
 */
router.get('/stats', getContractStats);

/**
 * GET /api/contracts
 * List all contracts with filters
 */
router.get('/', getAllContracts);

/**
 * POST /api/contracts
 * Create new contract
 */
router.post('/', createContract);

// ============================================
// SPECIFIC CONTRACT ROUTES (/:id ROUTES)
// Order matters! More specific routes BEFORE generic /:id
// ============================================

/**
 * GET /api/contracts/:id/mileage-estimate
 * Estimate overage charges before completing contract
 * Query params: estimated_end_mileage (integer)
 */
router.get('/:id/mileage-estimate', estimateOverageCharges);

/**
 * GET /api/contracts/:id/payments
 * Get all payments for a contract
 */
router.get('/:id/payments', getContractPayments);

/**
 * GET /api/contracts/:id
 * Get single contract details
 */
router.get('/:id', getContractById);

/**
 * PUT /api/contracts/:id
 * Update contract
 */
router.put(
  '/:id',
  requireRole(['owner', 'admin', 'manager', 'staff']),
  updateContract
);

/**
 * POST /api/contracts/:id/complete-with-mileage
 * Complete contract with automatic overage calculation (NEW - with tier pricing)
 * 
 * Body:
 *   - end_mileage: Final vehicle mileage (required)
 *   - actual_return_date: Return date (required)
 *   - additional_charges: Other charges (optional)
 *   - notes: Additional notes (optional)
 * 
 * Features:
 *   - Calculates km driven
 *   - Applies tier-based km bonuses
 *   - Calculates overage charges with tier discounts
 *   - Updates contract total
 *   - Returns vehicle to available
 *   - Creates overage notification
 */
router.post(
  '/:id/complete-with-mileage',
  requireRole(['owner', 'admin', 'manager', 'staff']),
  completeContractWithMileage
);

/**
 * POST /api/contracts/:id/complete
 * Complete contract (LEGACY - basic completion without tier pricing)
 * Use /complete-with-mileage for new implementations
 */
router.post(
  '/:id/complete',
  requireRole(['owner', 'admin', 'manager', 'staff']),
  completeContract
);

/**
 * POST /api/contracts/:id/cancel
 * Cancel contract
 */
router.post(
  '/:id/cancel',
  requireRole(['owner', 'admin', 'manager']),
  cancelContract
);

/**
 * POST /api/contracts/:id/extend
 * Extend rental period
 */
router.post(
  '/:id/extend',
  requireRole(['owner', 'admin', 'manager', 'staff']),
  extendContract
);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\customer.routes.js
// src/routes/customer.routes.js - WITH TIER INFO
const express = require('express');
const router = express.Router();

const {
  getAllCustomers,
  getCustomerById,
  getCustomerHistory,
  createCustomer,
  updateCustomer,
  deleteCustomer,
  getCustomerStats,
} = require('../controllers/customer.controller');

// Import tier info endpoint from contractKm controller
const { getCustomerTierInfoEndpoint } = require('../controllers/contractKm.controller');

const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// CUSTOMER ROUTES
// ============================================

// GET /api/customers/stats - Get customer statistics
// Must be BEFORE /:id route to avoid matching 'stats' as an ID
router.get('/stats', getCustomerStats);

// GET /api/customers - List all customers (with filters & search)
router.get('/', getAllCustomers);

// GET /api/customers/:id/tier-info - Get customer loyalty tier (MUST be before /:id)
router.get('/:id/tier-info', getCustomerTierInfoEndpoint);

// GET /api/customers/:id/history - Get customer rental history
router.get('/:id/history', getCustomerHistory);

// GET /api/customers/:id - Get single customer
router.get('/:id', getCustomerById);

// POST /api/customers - Create customer
router.post('/', createCustomer);

// PUT /api/customers/:id - Update customer
router.put('/:id', requireRole(['owner', 'admin', 'manager', 'staff']), updateCustomer);

// DELETE /api/customers/:id - Delete customer
router.delete('/:id', requireRole(['owner', 'admin']), deleteCustomer);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\employee.routes.js
// src/routes/employee.routes.js
const express = require('express');
const router = express.Router();
const {
  getAllEmployees,
  getEmployeeById,
  createEmployee,
  updateEmployee,
  terminateEmployee,
  resetEmployeePassword,
  getEmployeeStats,
  getAvailableRoles,
} = require('../controllers/employee.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// EMPLOYEE ROUTES
// ============================================

/**
 * GET /api/employees/roles
 * Get available roles with their permissions
 * Access: All authenticated users
 */
router.get('/roles', getAvailableRoles);

/**
 * GET /api/employees/stats
 * Get employee statistics
 * Access: Owner, Admin, Manager
 */
router.get('/stats', requireRole(['owner', 'admin', 'manager']), getEmployeeStats);

/**
 * GET /api/employees
 * List all employees with filters
 * Query params:
 *   - status: 'active' | 'on_leave' | 'suspended' | 'terminated'
 *   - role: Employee role
 *   - department: Department name
 *   - search: Search by name, email, phone, position
 *   - page: Page number (default: 1)
 *   - limit: Items per page (default: 20)
 *   - sort_by: Sort field (default: created_at)
 *   - sort_order: 'ASC' | 'DESC' (default: DESC)
 * 
 * Access: Owner, Admin, Manager, Receptionist
 */
router.get('/', requireRole(['owner', 'admin', 'manager', 'receptionist']), getAllEmployees);

/**
 * GET /api/employees/:id
 * Get single employee with full details
 * Access: Owner, Admin, Manager, Receptionist
 */
router.get('/:id', requireRole(['owner', 'admin', 'manager', 'receptionist']), getEmployeeById);

/**
 * POST /api/employees
 * Create new employee (also creates user account)
 * Required fields:
 *   - full_name: string
 *   - email: string (unique)
 *   - phone: string
 *   - password: string (min 8 chars)
 *   - role: Role enum
 *   - hire_date: ISO date
 * Optional fields:
 *   - department: Department enum
 *   - position: string
 *   - salary_type: Salary type enum
 *   - salary: number
 *   - commission_rate: number (0-100)
 *   - work_schedule: object
 *   - custom_permissions: object
 *   - address, emergency_contact_name, emergency_contact_phone, notes
 * 
 * Access: Owner, Admin
 */
router.post('/', requireRole(['owner', 'admin']), createEmployee);

/**
 * PUT /api/employees/:id
 * Update employee details
 * All fields are optional
 * Access: Owner, Admin
 */
router.put('/:id', requireRole(['owner', 'admin']), updateEmployee);

/**
 * DELETE /api/employees/:id
 * Terminate employee (soft delete - sets status to 'terminated')
 * Also deactivates the associated user account
 * Note: Cannot terminate owner accounts
 * Access: Owner only
 */
router.delete('/:id', requireRole(['owner']), terminateEmployee);

/**
 * POST /api/employees/:id/reset-password
 * Reset employee's password
 * Required fields:
 *   - new_password: string (min 8 chars)
 * 
 * Access: Owner, Admin
 */
router.post('/:id/reset-password', requireRole(['owner', 'admin']), resetEmployeePassword);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\notifications.routes.js
const express = require('express');
const router = express.Router();
const { Notification, sequelize } = require('../models');
const { Op } = require('sequelize');
const { authenticateToken } = require('../middleware/auth.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply auth & tenant isolation
router.use(authenticateToken);
router.use(injectCompanyId);

// GET /api/notifications?priority=critical&limit=5&unread=true&dismissed=false&type=km_limit_*&data[vehicle_id]=abc123
// Fetches company-specific notifications (filtered/sorted)
router.get('/', async (req, res) => {
  try {
    const { priority, limit = 10, unread = true, dismissed = false, type } = req.query;
    const where = { company_id: req.companyId };
    if (unread) where.is_read = false;
    if (priority) where.priority = priority;
    
    // Existing dismissed handling
    if (dismissed === 'true') {
      where.dismissed = true;
    } else {
      where.dismissed = false;
    }
    
    // FIXED: Filter by type with wildcard support (cast ENUM to TEXT for ILIKE)
    if (type) {
      if (typeof type === 'string' && type.includes('*')) {
        // Wildcard: km_limit_* â†’ LIKE 'km_limit_%' (case-insensitive)
        const pattern = type.replace('*', '%').toLowerCase();
        // Use sequelize.where with CAST to convert ENUM to TEXT for ILIKE
        where[Op.and] = sequelize.where(
          sequelize.cast(sequelize.col('type'), 'TEXT'),
          { [Op.iLike]: pattern }
        );
      } else {
        // Exact match (works with ENUM)
        where.type = type;
      }
    }
    
    // Filter by data (JSONB) - Parse params like data[vehicle_id]=abc123
    const dataFilters = {};
    Object.keys(req.query).forEach(key => {
      if (key.startsWith('data[') && key.endsWith(']')) {
        const dataKey = key.slice(5, -1);  // Extract 'vehicle_id'
        const value = req.query[key];
        dataFilters[dataKey] = value;
      }
    });
    if (Object.keys(dataFilters).length > 0) {
      where.data = {};
      Object.entries(dataFilters).forEach(([key, value]) => {
        where.data[key] = { [Op.eq]: value };
      });
    }
    
    const notifications = await Notification.findAll({
      where,
      order: [['created_at', 'DESC']],
      limit: parseInt(limit),
      attributes: { exclude: ['updated_at'] },
    });
    res.json({
      success: true,
      data: { notifications },
      meta: { total: notifications.length },
    });
  } catch (error) {
    console.error('ðŸ’¥ Fetch notifications error:', error);
    res.status(500).json({ success: false, message: 'Failed to fetch notifications', error: error.message });
  }
});

// PATCH /api/notifications/:id/read
router.patch('/:id/read', async (req, res) => {
  try {
    const { id } = req.params;
    const notification = await Notification.findOne({ where: { id, company_id: req.companyId } });
    if (!notification) return res.status(404).json({ success: false, message: 'Notification not found' });
    await notification.update({ is_read: true, read_at: new Date() });
    res.json({ success: true, message: 'Marked as read' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Failed to update notification' });
  }
});

// PATCH /api/notifications/:id/dismiss
router.patch('/:id/dismiss', async (req, res) => {
  try {
    const { id } = req.params;
    const notification = await Notification.findOne({ where: { id, company_id: req.companyId } });
    if (!notification) return res.status(404).json({ success: false, message: 'Notification not found' });
    await notification.update({ 
      dismissed: true, 
      dismissed_at: new Date(), 
      is_read: true, 
      read_at: new Date() 
    });
    res.json({ success: true, message: 'Notification dismissed' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Failed to dismiss notification' });
  }
});

// PATCH /api/notifications/:id/restore
router.patch('/:id/restore', async (req, res) => {
  try {
    const { id } = req.params;
    const notification = await Notification.findOne({ where: { id, company_id: req.companyId } });
    if (!notification) return res.status(404).json({ success: false, message: 'Notification not found' });
    await notification.update({ 
      dismissed: false, 
      dismissed_at: null 
    });
    res.json({ success: true, message: 'Notification restored' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Failed to restore notification' });
  }
});

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\payment.routes.js
// src/routes/payment.routes.js
const express = require('express');
const router = express.Router();
const {
  getAllPayments,
  getPaymentById,
  createPayment,
  updatePayment,
  getOutstandingPayments,
  getContractPayments,
  getPaymentStats,
} = require('../controllers/payment.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// PAYMENT ROUTES
// ============================================

// GET /api/payments/stats - Get payment statistics
// Must be BEFORE /:id route to avoid matching 'stats' as an ID
router.get('/stats', getPaymentStats);

// GET /api/payments/outstanding - Get outstanding payments
// Must be BEFORE /:id route to avoid matching 'outstanding' as an ID
router.get('/outstanding', getOutstandingPayments);

// GET /api/payments - List all payments
// All authenticated users can view payments
router.get('/', getAllPayments);

// GET /api/payments/:id - Get single payment
router.get('/:id', getPaymentById);

// POST /api/payments - Record new payment
// Only owners, admins, managers, and staff can record payments
router.post('/', requireRole(['owner', 'admin', 'manager', 'staff']), createPayment);

// PUT /api/payments/:id - Update payment
// Only owners, admins, and managers can update payments
router.put('/:id', requireRole(['owner', 'admin', 'manager']), updatePayment);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\payroll.routes.js
// src/routes/payroll.routes.js
const express = require('express');
const router = express.Router();
const {
  calculatePayroll,
  getPayroll,
  approvePayroll,
  markAsPaid,
  getPayrollStats,
} = require('../controllers/payroll.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// PAYROLL ROUTES
// ============================================

/**
 * GET /api/payroll/stats
 * Get payroll statistics
 * Query params:
 *   - month: YYYY-MM (optional)
 * Access: Owner, Admin, Accountant
 */
router.get('/stats', requireRole(['owner', 'admin', 'accountant']), getPayrollStats);

/**
 * GET /api/payroll
 * Get payroll records with filters
 * Query params:
 *   - employee_id: UUID (optional)
 *   - month: YYYY-MM (optional)
 *   - status: Payment status (optional)
 *   - page: Page number (default: 1)
 *   - limit: Items per page (default: 20)
 * Access: Owner, Admin, Accountant
 */
router.get('/', requireRole(['owner', 'admin', 'accountant']), getPayroll);

/**
 * POST /api/payroll/calculate
 * Calculate payroll for an employee for a period
 * Body:
 *   - employee_id: UUID
 *   - pay_period_start: ISO date
 *   - pay_period_end: ISO date
 *   - payment_date: ISO date (optional)
 * Access: Owner, Admin, Accountant
 */
router.post('/calculate', requireRole(['owner', 'admin', 'accountant']), calculatePayroll);

/**
 * PUT /api/payroll/:id/approve
 * Approve payroll
 * Access: Owner, Admin
 */
router.put('/:id/approve', requireRole(['owner', 'admin']), approvePayroll);

/**
 * PUT /api/payroll/:id/pay
 * Mark payroll as paid
 * Body:
 *   - payment_date: ISO date
 *   - payment_method: 'bank_transfer' | 'cash' | 'check'
 *   - payment_reference: String (optional)
 * Access: Owner, Admin, Accountant
 */
router.put('/:id/pay', requireRole(['owner', 'admin', 'accountant']), markAsPaid);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\reports.routes.js
// src/routes/reports.routes.js
const express = require('express');
const router = express.Router();
const {
  generateReport,
  generateReportPDF,
  generateReportExcel,
} = require('../controllers/reports.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// REPORT GENERATION ROUTES
// ============================================

/**
 * GET /api/reports/:type
 * Generate report in JSON format
 * 
 * Params:
 *   - type: 'executive' | 'vehicle' | 'customer'
 * 
 * Query params:
 *   - startDate: ISO date string (optional)
 *   - endDate: ISO date string (optional)
 *   - vehicleIds: Array of vehicle IDs (optional)
 *   - customerIds: Array of customer IDs (optional)
 *   - minRevenue: Minimum revenue filter (optional)
 *   - maxRevenue: Maximum revenue filter (optional)
 *   - minUtilization: Minimum utilization % (optional)
 *   - maxUtilization: Maximum utilization % (optional)
 *   - vehicleBrand: Filter by brand (optional)
 *   - customerType: 'individual' | 'corporate' (optional)
 *   - sortBy: 'profit' | 'revenue' | 'utilization' (optional)
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/:type',
  requireRole(['owner', 'admin', 'manager']),
  generateReport
);

/**
 * GET /api/reports/:type/pdf
 * Generate report as PDF file
 * 
 * Params:
 *   - type: 'executive' | 'vehicle' | 'customer'
 * 
 * Query params: Same as JSON endpoint
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/:type/pdf',
  requireRole(['owner', 'admin', 'manager']),
  generateReportPDF
);

/**
 * GET /api/reports/:type/excel
 * Generate report as Excel file
 * 
 * Params:
 *   - type: 'executive' | 'vehicle' | 'customer'
 * 
 * Query params: Same as JSON endpoint
 * 
 * Access: Owner, Admin, Manager
 */
router.get(
  '/:type/excel',
  requireRole(['owner', 'admin', 'manager']),
  generateReportExcel
);

module.exports = router;

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\routes\vehicle.routes.js
// src/routes/vehicle.routes.js - FIXED
const express = require('express');
const router = express.Router();
const {
  getAllVehicles,
  getAvailableVehicles,
  getVehicleById,
  createVehicle,
  updateVehicle,
  deleteVehicle,
  addVehicleCost,
  getVehicleCosts,
} = require('../controllers/vehicle.controller');
const {
  completeMaintenanceService,
  getMaintenanceHistory,
  getVehiclesDueMaintenance,
} = require('../controllers/vehicleMaintenance.controller');
const { authenticateToken } = require('../middleware/auth.middleware');
const { requireRole } = require('../middleware/permissions.middleware');
const { injectCompanyId } = require('../middleware/tenantIsolation.middleware');

// Apply authentication and tenant isolation to ALL routes
router.use(authenticateToken);
router.use(injectCompanyId);

// ============================================
// MAINTENANCE ROUTES (MUST BE BEFORE /:id)
// ============================================

// GET /api/vehicles/maintenance/due
router.get('/maintenance/due', getVehiclesDueMaintenance);

// ============================================
// VEHICLE ROUTES
// ============================================

// GET /api/vehicles - List all vehicles (with filters)
router.get('/', getAllVehicles);

// GET /api/vehicles/available - Get available vehicles
// MUST be BEFORE /:id route
router.get('/available', getAvailableVehicles);

// GET /api/vehicles/:id - Get single vehicle
router.get('/:id', getVehicleById);

// POST /api/vehicles - Create vehicle
router.post('/', requireRole(['owner', 'admin', 'manager']), createVehicle);

// PUT /api/vehicles/:id - Update vehicle
router.put('/:id', requireRole(['owner', 'admin', 'manager']), updateVehicle);

// DELETE /api/vehicles/:id - Delete vehicle (soft delete)
router.delete('/:id', requireRole(['owner', 'admin']), deleteVehicle);

// ============================================
// VEHICLE-SPECIFIC MAINTENANCE ROUTES
// ============================================

// POST /api/vehicles/:id/maintenance/complete
router.post(
  '/:id/maintenance/complete',
  requireRole(['owner', 'admin', 'manager']),
  completeMaintenanceService
);

// GET /api/vehicles/:id/maintenance/history
router.get('/:id/maintenance/history', getMaintenanceHistory);

// ============================================
// VEHICLE COST ROUTES
// ============================================

// POST /api/vehicles/:id/costs - Add vehicle cost
router.post('/:id/costs', requireRole(['owner', 'admin', 'manager']), addVehicleCost);

// GET /api/vehicles/:id/costs - Get cost history
router.get('/:id/costs', getVehicleCosts);

module.exports = router;


//   [Folder] services


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\services\analytics.service.js
// src/services/analytics.service.js
const { Contract, Payment, Vehicle, Customer, VehicleCost, sequelize } = require('../models');
const { Op } = require('sequelize');

/**
 * Analytics Service
 * Provides business intelligence calculations for the car rental system
 */

// ============================================
// REVENUE ANALYTICS
// ============================================

/**
 * Calculate revenue for a given period
 * @param {string} companyId - Company UUID
 * @param {Date} startDate - Start of period
 * @param {Date} endDate - End of period
 * @returns {Object} Revenue breakdown
 */
const calculateRevenue = async (companyId, startDate, endDate) => {
  try {
    // Total revenue from completed payments
    const revenueResult = await Payment.findOne({
      where: {
        company_id: companyId,
        status: 'completed',
        payment_date: {
          [Op.between]: [startDate, endDate],
        },
      },
      attributes: [
        [sequelize.fn('SUM', sequelize.col('amount')), 'total_revenue'],
        [sequelize.fn('COUNT', sequelize.col('id')), 'payment_count'],
      ],
      raw: true,
    });

    // Revenue by payment method
    const revenueByMethod = await Payment.findAll({
      where: {
        company_id: companyId,
        status: 'completed',
        payment_date: {
          [Op.between]: [startDate, endDate],
        },
      },
      attributes: [
        'payment_method',
        [sequelize.fn('SUM', sequelize.col('amount')), 'amount'],
        [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
      ],
      group: ['payment_method'],
      raw: true,
    });

    // Revenue by day (for trend analysis)
    const revenueByDay = await Payment.findAll({
      where: {
        company_id: companyId,
        status: 'completed',
        payment_date: {
          [Op.between]: [startDate, endDate],
        },
      },
      attributes: [
        [sequelize.fn('DATE', sequelize.col('payment_date')), 'date'],
        [sequelize.fn('SUM', sequelize.col('amount')), 'revenue'],
        [sequelize.fn('COUNT', sequelize.col('id')), 'transactions'],
      ],
      group: [sequelize.fn('DATE', sequelize.col('payment_date'))],
      order: [[sequelize.fn('DATE', sequelize.col('payment_date')), 'ASC']],
      raw: true,
    });

    // Average transaction value
    const avgTransactionValue = revenueResult?.total_revenue && revenueResult?.payment_count
      ? parseFloat(revenueResult.total_revenue) / parseInt(revenueResult.payment_count)
      : 0;

    return {
      total_revenue: parseFloat(revenueResult?.total_revenue || 0),
      payment_count: parseInt(revenueResult?.payment_count || 0),
      average_transaction_value: avgTransactionValue,
      revenue_by_method: revenueByMethod.map(r => ({
        method: r.payment_method,
        amount: parseFloat(r.amount),
        count: parseInt(r.count),
      })),
      revenue_by_day: revenueByDay.map(r => ({
        date: r.date,
        revenue: parseFloat(r.revenue),
        transactions: parseInt(r.transactions),
      })),
    };
  } catch (error) {
    console.error('ðŸ’¥ Calculate revenue error:', error);
    throw error;
  }
};

/**
 * Get revenue comparison with previous period
 * @param {string} companyId 
 * @param {Date} currentStart 
 * @param {Date} currentEnd 
 * @returns {Object} Revenue comparison
 */
const getRevenueComparison = async (companyId, currentStart, currentEnd) => {
  try {
    const periodLength = currentEnd - currentStart;
    const previousStart = new Date(currentStart.getTime() - periodLength);
    const previousEnd = new Date(currentStart.getTime());

    const currentRevenue = await calculateRevenue(companyId, currentStart, currentEnd);
    const previousRevenue = await calculateRevenue(companyId, previousStart, previousEnd);

    const growth = previousRevenue.total_revenue > 0
      ? ((currentRevenue.total_revenue - previousRevenue.total_revenue) / previousRevenue.total_revenue) * 100
      : 0;

    return {
      current_period: currentRevenue,
      previous_period: previousRevenue,
      growth_percentage: growth,
    };
  } catch (error) {
    console.error('ðŸ’¥ Revenue comparison error:', error);
    throw error;
  }
};

// ============================================
// VEHICLE ANALYTICS
// ============================================

/**
 * Calculate vehicle utilization rates
 * @param {string} companyId 
 * @param {Date} startDate 
 * @param {Date} endDate 
 * @returns {Array} Vehicle utilization data
 */
const calculateVehicleUtilization = async (companyId, startDate, endDate) => {
  try {
    const vehicles = await Vehicle.findAll({
      where: { company_id: companyId },
      attributes: ['id', 'brand', 'model', 'registration_number', 'daily_rate', 'status'],
    });

    const periodDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));

    const utilizationData = await Promise.all(
      vehicles.map(async (vehicle) => {
        // Count days rented
        const contracts = await Contract.findAll({
          where: {
            vehicle_id: vehicle.id,
            status: { [Op.in]: ['active', 'completed'] },
            [Op.or]: [
              {
                start_date: { [Op.between]: [startDate, endDate] },
              },
              {
                end_date: { [Op.between]: [startDate, endDate] },
              },
              {
                [Op.and]: [
                  { start_date: { [Op.lte]: startDate } },
                  { end_date: { [Op.gte]: endDate } },
                ],
              },
            ],
          },
          attributes: ['start_date', 'end_date', 'total_amount'],
        });

        let totalDaysRented = 0;
        let totalRevenue = 0;

        contracts.forEach(contract => {
          const contractStart = new Date(Math.max(contract.start_date, startDate));
          const contractEnd = new Date(Math.min(contract.end_date, endDate));
          const daysRented = Math.ceil((contractEnd - contractStart) / (1000 * 60 * 60 * 24)) + 1;
          totalDaysRented += daysRented;
          totalRevenue += parseFloat(contract.total_amount);
        });

        const utilizationRate = (totalDaysRented / periodDays) * 100;
        const revenuePerDay = totalDaysRented > 0 ? totalRevenue / totalDaysRented : 0;

        return {
          vehicle_id: vehicle.id,
          brand: vehicle.brand,
          model: vehicle.model,
          registration_number: vehicle.registration_number,
          daily_rate: parseFloat(vehicle.daily_rate),
          current_status: vehicle.status,
          total_days_rented: totalDaysRented,
          available_days: periodDays - totalDaysRented,
          utilization_rate: utilizationRate,
          total_revenue: totalRevenue,
          revenue_per_day: revenuePerDay,
          rental_count: contracts.length,
        };
      })
    );

    // Sort by utilization rate
    utilizationData.sort((a, b) => b.utilization_rate - a.utilization_rate);

    return utilizationData;
  } catch (error) {
    console.error('ðŸ’¥ Calculate vehicle utilization error:', error);
    throw error;
  }
};

/**
 * Get top performing vehicles
 * @param {string} companyId 
 * @param {Date} startDate 
 * @param {Date} endDate 
 * @param {number} limit 
 * @returns {Array} Top vehicles
 */
const getTopPerformingVehicles = async (companyId, startDate, endDate, limit = 10) => {
  try {
    const vehicles = await calculateVehicleUtilization(companyId, startDate, endDate);
    return vehicles.slice(0, limit);
  } catch (error) {
    console.error('ðŸ’¥ Get top vehicles error:', error);
    throw error;
  }
};

/**
 * Calculate profit/loss for vehicles
 * @param {string} companyId 
 * @param {Date} startDate 
 * @param {Date} endDate 
 * @returns {Array} Vehicle P&L
 */
const calculateVehicleProfitLoss = async (companyId, startDate, endDate) => {
  try {
    const utilization = await calculateVehicleUtilization(companyId, startDate, endDate);

    const profitLossData = await Promise.all(
      utilization.map(async (vehicle) => {
        // Get costs for this vehicle
        const costs = await VehicleCost.findAll({
          where: {
            vehicle_id: vehicle.vehicle_id,
            incurred_date: {
              [Op.between]: [startDate, endDate],
            },
          },
          attributes: [
            'cost_type',
            [sequelize.fn('SUM', sequelize.col('amount')), 'total'],
          ],
          group: ['cost_type'],
          raw: true,
        });

        const totalCosts = costs.reduce((sum, cost) => sum + parseFloat(cost.total), 0);
        const profit = vehicle.total_revenue - totalCosts;
        const profitMargin = vehicle.total_revenue > 0 ? (profit / vehicle.total_revenue) * 100 : 0;

        return {
          ...vehicle,
          total_costs: totalCosts,
          costs_by_type: costs.map(c => ({
            type: c.cost_type,
            amount: parseFloat(c.total),
          })),
          profit: profit,
          profit_margin: profitMargin,
        };
      })
    );

    // Sort by profit
    profitLossData.sort((a, b) => b.profit - a.profit);

    return profitLossData;
  } catch (error) {
    console.error('ðŸ’¥ Calculate vehicle P&L error:', error);
    throw error;
  }
};

// ============================================
// CUSTOMER ANALYTICS
// ============================================

/**
 * Segment customers by value
 * @param {string} companyId 
 * @returns {Object} Customer segmentation
 */
const segmentCustomers = async (companyId) => {
  try {
    const customers = await Customer.findAll({
      where: { company_id: companyId },
      attributes: [
        'id',
        'full_name',
        'email',
        'customer_type',
        'total_rentals',
        'lifetime_value',
        'created_at',
      ],
      order: [['lifetime_value', 'DESC']],
    });

    // Calculate quartiles
    const sortedByValue = customers.map(c => parseFloat(c.lifetime_value)).sort((a, b) => a - b);
    const q1 = sortedByValue[Math.floor(sortedByValue.length * 0.25)];
    const q2 = sortedByValue[Math.floor(sortedByValue.length * 0.5)];
    const q3 = sortedByValue[Math.floor(sortedByValue.length * 0.75)];

    const segmented = {
      vip: customers.filter(c => parseFloat(c.lifetime_value) >= q3),
      high_value: customers.filter(c => parseFloat(c.lifetime_value) >= q2 && parseFloat(c.lifetime_value) < q3),
      medium_value: customers.filter(c => parseFloat(c.lifetime_value) >= q1 && parseFloat(c.lifetime_value) < q2),
      low_value: customers.filter(c => parseFloat(c.lifetime_value) < q1),
    };

    return {
      total_customers: customers.length,
      segments: {
        vip: {
          count: segmented.vip.length,
          total_value: segmented.vip.reduce((sum, c) => sum + parseFloat(c.lifetime_value), 0),
          customers: segmented.vip.slice(0, 10), // Top 10 VIPs
        },
        high_value: {
          count: segmented.high_value.length,
          total_value: segmented.high_value.reduce((sum, c) => sum + parseFloat(c.lifetime_value), 0),
        },
        medium_value: {
          count: segmented.medium_value.length,
          total_value: segmented.medium_value.reduce((sum, c) => sum + parseFloat(c.lifetime_value), 0),
        },
        low_value: {
          count: segmented.low_value.length,
          total_value: segmented.low_value.reduce((sum, c) => sum + parseFloat(c.lifetime_value), 0),
        },
      },
    };
  } catch (error) {
    console.error('ðŸ’¥ Segment customers error:', error);
    throw error;
  }
};

/**
 * Get customer retention metrics
 * @param {string} companyId 
 * @param {Date} startDate 
 * @param {Date} endDate 
 * @returns {Object} Retention metrics
 */
const getCustomerRetention = async (companyId, startDate, endDate) => {
  try {
    // New customers in period
    const newCustomers = await Customer.count({
      where: {
        company_id: companyId,
        created_at: {
          [Op.between]: [startDate, endDate],
        },
      },
    });

    // Repeat customers (had rentals before and during period)
    const repeatCustomers = await Customer.count({
      where: {
        company_id: companyId,
        created_at: { [Op.lt]: startDate },
        total_rentals: { [Op.gt]: 1 },
      },
      include: [
        {
          model: Contract,
          as: 'contracts',
          where: {
            start_date: {
              [Op.between]: [startDate, endDate],
            },
          },
          required: true,
        },
      ],
      distinct: true,
    });

    // Total active customers
    const totalActiveCustomers = await Customer.count({
      where: { company_id: companyId },
      include: [
        {
          model: Contract,
          as: 'contracts',
          where: {
            start_date: {
              [Op.between]: [startDate, endDate],
            },
          },
          required: true,
        },
      ],
      distinct: true,
    });

    const retentionRate = totalActiveCustomers > 0
      ? (repeatCustomers / totalActiveCustomers) * 100
      : 0;

    return {
      new_customers: newCustomers,
      repeat_customers: repeatCustomers,
      total_active_customers: totalActiveCustomers,
      retention_rate: retentionRate,
    };
  } catch (error) {
    console.error('ðŸ’¥ Get customer retention error:', error);
    throw error;
  }
};

// ============================================
// DASHBOARD KPIs
// ============================================

/**
 * Get comprehensive dashboard KPIs
 * @param {string} companyId 
 * @param {Date} startDate 
 * @param {Date} endDate 
 * @returns {Object} Dashboard data
 */
const getDashboardKPIs = async (companyId, startDate, endDate) => {
  try {
    // Run all analytics in parallel
    const [
      revenue,
      vehicleUtilization,
      customerSegmentation,
      customerRetention,
      activeContracts,
      totalVehicles,
      maintenanceVehicles,
    ] = await Promise.all([
      calculateRevenue(companyId, startDate, endDate),
      calculateVehicleUtilization(companyId, startDate, endDate),
      segmentCustomers(companyId),
      getCustomerRetention(companyId, startDate, endDate),
      Contract.count({
        where: {
          company_id: companyId,
          status: 'active',
        },
      }),
      Vehicle.count({
        where: { company_id: companyId },
      }),
      Vehicle.count({
        where: {
          company_id: companyId,
          status: 'maintenance',
        },
      }),
    ]);

    // Calculate fleet-wide utilization
    const avgUtilization = vehicleUtilization.length > 0
      ? vehicleUtilization.reduce((sum, v) => sum + v.utilization_rate, 0) / vehicleUtilization.length
      : 0;

    const availableVehicles = totalVehicles - activeContracts - maintenanceVehicles;

    return {
      period: {
        start: startDate,
        end: endDate,
      },
      revenue: {
        total: revenue.total_revenue,
        average_transaction: revenue.average_transaction_value,
        payment_count: revenue.payment_count,
      },
      fleet: {
        total_vehicles: totalVehicles,
        active_rentals: activeContracts,
        available_vehicles: availableVehicles,
        maintenance_vehicles: maintenanceVehicles,
        average_utilization: avgUtilization,
      },
      customers: {
        total: customerSegmentation.total_customers,
        new: customerRetention.new_customers,
        repeat: customerRetention.repeat_customers,
        retention_rate: customerRetention.retention_rate,
      },
      top_vehicles: vehicleUtilization.slice(0, 5),
    };
  } catch (error) {
    console.error('ðŸ’¥ Get dashboard KPIs error:', error);
    throw error;
  }
};

module.exports = {
  // Revenue
  calculateRevenue,
  getRevenueComparison,
  
  // Vehicles
  calculateVehicleUtilization,
  getTopPerformingVehicles,
  calculateVehicleProfitLoss,
  
  // Customers
  segmentCustomers,
  getCustomerRetention,
  
  // Dashboard
  getDashboardKPIs,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\services\companySettings.service.js
// src/services/companySettings.service.js
const { Company } = require('../models');

const getDefaultDailyKmLimit = async (companyId) => {
  try {
    const company = await Company.findByPk(companyId, {
      attributes: ['settings'],
    });
    if (!company) {
      console.warn(`âš ï¸ Company ${companyId} not found, using default 300km`);
      return 300;
    }
    const dailyKmLimit = company.settings?.defaultDailyKmLimit;
    if (dailyKmLimit && typeof dailyKmLimit === 'number' && dailyKmLimit >= 50 && dailyKmLimit <= 1000) {
      console.log(`âœ… Using company ${companyId} daily KM limit: ${dailyKmLimit}km`);
      return dailyKmLimit;
    }
    console.log(`â„¹ï¸ No valid daily KM limit in settings for company ${companyId}, using default 300km`);
    return 300;
  } catch (error) {
    console.error(`âŒ Error fetching daily KM limit for company ${companyId}:`, error);
    return 300;
  }
};

const getDefaultOverageRate = async (companyId) => {
  try {
    const company = await Company.findByPk(companyId, {
      attributes: ['settings'],
    });
    if (!company) {
      console.warn(`âš ï¸ Company ${companyId} not found, using default 20 DA/km`);
      return 20;
    }
    const overageRate = company.settings?.defaultOverageRate;
    if (overageRate && typeof overageRate === 'number' && overageRate >= 5 && overageRate <= 50) {
      console.log(`âœ… Using company ${companyId} overage rate: ${overageRate} DA/km`);
      return overageRate;
    }
    console.log(`â„¹ï¸ No valid overage rate in settings for company ${companyId}, using default 20 DA/km`);
    return 20;
  } catch (error) {
    console.error(`âŒ Error fetching overage rate for company ${companyId}:`, error);
    return 20;
  }
};

const getRentalPolicySettings = async (companyId) => {
  try {
    const [dailyKmLimit, overageRate] = await Promise.all([
      getDefaultDailyKmLimit(companyId),
      getDefaultOverageRate(companyId),
    ]);
    return {
      defaultDailyKmLimit: dailyKmLimit,
      defaultOverageRate: overageRate,
    };
  } catch (error) {
    console.error(`âŒ Error fetching rental policy settings for company ${companyId}:`, error);
    return {
      defaultDailyKmLimit: 300,
      defaultOverageRate: 20,
    };
  }
};

module.exports = {
  getDefaultDailyKmLimit,
  getDefaultOverageRate,
  getRentalPolicySettings,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\services\customerTier.service.js
// src/services/customerTier.service.js
/**
 * Customer Tier System for Loyalty-Based Pricing
 * Determines overage rates and benefits based on customer rental history
 */

const CUSTOMER_TIERS = {
  NEW: {
    name: 'New Customer',
    min_rentals: 0,
    max_rentals: 0,
    overage_rate: 20, // 20 DA per km
    benefits: [],
    discount_percentage: 0,
  },
  BRONZE: {
    name: 'Bronze',
    min_rentals: 1,
    max_rentals: 4,
    overage_rate: 18, // 18 DA per km
    benefits: [
      '10% discount on overage charges',
      'Priority customer support',
    ],
    discount_percentage: 5,
  },
  SILVER: {
    name: 'Silver',
    min_rentals: 5,
    max_rentals: 9,
    overage_rate: 15, // 15 DA per km
    benefits: [
      '25% discount on overage charges',
      'Free vehicle upgrade (subject to availability)',
      'Priority booking',
      'Extended daily km limit (+50km)',
    ],
    discount_percentage: 10,
    km_bonus: 50, // Extra 50km per day
  },
  GOLD: {
    name: 'Gold',
    min_rentals: 10,
    max_rentals: 19,
    overage_rate: 12, // 12 DA per km
    benefits: [
      '40% discount on overage charges',
      'Free premium vehicle upgrade',
      'Priority booking & support',
      'Extended daily km limit (+100km)',
      'Waived deposit on select vehicles',
    ],
    discount_percentage: 15,
    km_bonus: 100,
  },
  PLATINUM: {
    name: 'Platinum',
    min_rentals: 20,
    max_rentals: Infinity,
    overage_rate: 10, // 10 DA per km
    benefits: [
      '50% discount on overage charges',
      'Complimentary luxury upgrades',
      'VIP priority service',
      'Extended daily km limit (+150km)',
      'Free insurance upgrades',
      'Dedicated account manager',
      'Special corporate rates',
    ],
    discount_percentage: 20,
    km_bonus: 150,
  },
};

/**
 * Determine customer tier based on rental history
 * @param {number} totalRentals - Number of completed rentals
 * @returns {Object} Tier information
 */
const getCustomerTier = (totalRentals) => {
  for (const [tierKey, tierData] of Object.entries(CUSTOMER_TIERS)) {
    if (totalRentals >= tierData.min_rentals && totalRentals <= tierData.max_rentals) {
      return {
        tier: tierKey,
        ...tierData,
      };
    }
  }
  
  return { tier: 'NEW', ...CUSTOMER_TIERS.NEW };
};

/**
 * Calculate overage rate for customer
 * @param {Object} customer - Customer object (may have apply_tier_discount)
 * @param {number} baseRate - Base overage rate (optional)
 * @returns {number} Overage rate in DZD per km
 */
const calculateOverageRate = (customer, baseRate = null) => {
  const applyTier = customer.apply_tier_discount !== false;
  if (!applyTier) {
    return baseRate ?? CUSTOMER_TIERS.NEW.overage_rate;
  }
  const tier = getCustomerTier(customer.total_rentals || 0);
  return baseRate || tier.overage_rate;
};

/**
 * Calculate total km allowed with tier bonuses
 * @param {number} baseDailyLimit - Base daily km limit (e.g., 300)
 * @param {number} totalDays - Number of rental days
 * @param {number} totalRentals - Customer's total rentals
 * @param {Object} [options] - { applyTierBonus: boolean } default true
 * @returns {Object} Allowed km breakdown
 */
const calculateAllowedKm = (baseDailyLimit, totalDays, totalRentals, options = {}) => {
  const applyTierBonus = options.applyTierBonus !== false;
  const tier = getCustomerTier(totalRentals);
  
  const baseKmPerDay = baseDailyLimit;
  const bonusKmPerDay = applyTierBonus ? (tier.km_bonus || 0) : 0;
  const totalDailyLimit = baseKmPerDay + bonusKmPerDay;
  
  const totalAllowed = totalDailyLimit * totalDays;
  
  return {
    base_daily_limit: baseKmPerDay,
    bonus_km_per_day: bonusKmPerDay,
    total_daily_limit: totalDailyLimit,
    total_days: totalDays,
    total_km_allowed: totalAllowed,
    tier: tier.tier,
    tier_name: tier.name,
  };
};

/**
 * Calculate overage charges with tier discount
 * @param {number} kmOverage - Kilometers over limit
 * @param {number} overageRate - Rate per km
 * @param {number} totalRentals - Customer's total rentals
 * @param {Object} [options] - { applyTierDiscount: boolean } default true
 * @returns {Object} Overage breakdown
 */
const calculateOverageCharges = (kmOverage, overageRate, totalRentals, options = {}) => {
  if (kmOverage <= 0) {
    return {
      km_overage: 0,
      base_overage_charges: 0,
      discount_amount: 0,
      final_overage_charges: 0,
      tier: 'N/A',
    };
  }
  
  const applyTierDiscount = options.applyTierDiscount !== false;
  const tier = getCustomerTier(totalRentals);
  
  const baseCharges = kmOverage * overageRate;
  const discountPercentage = applyTierDiscount ? (tier.discount_percentage || 0) : 0;
  const discountAmount = (baseCharges * discountPercentage) / 100;
  const finalCharges = baseCharges - discountAmount;
  
  return {
    km_overage: kmOverage,
    overage_rate: overageRate,
    base_overage_charges: baseCharges,
    discount_percentage: discountPercentage,
    discount_amount: discountAmount,
    final_overage_charges: finalCharges,
    tier: tier.tier,
    tier_name: tier.name,
    savings: discountAmount,
  };
};

/**
 * Get tier progress (how many more rentals to next tier)
 * @param {number} totalRentals - Current total rentals
 * @returns {Object} Progress information
 */
const getTierProgress = (totalRentals) => {
  const currentTier = getCustomerTier(totalRentals);
  
  // Find next tier
  const tierOrder = ['NEW', 'BRONZE', 'SILVER', 'GOLD', 'PLATINUM'];
  const currentIndex = tierOrder.indexOf(currentTier.tier);
  
  if (currentIndex === tierOrder.length - 1) {
    // Already at highest tier
    return {
      current_tier: currentTier.tier,
      current_tier_name: currentTier.name,
      next_tier: null,
      rentals_to_next_tier: 0,
      is_max_tier: true,
    };
  }
  
  const nextTierKey = tierOrder[currentIndex + 1];
  const nextTier = CUSTOMER_TIERS[nextTierKey];
  
  const rentalsToNextTier = nextTier.min_rentals - totalRentals;
  
  return {
    current_tier: currentTier.tier,
    current_tier_name: currentTier.name,
    current_rentals: totalRentals,
    next_tier: nextTierKey,
    next_tier_name: nextTier.name,
    rentals_to_next_tier: rentalsToNextTier,
    progress_percentage: Math.min(100, (totalRentals / nextTier.min_rentals) * 100),
    is_max_tier: false,
  };
};

/**
 * Get complete customer tier info with all benefits
 * @param {Object} customer - Customer object (may have apply_tier_discount)
 * @returns {Object} Complete tier information
 */
const getCustomerTierInfo = (customer) => {
  const totalRentals = customer.total_rentals || 0;
  const tier = getCustomerTier(totalRentals);
  const progress = getTierProgress(totalRentals);
  const apply_tier_discount = customer.apply_tier_discount !== false;
  
  return {
    customer_id: customer.id,
    customer_name: customer.full_name,
    total_rentals: totalRentals,
    lifetime_value: parseFloat(customer.lifetime_value || 0),
    apply_tier_discount: !!apply_tier_discount,
    ...tier,
    progress,
  };
};

module.exports = {
  CUSTOMER_TIERS,
  getCustomerTier,
  calculateOverageRate,
  calculateAllowedKm,
  calculateOverageCharges,
  getTierProgress,
  getCustomerTierInfo,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\services\email.service.js
// src/services/email.service.js
const nodemailer = require('nodemailer');
require('dotenv').config();

// Create transporter (configure based on your email provider)
const transporter = nodemailer.createTransport({
  host: process.env.EMAIL_HOST || 'smtp.gmail.com',
  port: process.env.EMAIL_PORT || 587,
  secure: false, // true for 465, false for other ports
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD,
  },
});

/**
 * Email templates
 */
const EMAIL_TEMPLATES = {
  warning: {
    subject: 'âš ï¸ Fleet Capacity Notification',
    getHtml: (data) => `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #f59e0b;">âš ï¸ Fleet Capacity Alert</h2>
        <p>Dear ${data.companyName},</p>
        <p>Your fleet is approaching its capacity limit.</p>
        
        <div style="background: #fef3c7; padding: 20px; border-radius: 8px; margin: 20px 0;">
          <h3 style="margin-top: 0;">Current Status:</h3>
          <p style="font-size: 18px; margin: 10px 0;">
            <strong>${data.current} / ${data.max}</strong> vehicles
          </p>
          <p style="color: #92400e;">
            â° Only <strong>${data.remaining} slots</strong> remaining on your ${data.plan} plan
          </p>
        </div>

        <p>To ensure uninterrupted service and accommodate your growing fleet, we recommend upgrading your subscription.</p>

        <a href="${data.upgradeUrl}" style="display: inline-block; background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0;">
          Upgrade Now
        </a>

        <p style="color: #6b7280; font-size: 14px;">
          If you have any questions, please contact our support team.
        </p>
      </div>
    `,
  },

  critical: {
    subject: 'ðŸš¨ URGENT: Fleet Capacity Almost Reached',
    getHtml: (data) => `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #dc2626;">ðŸš¨ URGENT: Action Required</h2>
        <p>Dear ${data.companyName},</p>
        
        <div style="background: #fee2e2; border-left: 4px solid #dc2626; padding: 20px; margin: 20px 0;">
          <h3 style="color: #dc2626; margin-top: 0;">Critical Fleet Capacity Warning</h3>
          <p style="font-size: 18px; margin: 10px 0;">
            <strong>${data.current} / ${data.max}</strong> vehicles
          </p>
          <p style="color: #991b1b;">
            ðŸš¨ Only <strong>${data.remaining} slots</strong> remaining!
          </p>
        </div>

        <p><strong>Immediate action required:</strong> Your fleet is at ${data.percentage}% capacity. To avoid service disruption and continue adding vehicles, please upgrade your plan.</p>

        <div style="background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
          <h4 style="margin-top: 0;">Upgrade Benefits:</h4>
          <ul>
            <li><strong>Professional Plan:</strong> Up to 150 vehicles</li>
            <li><strong>Enterprise Plan:</strong> Up to 500 vehicles + priority support</li>
            <li>Advanced analytics and reporting</li>
            <li>Dedicated account manager (Enterprise)</li>
          </ul>
        </div>

        <a href="${data.upgradeUrl}" style="display: inline-block; background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0; font-weight: bold;">
          Upgrade Now to Avoid Disruption
        </a>

        <p style="color: #6b7280; font-size: 14px;">
          Need help? Contact us at support@carrentalsystem.com
        </p>
      </div>
    `,
  },

  limit_reached: {
    subject: 'ðŸ›‘ Fleet Limit Reached - Upgrade Required',
    getHtml: (data) => `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #dc2626;">ðŸ›‘ Fleet Limit Reached</h2>
        <p>Dear ${data.companyName},</p>
        
        <div style="background: #fecaca; border: 2px solid #dc2626; padding: 20px; border-radius: 8px; margin: 20px 0;">
          <h3 style="color: #dc2626; margin-top: 0;">Maximum Capacity Reached</h3>
          <p style="font-size: 20px; font-weight: bold; margin: 10px 0;">
            ${data.current} / ${data.max} vehicles
          </p>
          <p style="color: #991b1b;">
            You cannot add more vehicles without upgrading your plan.
          </p>
        </div>

        <p><strong>What this means:</strong> You've reached the maximum ${data.max} vehicles allowed on your ${data.plan} plan. To continue growing your fleet, an upgrade is required.</p>

        <a href="${data.upgradeUrl}" style="display: inline-block; background: #16a34a; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; margin: 20px 0; font-weight: bold; font-size: 16px;">
          Upgrade Your Plan Now
        </a>

        <p>Our team is here to help you select the best plan for your business needs.</p>

        <p style="color: #6b7280; font-size: 14px;">
          Questions? Call us at +213-XXX-XXXX or reply to this email.
        </p>
      </div>
    `,
  },

  maintenance_due: {
    subject: 'âš ï¸ Vehicle Maintenance Required',
    getHtml: (data) => `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #ea580c;">ðŸ”§ Vehicle Maintenance Alert</h2>
        <p>Dear ${data.companyName},</p>
        
        <div style="background: #fed7aa; border-left: 4px solid #ea580c; padding: 20px; margin: 20px 0;">
          <h3 style="color: #9a3412; margin-top: 0;">Maintenance Service Required</h3>
          <p style="font-size: 16px; margin: 10px 0;">
            <strong>Vehicle:</strong> ${data.vehicleBrand} ${data.vehicleModel}<br>
            <strong>Registration:</strong> ${data.registration}
          </p>
          <p style="font-size: 18px; color: #c2410c; margin: 15px 0;">
            <strong>Current Mileage:</strong> ${data.currentMileage.toLocaleString()} km<br>
            <strong>Overdue by:</strong> ${data.kmOverdue} km
          </p>
        </div>

        <p><strong>Action Required:</strong> This vehicle has exceeded its maintenance interval and requires immediate service to ensure safety and optimal performance.</p>

        <div style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;">
          <h4 style="margin-top: 0;">Recommended Maintenance:</h4>
          <ul style="margin: 10px 0;">
            <li>ðŸ”§ Oil and filter change</li>
            <li>ðŸ” Brake system inspection</li>
            <li>ðŸ›ž Tire pressure and tread check</li>
            <li>âš™ï¸ General mechanical inspection</li>
            <li>ðŸ’§ Fluid level checks</li>
          </ul>
        </div>

        <a href="${data.vehicleUrl}" style="display: inline-block; background: #ea580c; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0;">
          Schedule Maintenance Now
        </a>

        <p style="background: #fef3c7; padding: 15px; border-radius: 6px; margin: 20px 0;">
          <strong>âš ï¸ Important:</strong> Regular maintenance prevents costly repairs and ensures vehicle safety. Please schedule service as soon as possible.
        </p>

        <p style="color: #6b7280; font-size: 14px;">
          Questions? Contact our support team or your maintenance provider.
        </p>
      </div>
    `,
  },
};

/**
 * Send email using template
 * @param {Object} options - Email options
 */
const sendEmail = async ({ to, templateType, data, cc, bcc }) => {
  try {
    const template = EMAIL_TEMPLATES[templateType];
    
    if (!template) {
      throw new Error(`Unknown email template: ${templateType}`);
    }

    const mailOptions = {
      from: `"Car Rental System" <${process.env.EMAIL_USER}>`,
      to,
      cc,
      bcc,
      subject: template.subject,
      html: template.getHtml(data),
    };

    const info = await transporter.sendMail(mailOptions);
    
    console.log(`ðŸ“§ Email sent: ${info.messageId}`);
    return { success: true, messageId: info.messageId };

  } catch (error) {
    console.error('âŒ Email sending error:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Send simple text email (for quick notifications)
 */
const sendSimpleEmail = async ({ to, subject, text, html }) => {
  try {
    const mailOptions = {
      from: `"Car Rental System" <${process.env.EMAIL_USER}>`,
      to,
      subject,
      text,
      html: html || `<p>${text}</p>`,
    };

    const info = await transporter.sendMail(mailOptions);
    console.log(`ðŸ“§ Simple email sent: ${info.messageId}`);
    return { success: true, messageId: info.messageId };

  } catch (error) {
    console.error('âŒ Email sending error:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Verify email configuration
 */
const verifyEmailConfig = async () => {
  try {
    await transporter.verify();
    console.log('âœ… Email service is ready');
    return true;
  } catch (error) {
    console.error('âŒ Email service error:', error);
    return false;
  }
};

module.exports = {
  sendEmail,
  sendSimpleEmail,
  verifyEmailConfig,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\services\pdf.service.js


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\services\reportGeneration.service.js
// src/services/reportGeneration.service.js
const { Contract, Payment, Vehicle, Customer, VehicleCost, sequelize } = require('../models');
const { Op } = require('sequelize');
const analyticsService = require('./analytics.service');

/**
 * Report Generation Service
 * Generates comprehensive reports with dynamic filtering
 */

// ============================================
// HELPER: Build Dynamic WHERE Clause
// ============================================
const buildWhereClause = (companyId, filters) => {
  const where = { company_id: companyId };

  // Date range
  if (filters.startDate && filters.endDate) {
    where.created_at = {
      [Op.between]: [new Date(filters.startDate), new Date(filters.endDate)],
    };
  }

  // Vehicle filters
  if (filters.vehicleIds?.length > 0) {
    where.vehicle_id = { [Op.in]: filters.vehicleIds };
  }
  if (filters.vehicleBrand) {
    where['$vehicle.brand$'] = filters.vehicleBrand;
  }
  if (filters.vehicleStatus) {
    where['$vehicle.status$'] = filters.vehicleStatus;
  }

  // Customer filters
  if (filters.customerIds?.length > 0) {
    where.customer_id = { [Op.in]: filters.customerIds };
  }
  if (filters.customerType) {
    where['$customer.customer_type$'] = filters.customerType;
  }

  // Contract filters
  if (filters.contractStatus) {
    where.status = filters.contractStatus;
  }

  // Revenue range
  if (filters.minRevenue || filters.maxRevenue) {
    where.total_amount = {};
    if (filters.minRevenue) where.total_amount[Op.gte] = filters.minRevenue;
    if (filters.maxRevenue) where.total_amount[Op.lte] = filters.maxRevenue;
  }

  return where;
};

// ============================================
// REPORT 1: Executive Summary
// ============================================
const generateExecutiveSummary = async (companyId, filters = {}) => {
  try {
    const startDate = new Date(filters.startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000));
    const endDate = new Date(filters.endDate || new Date());

    // Get dashboard KPIs
    const dashboardData = await analyticsService.getDashboardKPIs(companyId, startDate, endDate);

    // Get revenue breakdown
    const revenue = await analyticsService.calculateRevenue(companyId, startDate, endDate);

    // Get vehicle utilization
    const utilization = await analyticsService.calculateVehicleUtilization(companyId, startDate, endDate);
    const avgUtilization = utilization.reduce((sum, v) => sum + v.utilization_rate, 0) / utilization.length;

    // Get top customers
    const topCustomers = await Customer.findAll({
      where: { company_id: companyId },
      order: [['lifetime_value', 'DESC']],
      limit: 5,
      attributes: ['id', 'full_name', 'total_rentals', 'lifetime_value', 'customer_type'],
    });

    // Get alerts (vehicles needing maintenance)
    const maintenanceAlerts = await Vehicle.count({
      where: {
        company_id: companyId,
        [Op.or]: [
          sequelize.literal('mileage >= next_maintenance_mileage'),
          { status: 'maintenance' },
        ],
      },
    });

    // Compare with previous period
    const periodLength = endDate - startDate;
    const prevStartDate = new Date(startDate.getTime() - periodLength);
    const prevRevenue = await analyticsService.calculateRevenue(companyId, prevStartDate, startDate);
    
    const revenueGrowth = prevRevenue.total_revenue > 0
      ? ((revenue.total_revenue - prevRevenue.total_revenue) / prevRevenue.total_revenue) * 100
      : 0;

    return {
      report_type: 'executive_summary',
      generated_at: new Date(),
      period: {
        start: startDate,
        end: endDate,
        days: Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)),
      },
      summary: {
        total_revenue: revenue.total_revenue,
        revenue_growth: revenueGrowth,
        total_contracts: dashboardData.fleet.active_rentals,
        fleet_utilization: avgUtilization,
        active_customers: dashboardData.customers.total,
        new_customers: dashboardData.customers.new,
        maintenance_alerts: maintenanceAlerts,
      },
      revenue_breakdown: {
        total: revenue.total_revenue,
        average_transaction: revenue.average_transaction_value,
        payment_count: revenue.payment_count,
        by_method: revenue.revenue_by_method,
      },
      fleet_overview: {
        total_vehicles: dashboardData.fleet.total_vehicles,
        active_rentals: dashboardData.fleet.active_rentals,
        available: dashboardData.fleet.available_vehicles,
        maintenance: dashboardData.fleet.maintenance_vehicles,
        average_utilization: avgUtilization,
      },
      top_customers: topCustomers.map(c => ({
        name: c.full_name,
        type: c.customer_type,
        total_rentals: c.total_rentals,
        lifetime_value: parseFloat(c.lifetime_value),
      })),
      top_vehicles: dashboardData.top_vehicles.slice(0, 5),
      trends: revenue.revenue_by_day,
    };
  } catch (error) {
    console.error('ðŸ’¥ Generate executive summary error:', error);
    throw error;
  }
};

// ============================================
// REPORT 2: Vehicle Performance Report
// ============================================
const generateVehicleReport = async (companyId, filters = {}) => {
  try {
    const startDate = new Date(filters.startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000));
    const endDate = new Date(filters.endDate || new Date());

    // Get vehicle utilization
    const utilization = await analyticsService.calculateVehicleUtilization(companyId, startDate, endDate);

    // Get vehicle P&L
    const profitLoss = await analyticsService.calculateVehicleProfitLoss(companyId, startDate, endDate);

    // Apply filters
    let filteredVehicles = profitLoss;

    if (filters.minUtilization) {
      filteredVehicles = filteredVehicles.filter(v => v.utilization_rate >= filters.minUtilization);
    }
    if (filters.maxUtilization) {
      filteredVehicles = filteredVehicles.filter(v => v.utilization_rate <= filters.maxUtilization);
    }
    if (filters.vehicleBrand) {
      filteredVehicles = filteredVehicles.filter(v => v.brand === filters.vehicleBrand);
    }

    // Sort by selected metric
    const sortBy = filters.sortBy || 'profit';
    filteredVehicles.sort((a, b) => b[sortBy] - a[sortBy]);

    // Get top performers and bottom performers
    const topPerformers = filteredVehicles.slice(0, 5);
    const bottomPerformers = filteredVehicles.slice(-5).reverse();

    // Get maintenance alerts
    const maintenanceNeeded = await Vehicle.findAll({
      where: {
        company_id: companyId,
        [Op.or]: [
          sequelize.literal('mileage >= next_maintenance_mileage'),
          sequelize.literal('mileage - last_maintenance_mileage >= maintenance_interval_km'),
        ],
      },
      attributes: ['id', 'brand', 'model', 'registration_number', 'mileage', 'next_maintenance_mileage'],
    });

    // Calculate fleet totals
    const fleetTotals = {
      total_revenue: filteredVehicles.reduce((sum, v) => sum + v.total_revenue, 0),
      total_costs: filteredVehicles.reduce((sum, v) => sum + v.total_costs, 0),
      total_profit: filteredVehicles.reduce((sum, v) => sum + v.profit, 0),
      average_utilization: filteredVehicles.reduce((sum, v) => sum + v.utilization_rate, 0) / filteredVehicles.length,
    };

    return {
      report_type: 'vehicle_performance',
      generated_at: new Date(),
      period: {
        start: startDate,
        end: endDate,
        days: Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)),
      },
      fleet_summary: {
        total_vehicles: filteredVehicles.length,
        ...fleetTotals,
        profit_margin: fleetTotals.total_revenue > 0
          ? (fleetTotals.total_profit / fleetTotals.total_revenue) * 100
          : 0,
      },
      top_performers: topPerformers,
      bottom_performers: bottomPerformers,
      maintenance_alerts: maintenanceNeeded.map(v => ({
        registration: v.registration_number,
        vehicle: `${v.brand} ${v.model}`,
        current_mileage: v.mileage,
        next_maintenance: v.next_maintenance_mileage,
        km_overdue: Math.max(0, v.mileage - v.next_maintenance_mileage),
      })),
      all_vehicles: filteredVehicles,
    };
  } catch (error) {
    console.error('ðŸ’¥ Generate vehicle report error:', error);
    throw error;
  }
};

// ============================================
// REPORT 3: Customer Insights Report
// ============================================
const generateCustomerReport = async (companyId, filters = {}) => {
  try {
    const startDate = new Date(filters.startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000));
    const endDate = new Date(filters.endDate || new Date());

    // Get customer segmentation
    const segmentation = await analyticsService.segmentCustomers(companyId);

    // Get retention metrics
    const retention = await analyticsService.getCustomerRetention(companyId, startDate, endDate);

    // Get customer trends
    const customerTrends = await Contract.findAll({
      where: {
        company_id: companyId,
        start_date: { [Op.between]: [startDate, endDate] },
      },
      attributes: [
        [sequelize.fn('DATE', sequelize.col('start_date')), 'date'],
        [sequelize.fn('COUNT', sequelize.col('id')), 'bookings'],
        [sequelize.fn('AVG', sequelize.col('total_days')), 'avg_duration'],
      ],
      group: [sequelize.fn('DATE', sequelize.col('start_date'))],
      order: [[sequelize.fn('DATE', sequelize.col('start_date')), 'ASC']],
      raw: true,
    });

    // Get booking patterns (weekday vs weekend)
    const bookingPatterns = await Contract.findAll({
      where: {
        company_id: companyId,
        start_date: { [Op.between]: [startDate, endDate] },
      },
      attributes: [
        [sequelize.fn('EXTRACT', sequelize.literal("DOW FROM start_date")), 'day_of_week'],
        [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
      ],
      group: [sequelize.fn('EXTRACT', sequelize.literal("DOW FROM start_date"))],
      raw: true,
    });

    // Get corporate vs individual breakdown
    const typeBreakdown = await Contract.findAll({
      where: {
        company_id: companyId,
        start_date: { [Op.between]: [startDate, endDate] },
      },
      include: [
        {
          model: Customer,
          as: 'customer',
          attributes: ['customer_type'],
        },
      ],
      attributes: [
        [sequelize.col('customer.customer_type'), 'type'],
        [sequelize.fn('COUNT', sequelize.col('Contract.id')), 'count'],
        [sequelize.fn('SUM', sequelize.col('total_amount')), 'revenue'],
      ],
      group: [sequelize.col('customer.customer_type')],
      raw: true,
    });

    return {
      report_type: 'customer_insights',
      generated_at: new Date(),
      period: {
        start: startDate,
        end: endDate,
        days: Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)),
      },
      customer_segmentation: segmentation,
      retention_metrics: retention,
      booking_trends: customerTrends.map(t => ({
        date: t.date,
        bookings: parseInt(t.bookings),
        avg_duration: parseFloat(t.avg_duration).toFixed(1),
      })),
      booking_patterns: {
        by_weekday: bookingPatterns.map(p => ({
          day: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][p.day_of_week],
          count: parseInt(p.count),
        })),
        by_customer_type: typeBreakdown.map(t => ({
          type: t.type,
          bookings: parseInt(t.count),
          revenue: parseFloat(t.revenue),
        })),
      },
    };
  } catch (error) {
    console.error('ðŸ’¥ Generate customer report error:', error);
    throw error;
  }
};

// ============================================
// MAIN: Generate Report
// ============================================
const generateReport = async (companyId, reportType, filters = {}) => {
  try {
    console.log(`ðŸ“Š Generating ${reportType} report for company ${companyId}`);

    let report;

    switch (reportType) {
      case 'executive':
        report = await generateExecutiveSummary(companyId, filters);
        break;
      case 'vehicle':
        report = await generateVehicleReport(companyId, filters);
        break;
      case 'customer':
        report = await generateCustomerReport(companyId, filters);
        break;
      default:
        throw new Error(`Unknown report type: ${reportType}`);
    }

    return report;
  } catch (error) {
    console.error('ðŸ’¥ Generate report error:', error);
    throw error;
  }
};

module.exports = {
  generateReport,
  generateExecutiveSummary,
  generateVehicleReport,
  generateCustomerReport,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\services\storage.service.js



//   [Folder] utils


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\utils\bcrypt.util.js
// src/utils/bcrypt.util.js
const bcrypt = require('bcryptjs');

// Salt rounds (higher = more secure, but slower; 10-12 is standard)
const SALT_ROUNDS = 12;

/**
 * Hash a plain password
 * @param {string} password - Plain text password
 * @returns {string} Hashed password
 */
const hashPassword = async (password) => {
  if (!password || typeof password !== 'string') {
    throw new Error('Invalid password provided');
  }
  return await bcrypt.hash(password, SALT_ROUNDS);
};

/**
 * Compare plain password with hashed one
 * @param {string} password - Plain text password
 * @param {string} hash - Hashed password from DB
 * @returns {boolean} True if match
 */
const comparePassword = async (password, hash) => {
  if (!password || !hash) {
    throw new Error('Password or hash missing');
  }
  return await bcrypt.compare(password, hash);
};

module.exports = {
  hashPassword,
  comparePassword,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\utils\chartGenerator.util.js
// src/utils/chartGenerator.util.js
const { Chart } = require('chart.js/auto');
const { createCanvas } = require('canvas');

/**
 * Chart Generator Utility
 * Generates chart images for PDF reports using Chart.js
 */

// ============================================
// HELPER: Create Chart Canvas
// ============================================
const createChartCanvas = (width = 800, height = 400) => {
  return createCanvas(width, height);
};

// ============================================
// CHART 1: Revenue Trend Line Chart
// ============================================
const generateRevenueTrendChart = async (revenueByDay) => {
  const canvas = createChartCanvas();
  const ctx = canvas.getContext('2d');

  const labels = revenueByDay.map(d => new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
  const data = revenueByDay.map(d => d.revenue);

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: 'Daily Revenue (DZD)',
        data: data,
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        borderWidth: 3,
        fill: true,
        tension: 0.4,
        pointRadius: 4,
        pointHoverRadius: 6,
      }],
    },
    options: {
      responsive: false,
      plugins: {
        legend: {
          display: true,
          position: 'top',
          labels: {
            font: { size: 14, weight: 'bold' },
            color: '#111827',
          },
        },
        title: {
          display: true,
          text: 'Revenue Trend Over Time',
          font: { size: 18, weight: 'bold' },
          color: '#111827',
          padding: 20,
        },
      },
      scales: {
        x: {
          grid: { display: false },
          ticks: {
            font: { size: 12 },
            color: '#6b7280',
          },
        },
        y: {
          beginAtZero: true,
          grid: { color: '#e5e7eb' },
          ticks: {
            font: { size: 12 },
            color: '#6b7280',
            callback: (value) => value.toLocaleString() + ' DA',
          },
        },
      },
    },
  });

  return canvas.toBuffer('image/png');
};

// ============================================
// CHART 2: Payment Methods Pie Chart
// ============================================
const generatePaymentMethodsChart = async (revenueByMethod) => {
  const canvas = createChartCanvas(600, 400);
  const ctx = canvas.getContext('2d');

  const labels = revenueByMethod.map(m => m.method.charAt(0).toUpperCase() + m.method.slice(1));
  const data = revenueByMethod.map(m => m.amount);
  
  const colors = [
    '#3b82f6', // Blue
    '#10b981', // Green
    '#f59e0b', // Amber
    '#ef4444', // Red
    '#8b5cf6', // Purple
  ];

  new Chart(ctx, {
    type: 'pie',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: colors.slice(0, data.length),
        borderColor: '#ffffff',
        borderWidth: 3,
      }],
    },
    options: {
      responsive: false,
      plugins: {
        legend: {
          display: true,
          position: 'right',
          labels: {
            font: { size: 14 },
            color: '#111827',
            padding: 15,
          },
        },
        title: {
          display: true,
          text: 'Revenue by Payment Method',
          font: { size: 18, weight: 'bold' },
          color: '#111827',
          padding: 20,
        },
        tooltip: {
          callbacks: {
            label: (context) => {
              const label = context.label || '';
              const value = context.parsed || 0;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const percentage = ((value / total) * 100).toFixed(1);
              return `${label}: ${value.toLocaleString()} DA (${percentage}%)`;
            },
          },
        },
      },
    },
  });

  return canvas.toBuffer('image/png');
};

// ============================================
// CHART 3: Vehicle Utilization Bar Chart
// ============================================
const generateVehicleUtilizationChart = async (vehicles) => {
  const canvas = createChartCanvas(800, 500);
  const ctx = canvas.getContext('2d');

  // Take top 10 vehicles
  const topVehicles = vehicles.slice(0, 10);
  const labels = topVehicles.map(v => `${v.brand} ${v.model}\n${v.registration_number}`);
  const data = topVehicles.map(v => v.utilization_rate);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: 'Utilization Rate (%)',
        data: data,
        backgroundColor: data.map(rate => {
          if (rate >= 80) return '#10b981'; // Green - High
          if (rate >= 60) return '#3b82f6'; // Blue - Medium
          if (rate >= 40) return '#f59e0b'; // Amber - Low
          return '#ef4444'; // Red - Very Low
        }),
        borderColor: '#ffffff',
        borderWidth: 2,
      }],
    },
    options: {
      responsive: false,
      plugins: {
        legend: {
          display: false,
        },
        title: {
          display: true,
          text: 'Top 10 Vehicles by Utilization Rate',
          font: { size: 18, weight: 'bold' },
          color: '#111827',
          padding: 20,
        },
        tooltip: {
          callbacks: {
            label: (context) => `${context.parsed.y.toFixed(1)}%`,
          },
        },
      },
      scales: {
        x: {
          grid: { display: false },
          ticks: {
            font: { size: 10 },
            color: '#6b7280',
            maxRotation: 45,
            minRotation: 45,
          },
        },
        y: {
          beginAtZero: true,
          max: 100,
          grid: { color: '#e5e7eb' },
          ticks: {
            font: { size: 12 },
            color: '#6b7280',
            callback: (value) => value + '%',
          },
        },
      },
    },
  });

  return canvas.toBuffer('image/png');
};

// ============================================
// CHART 4: Fleet Status Doughnut Chart
// ============================================
const generateFleetStatusChart = async (fleetOverview) => {
  const canvas = createChartCanvas(600, 400);
  const ctx = canvas.getContext('2d');

  const labels = ['Available', 'Rented', 'Maintenance'];
  const data = [
    fleetOverview.available,
    fleetOverview.active_rentals,
    fleetOverview.maintenance,
  ];

  const colors = ['#10b981', '#3b82f6', '#f59e0b'];

  new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: colors,
        borderColor: '#ffffff',
        borderWidth: 3,
      }],
    },
    options: {
      responsive: false,
      plugins: {
        legend: {
          display: true,
          position: 'right',
          labels: {
            font: { size: 14 },
            color: '#111827',
            padding: 15,
          },
        },
        title: {
          display: true,
          text: 'Fleet Status Distribution',
          font: { size: 18, weight: 'bold' },
          color: '#111827',
          padding: 20,
        },
        tooltip: {
          callbacks: {
            label: (context) => {
              const label = context.label || '';
              const value = context.parsed || 0;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const percentage = ((value / total) * 100).toFixed(1);
              return `${label}: ${value} vehicles (${percentage}%)`;
            },
          },
        },
      },
    },
  });

  return canvas.toBuffer('image/png');
};

// ============================================
// CHART 5: Customer Segmentation Bar Chart
// ============================================
const generateCustomerSegmentationChart = async (segments) => {
  const canvas = createChartCanvas(700, 400);
  const ctx = canvas.getContext('2d');

  const labels = ['VIP', 'High Value', 'Medium Value', 'Low Value'];
  const counts = [
    segments.vip.count,
    segments.high_value.count,
    segments.medium_value.count,
    segments.low_value.count,
  ];
  const values = [
    segments.vip.total_value,
    segments.high_value.total_value,
    segments.medium_value.total_value,
    segments.low_value.total_value,
  ];

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'Customer Count',
          data: counts,
          backgroundColor: '#3b82f6',
          borderColor: '#ffffff',
          borderWidth: 2,
          yAxisID: 'y',
        },
        {
          label: 'Total Value (DZD)',
          data: values,
          backgroundColor: '#10b981',
          borderColor: '#ffffff',
          borderWidth: 2,
          yAxisID: 'y1',
        },
      ],
    },
    options: {
      responsive: false,
      plugins: {
        legend: {
          display: true,
          position: 'top',
          labels: {
            font: { size: 14 },
            color: '#111827',
          },
        },
        title: {
          display: true,
          text: 'Customer Segmentation by Value',
          font: { size: 18, weight: 'bold' },
          color: '#111827',
          padding: 20,
        },
      },
      scales: {
        x: {
          grid: { display: false },
          ticks: {
            font: { size: 12 },
            color: '#6b7280',
          },
        },
        y: {
          type: 'linear',
          display: true,
          position: 'left',
          beginAtZero: true,
          grid: { color: '#e5e7eb' },
          ticks: {
            font: { size: 12 },
            color: '#6b7280',
          },
          title: {
            display: true,
            text: 'Number of Customers',
            font: { size: 12, weight: 'bold' },
            color: '#6b7280',
          },
        },
        y1: {
          type: 'linear',
          display: true,
          position: 'right',
          beginAtZero: true,
          grid: { display: false },
          ticks: {
            font: { size: 12 },
            color: '#6b7280',
            callback: (value) => (value / 1000).toFixed(0) + 'K',
          },
          title: {
            display: true,
            text: 'Total Value (DZD)',
            font: { size: 12, weight: 'bold' },
            color: '#6b7280',
          },
        },
      },
    },
  });

  return canvas.toBuffer('image/png');
};

// ============================================
// CHART 6: Booking Patterns by Weekday
// ============================================
const generateBookingPatternsChart = async (bookingsByWeekday) => {
  const canvas = createChartCanvas(700, 400);
  const ctx = canvas.getContext('2d');

  const labels = bookingsByWeekday.map(d => d.day);
  const data = bookingsByWeekday.map(d => d.count);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: 'Number of Bookings',
        data: data,
        backgroundColor: '#8b5cf6',
        borderColor: '#ffffff',
        borderWidth: 2,
      }],
    },
    options: {
      responsive: false,
      plugins: {
        legend: {
          display: false,
        },
        title: {
          display: true,
          text: 'Booking Patterns by Day of Week',
          font: { size: 18, weight: 'bold' },
          color: '#111827',
          padding: 20,
        },
      },
      scales: {
        x: {
          grid: { display: false },
          ticks: {
            font: { size: 12 },
            color: '#6b7280',
          },
        },
        y: {
          beginAtZero: true,
          grid: { color: '#e5e7eb' },
          ticks: {
            font: { size: 12 },
            color: '#6b7280',
          },
        },
      },
    },
  });

  return canvas.toBuffer('image/png');
};

// ============================================
// MAIN: Generate Charts Based on Report Type
// ============================================
const generateChartsForReport = async (report, reportType) => {
  const charts = {};

  try {
    if (reportType === 'executive') {
      // Revenue trend chart
      if (report.trends && report.trends.length > 0) {
        charts.revenueTrend = await generateRevenueTrendChart(report.trends);
      }

      // Payment methods pie chart
      if (report.revenue_breakdown?.by_method && report.revenue_breakdown.by_method.length > 0) {
        charts.paymentMethods = await generatePaymentMethodsChart(report.revenue_breakdown.by_method);
      }

      // Fleet status doughnut chart
      if (report.fleet_overview) {
        charts.fleetStatus = await generateFleetStatusChart(report.fleet_overview);
      }

      // Top vehicles utilization
      if (report.top_vehicles && report.top_vehicles.length > 0) {
        charts.vehicleUtilization = await generateVehicleUtilizationChart(report.top_vehicles);
      }
    } else if (reportType === 'vehicle') {
      // Vehicle utilization bar chart
      if (report.all_vehicles && report.all_vehicles.length > 0) {
        charts.vehicleUtilization = await generateVehicleUtilizationChart(report.all_vehicles);
      }
    } else if (reportType === 'customer') {
      // Customer segmentation chart
      if (report.customer_segmentation?.segments) {
        charts.customerSegmentation = await generateCustomerSegmentationChart(
          report.customer_segmentation.segments
        );
      }

      // Booking patterns chart
      if (report.booking_patterns?.by_weekday) {
        charts.bookingPatterns = await generateBookingPatternsChart(
          report.booking_patterns.by_weekday
        );
      }
    }

    return charts;
  } catch (error) {
    console.error('ðŸ’¥ Chart generation error:', error);
    return {};
  }
};

module.exports = {
  generateChartsForReport,
  generateRevenueTrendChart,
  generatePaymentMethodsChart,
  generateVehicleUtilizationChart,
  generateFleetStatusChart,
  generateCustomerSegmentationChart,
  generateBookingPatternsChart,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\utils\jwt.util.js
// src/utils/jwt.util.js
const jwt = require('jsonwebtoken');
require('dotenv').config();

// JWT secrets (from .env: JWT_ACCESS_SECRET, JWT_REFRESH_SECRET)
const ACCESS_SECRET = process.env.JWT_ACCESS_SECRET || 'your-access-secret-fallback';
const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'your-refresh-secret-fallback';

// Token options
const ACCESS_TOKEN_OPTIONS = {
  expiresIn: '15m', // Short-lived for security
};
const REFRESH_TOKEN_OPTIONS = {
  expiresIn: '7d', // Longer for session persistence
};

// Generate access token
const generateAccessToken = (payload) => {
  return jwt.sign(payload, ACCESS_SECRET, ACCESS_TOKEN_OPTIONS);
};

// Generate refresh token
const generateRefreshToken = (payload) => {
  return jwt.sign(payload, REFRESH_SECRET, REFRESH_TOKEN_OPTIONS);
};

// Verify access token
const verifyAccessToken = (token) => {
  try {
    return jwt.verify(token, ACCESS_SECRET);
  } catch (error) {
    throw new Error('Invalid access token');
  }
};

// Verify refresh token
const verifyRefreshToken = (token) => {
  try {
    return jwt.verify(token, REFRESH_SECRET);
  } catch (error) {
    throw new Error('Invalid refresh token');
  }
};

// Generate both tokens (for login/register)
const generateTokens = (user) => {
  const payload = {
    id: user.id,
    email: user.email,
    role: user.role,
    company_id: user.company_id,
  };
  return {
    accessToken: generateAccessToken(payload),
    refreshToken: generateRefreshToken(payload),
  };
};

module.exports = {
  generateAccessToken,
  generateRefreshToken,
  verifyAccessToken,
  verifyRefreshToken,
  generateTokens,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\utils\pdfGenerator.util.js
// src/utils/pdfGenerator.util.js
const puppeteer = require('puppeteer');
const { generateChartsForReport } = require('./chartGenerator.util');

/**
 * Generate HTML content for report with embedded charts
 */
const generateReportHTML = (report, type, charts = {}) => {
  const styles = `
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 40px;
        color: #333;
      }
      .header {
        text-align: center;
        margin-bottom: 40px;
        border-bottom: 3px solid #3b82f6;
        padding-bottom: 20px;
      }
      .header h1 {
        color: #3b82f6;
        margin: 0;
      }
      .header .subtitle {
        color: #6b7280;
        margin-top: 10px;
      }
      .summary-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        margin-bottom: 40px;
      }
      .summary-card {
        background: #f3f4f6;
        padding: 20px;
        border-radius: 8px;
        border-left: 4px solid #3b82f6;
      }
      .summary-card h3 {
        margin: 0 0 10px 0;
        color: #6b7280;
        font-size: 14px;
        font-weight: normal;
      }
      .summary-card .value {
        font-size: 28px;
        font-weight: bold;
        color: #111827;
      }
      .summary-card .change {
        font-size: 14px;
        margin-top: 5px;
      }
      .change.positive { color: #10b981; }
      .change.negative { color: #ef4444; }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
      }
      th {
        background: #3b82f6;
        color: white;
        padding: 12px;
        text-align: left;
        font-weight: 600;
      }
      td {
        padding: 12px;
        border-bottom: 1px solid #e5e7eb;
      }
      tr:hover {
        background: #f9fafb;
      }
      .section {
        margin: 40px 0;
      }
      .section h2 {
        color: #111827;
        border-bottom: 2px solid #e5e7eb;
        padding-bottom: 10px;
        margin-bottom: 20px;
      }
      .footer {
        margin-top: 60px;
        text-align: center;
        color: #6b7280;
        font-size: 12px;
        border-top: 1px solid #e5e7eb;
        padding-top: 20px;
      }
      .chart-container {
        margin: 30px 0;
        text-align: center;
      }
      .chart-container img {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
    </style>
  `;

  let content = '';

  if (type === 'executive') {
    content = `
      <div class="header">
        <h1>Executive Summary Report</h1>
        <div class="subtitle">
          Period: ${new Date(report.period.start).toLocaleDateString()} - ${new Date(report.period.end).toLocaleDateString()}
        </div>
        <div class="subtitle">Generated: ${new Date(report.generated_at).toLocaleString()}</div>
      </div>

      <div class="summary-grid">
        <div class="summary-card">
          <h3>Total Revenue</h3>
          <div class="value">${report.summary.total_revenue.toLocaleString()} DA</div>
          <div class="change ${report.summary.revenue_growth >= 0 ? 'positive' : 'negative'}">
            ${report.summary.revenue_growth >= 0 ? 'â†‘' : 'â†“'} ${Math.abs(report.summary.revenue_growth).toFixed(1)}%
          </div>
        </div>
        <div class="summary-card">
          <h3>Fleet Utilization</h3>
          <div class="value">${report.summary.fleet_utilization.toFixed(1)}%</div>
        </div>
        <div class="summary-card">
          <h3>Active Contracts</h3>
          <div class="value">${report.summary.total_contracts}</div>
        </div>
        <div class="summary-card">
          <h3>Active Customers</h3>
          <div class="value">${report.summary.active_customers}</div>
        </div>
        <div class="summary-card">
          <h3>New Customers</h3>
          <div class="value">${report.summary.new_customers}</div>
        </div>
        <div class="summary-card">
          <h3>Maintenance Alerts</h3>
          <div class="value">${report.summary.maintenance_alerts}</div>
        </div>
      </div>

      <div class="section">
        <h2>Top Performing Vehicles</h2>
        <table>
          <thead>
            <tr>
              <th>Vehicle</th>
              <th>Registration</th>
              <th>Utilization</th>
              <th>Revenue</th>
            </tr>
          </thead>
          <tbody>
            ${report.top_vehicles.map(v => `
              <tr>
                <td>${v.brand} ${v.model}</td>
                <td>${v.registration_number}</td>
                <td>${v.utilization_rate.toFixed(1)}%</td>
                <td>${v.total_revenue.toLocaleString()} DA</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>

      <div class="section">
        <h2>Top Customers</h2>
        <table>
          <thead>
            <tr>
              <th>Name</th>
              <th>Type</th>
              <th>Total Rentals</th>
              <th>Lifetime Value</th>
            </tr>
          </thead>
          <tbody>
            ${report.top_customers.map(c => `
              <tr>
                <td>${c.name}</td>
                <td>${c.type}</td>
                <td>${c.total_rentals}</td>
                <td>${c.lifetime_value.toLocaleString()} DA</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;
  } else if (type === 'vehicle') {
    content = `
      <div class="header">
        <h1>Vehicle Performance Report</h1>
        <div class="subtitle">
          Period: ${new Date(report.period.start).toLocaleDateString()} - ${new Date(report.period.end).toLocaleDateString()}
        </div>
        <div class="subtitle">Generated: ${new Date(report.generated_at).toLocaleString()}</div>
      </div>

      <div class="summary-grid">
        <div class="summary-card">
          <h3>Total Revenue</h3>
          <div class="value">${report.fleet_summary.total_revenue.toLocaleString()} DA</div>
        </div>
        <div class="summary-card">
          <h3>Total Profit</h3>
          <div class="value">${report.fleet_summary.total_profit.toLocaleString()} DA</div>
        </div>
        <div class="summary-card">
          <h3>Profit Margin</h3>
          <div class="value">${report.fleet_summary.profit_margin.toFixed(1)}%</div>
        </div>
      </div>

      <div class="section">
        <h2>Top Performers</h2>
        <table>
          <thead>
            <tr>
              <th>Vehicle</th>
              <th>Registration</th>
              <th>Utilization</th>
              <th>Revenue</th>
              <th>Profit</th>
            </tr>
          </thead>
          <tbody>
            ${report.top_performers.map(v => `
              <tr>
                <td>${v.brand} ${v.model}</td>
                <td>${v.registration_number}</td>
                <td>${v.utilization_rate.toFixed(1)}%</td>
                <td>${v.total_revenue.toLocaleString()} DA</td>
                <td>${v.profit.toLocaleString()} DA</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>

      <div class="section">
        <h2>Maintenance Alerts</h2>
        <table>
          <thead>
            <tr>
              <th>Vehicle</th>
              <th>Registration</th>
              <th>Current Mileage</th>
              <th>KM Overdue</th>
            </tr>
          </thead>
          <tbody>
            ${report.maintenance_alerts.map(v => `
              <tr>
                <td>${v.vehicle}</td>
                <td>${v.registration}</td>
                <td>${v.current_mileage.toLocaleString()} km</td>
                <td style="color: ${v.km_overdue > 0 ? '#ef4444' : '#10b981'}">
                  ${v.km_overdue > 0 ? v.km_overdue : 0} km
                </td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;
  } else if (type === 'customer') {
    content = `
      <div class="header">
        <h1>Customer Insights Report</h1>
        <div class="subtitle">
          Period: ${new Date(report.period.start).toLocaleDateString()} - ${new Date(report.period.end).toLocaleDateString()}
        </div>
        <div class="subtitle">Generated: ${new Date(report.generated_at).toLocaleString()}</div>
      </div>

      <div class="summary-grid">
        <div class="summary-card">
          <h3>Total Customers</h3>
          <div class="value">${report.customer_segmentation.total_customers}</div>
        </div>
        <div class="summary-card">
          <h3>New Customers</h3>
          <div class="value">${report.retention_metrics.new_customers}</div>
        </div>
        <div class="summary-card">
          <h3>Retention Rate</h3>
          <div class="value">${report.retention_metrics.retention_rate.toFixed(1)}%</div>
        </div>
      </div>

      <div class="section">
        <h2>Customer Segmentation</h2>
        <table>
          <thead>
            <tr>
              <th>Segment</th>
              <th>Customer Count</th>
              <th>Total Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>VIP (Platinum)</td>
              <td>${report.customer_segmentation.segments.vip.count}</td>
              <td>${report.customer_segmentation.segments.vip.total_value.toLocaleString()} DA</td>
            </tr>
            <tr>
              <td>High Value (Gold)</td>
              <td>${report.customer_segmentation.segments.high_value.count}</td>
              <td>${report.customer_segmentation.segments.high_value.total_value.toLocaleString()} DA</td>
            </tr>
            <tr>
              <td>Medium Value (Silver)</td>
              <td>${report.customer_segmentation.segments.medium_value.count}</td>
              <td>${report.customer_segmentation.segments.medium_value.total_value.toLocaleString()} DA</td>
            </tr>
            <tr>
              <td>Low Value (Bronze)</td>
              <td>${report.customer_segmentation.segments.low_value.count}</td>
              <td>${report.customer_segmentation.segments.low_value.total_value.toLocaleString()} DA</td>
            </tr>
          </tbody>
        </table>
      </div>
    `;
  }

  // Add charts section for executive report
  if (type === 'executive') {
    if (charts.revenueTrend) {
      content += `
        <div class="section">
          <h2>Revenue Trend Analysis</h2>
          <div class="chart-container">
            <img src="data:image/png;base64,${charts.revenueTrend.toString('base64')}" alt="Revenue Trend Chart" />
          </div>
        </div>
      `;
    }
    
    if (charts.paymentMethods) {
      content += `
        <div class="section">
          <h2>Payment Methods Distribution</h2>
          <div class="chart-container">
            <img src="data:image/png;base64,${charts.paymentMethods.toString('base64')}" alt="Payment Methods Chart" />
          </div>
        </div>
      `;
    }
    
    if (charts.fleetStatus) {
      content += `
        <div class="section">
          <h2>Fleet Status Overview</h2>
          <div class="chart-container">
            <img src="data:image/png;base64,${charts.fleetStatus.toString('base64')}" alt="Fleet Status Chart" />
          </div>
        </div>
      `;
    }
  }

  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <title>${type} Report</title>
      ${styles}
    </head>
    <body>
      ${content}
      <div class="footer">
        Car Rental Management System | Report generated on ${new Date().toLocaleString()}
      </div>
    </body>
    </html>
  `;
};

/**
 * Generate PDF from HTML
 */
const generateReportPDF = async (report, type) => {
  let browser;
  try {
    // Generate charts first
    console.log('ðŸ“Š Generating charts for report...');
    const charts = await generateChartsForReport(report, type);
    console.log('âœ… Charts generated:', Object.keys(charts));

    // Generate HTML with embedded charts
    const html = generateReportHTML(report, type, charts);

    browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox'],
    });

    const page = await browser.newPage();
    await page.setContent(html, { waitUntil: 'networkidle0' });

    const pdfBuffer = await page.pdf({
      format: 'A4',
      printBackground: true,
      margin: {
        top: '20px',
        right: '20px',
        bottom: '20px',
        left: '20px',
      },
    });

    return pdfBuffer;
  } catch (error) {
    console.error('ðŸ’¥ PDF generation error:', error);
    throw error;
  } finally {
    if (browser) {
      await browser.close();
    }
  }
};

module.exports = {
  generateReportPDF,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\utils\response.util.js
// src/utils/response.util.js

/**
 * Send success response
 * @param {object} res - Express response object
 * @param {number} statusCode - HTTP status (default 200)
 * @param {string} message - Success message
 * @param {any} data - Optional data payload
 * @param {object} meta - Optional metadata (e.g., { pagination: { page, limit } })
 */
const sendSuccess = (res, { statusCode = 200, message = 'Success', data = null, meta = null }) => {
  const response = {
    success: true,
    message,
    ...(data && { data }),
    ...(meta && { meta }),
  };
  res.status(statusCode).json(response);
};

/**
 * Send error response
 * @param {object} res - Express response object
 * @param {number} statusCode - HTTP status (default 400)
 * @param {string} message - Error message
 * @param {string} [code] - Optional error code (e.g., 'VALIDATION_ERROR')
 * @param {any} [details] - Optional error details
 */
const sendError = (res, { statusCode = 400, message = 'Bad Request', code = null, details = null }) => {
  const response = {
    success: false,
    message,
    ...(code && { code }),
    ...(details && { details }),
  };
  res.status(statusCode).json(response);
};

/**
 * Send validation error (for express-validator)
 * @param {object} res - Express response object
 * @param {array} errors - Array of validation errors
 */
const sendValidationError = (res, errors) => {
  sendError(res, {
    statusCode: 422,
    message: 'Validation failed',
    code: 'VALIDATION_ERROR',
    details: errors,
  });
};

module.exports = {
  sendSuccess,
  sendError,
  sendValidationError,
};

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\utils\validators.util.js



// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\src\app.js
// src/app.js (UPDATED WITH ALL NEW ROUTES)
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
require('dotenv').config();

// Import routes
const authRoutes = require('./routes/auth.routes');
const companyRoutes = require('./routes/company.routes');
const protectedCompanyRoutes = require('./routes/companyProfile.routes');
const vehicleRoutes = require('./routes/vehicle.routes');
const customerRoutes = require('./routes/customer.routes');
const contractRoutes = require('./routes/contract.routes');
const paymentRoutes = require('./routes/payment.routes');
const analyticsRoutes = require('./routes/analytics.routes');
const employeeRoutes = require('./routes/employee.routes');
const reportsRoutes = require('./routes/reports.routes');
const notificationsRoutes = require('./routes/notifications.routes');
const attendanceRoutes = require('./routes/attendance.routes');
const payrollRoutes = require('./routes/payroll.routes');
const adminRoutes = require('./routes/admin.routes');

const app = express();

// 1. Security headers (Helmet)
app.use(helmet());

// 2. CORS (Cross-Origin Resource Sharing)
const FRONTEND_URL = process.env.FRONTEND_URL || 'http://localhost:3000';
app.use(cors({
  origin: FRONTEND_URL,
  optionsSuccessStatus: 200,
}));

// 3. Logging (Morgan)
const NODE_ENV = process.env.NODE_ENV || 'development';
app.use(morgan(NODE_ENV === 'development' ? 'dev' : 'combined'));

// 4. Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// ============================================
// HEALTH CHECK ROUTES
// ============================================
app.get('/', (req, res) => {
  res.json({ 
    status: 'ok', 
    message: 'Car Rental API Server',
    version: '2.0.0',
    features: [
      'Vehicle Limit Monitoring',
      'Maintenance Alerts',
      'KM Limit Tracking',
      'Loyalty Tier System',
      'Overage Charges',
    ],
  });
});

app.get('/api/ping', (req, res) => {
  res.json({ pong: true, timestamp: new Date().toISOString() });
});

// ============================================
// API ROUTES
// ============================================


console.log({
  authRoutes: typeof authRoutes,
  companyRoutes: typeof companyRoutes,
  protectedCompanyRoutes: typeof protectedCompanyRoutes,
  vehicleRoutes: typeof vehicleRoutes,
  customerRoutes: typeof customerRoutes,
  contractRoutes: typeof contractRoutes,
  paymentRoutes: typeof paymentRoutes,
  analyticsRoutes: typeof analyticsRoutes,
  employeeRoutes: typeof employeeRoutes,
  reportsRoutes: typeof reportsRoutes,
});


app.use('/api/auth', authRoutes);
app.use('/api/companies', companyRoutes);
app.use('/api/company', protectedCompanyRoutes);
app.use('/api/vehicles', vehicleRoutes);
app.use('/api/customers', customerRoutes);
app.use('/api/contracts', contractRoutes);
app.use('/api/payments', paymentRoutes);
app.use('/api/analytics', analyticsRoutes);
app.use('/api/employees', employeeRoutes);
app.use('/api/reports', reportsRoutes);
app.use('/api/notifications', notificationsRoutes);
app.use('/api/attendance', attendanceRoutes);
app.use('/api/payroll', payrollRoutes);
app.use('/api/admin', adminRoutes);

// ============================================
// ERROR HANDLERS
// ============================================

// 404 Handler
app.use((req, res, next) => {
  res.status(404).json({ 
    success: false,
    error: 'Not Found', 
    path: req.originalUrl,
    message: 'The requested resource does not exist',
  });
});

// Global Error Handler
app.use((err, req, res, next) => {
  console.error('âŒ Server Error:', err);
  const isDev = NODE_ENV === 'development';
  
  res.status(err.status || 500).json({
    success: false,
    error: err.message || 'Internal Server Error',
    ...(isDev && { stack: err.stack }),
  });
});

module.exports = app;


// [Folder] tests


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\tests\analytics.test.js


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\tests\auth.test.js


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\tests\vehicles.test.js



// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\check-enum.js
const { Sequelize } = require('sequelize');

const DATABASE_URL = process.env.DATABASE_URL;

const sequelize = new Sequelize(DATABASE_URL, {
  dialect: 'postgres',
  dialectOptions: {
    ssl: {
      require: true,
      rejectUnauthorized: false
    }
  },
  logging: false,
});

async function checkEnum() {
  try {
    await sequelize.authenticate();
    console.log('âœ… Connected');
    
    const [result] = await sequelize.query(`
  SELECT unnest(enum_range(NULL::enum_employees_role)) AS role_value;
`);
    
    console.log('Valid role values in database:');
    result.forEach(r => console.log('  -', r.role_value));
    
  } catch (error) {
    console.error('Error:', error.message);
  } finally {
    await sequelize.close();
  }
}

checkEnum();

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\package.json
{
  "name": "car-rental-backend",
  "version": "1.0.0",
  "main": "index.js",
  "directories": {
    "test": "tests"
  },
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "build": "npm install",
    "init-db": "node scripts/init-db.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "axios": "^1.13.4",
    "bcryptjs": "^3.0.3",
    "canvas": "^3.2.1",
    "chart.js": "^4.5.1",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "exceljs": "^4.4.0",
    "express": "^5.2.1",
    "express-validator": "^7.3.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.3",
    "morgan": "^1.10.1",
    "multer": "^2.0.2",
    "node-cron": "^4.2.1",
    "nodemailer": "^7.0.11",
    "pg": "^8.16.3",
    "pg-hstore": "^2.3.4",
    "puppeteer": "^24.33.0",
    "sequelize": "^6.37.7"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.1.11",
    "sequelize-cli": "^6.6.5",
    "supertest": "^7.1.4"
  }
}


// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\seed-demo-data.js
// seed-demo-data.js - Clear ALL data and reseed from scratch
const { Sequelize } = require('sequelize');
const bcrypt = require('bcryptjs');

const DATABASE_URL = process.env.DATABASE_URL;

const sequelize = new Sequelize(DATABASE_URL, {
  dialect: 'postgres',
  dialectOptions: {
    ssl: {
      require: true,
      rejectUnauthorized: false
    }
  },
  logging: false,
});

// Helper functions
const randomDate = (start, end) => {
  return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
};

const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

const randomElement = (array) => array[Math.floor(Math.random() * array.length)];

async function resetAndSeed() {
  try {
    console.log('ðŸŒ± Starting database reset and seeding...');
    await sequelize.authenticate();
    console.log('âœ… Database connected');

    // Get demo company
    const companies = await sequelize.query(`
      SELECT id FROM companies WHERE email = 'demo@example.com' LIMIT 1
    `, { type: sequelize.QueryTypes.SELECT });

    if (!companies || companies.length === 0) {
      console.error('âŒ Demo company not found. Run init-db.js first!');
      process.exit(1);
    }

    const companyId = companies[0].id;
    console.log(`âœ… Found demo company: ${companyId}`);

    // Get demo user
    const users = await sequelize.query(`
      SELECT id FROM users WHERE email = 'demo@demo.com' LIMIT 1
    `, { type: sequelize.QueryTypes.SELECT });
    const userId = users[0].id;

    // ============================================
    // STEP 1: DELETE ALL OLD SEED DATA
    // ============================================
    console.log('\nðŸ—‘ï¸  CLEARING OLD DATA...');
    
    // Delete in correct order (foreign key constraints)
    await sequelize.query(`DELETE FROM notifications WHERE company_id = :companyId`, { replacements: { companyId } });
    console.log('   âœ… Cleared notifications');
    
    await sequelize.query(`DELETE FROM vehicle_costs WHERE vehicle_id IN (SELECT id FROM vehicles WHERE company_id = :companyId)`, { replacements: { companyId } });
    console.log('   âœ… Cleared vehicle costs');
    
    await sequelize.query(`DELETE FROM payments WHERE company_id = :companyId`, { replacements: { companyId } });
    console.log('   âœ… Cleared payments');
    
    await sequelize.query(`DELETE FROM contracts WHERE company_id = :companyId`, { replacements: { companyId } });
    console.log('   âœ… Cleared contracts');
    
    await sequelize.query(`DELETE FROM customers WHERE company_id = :companyId`, { replacements: { companyId } });
    console.log('   âœ… Cleared customers');
    
    await sequelize.query(`DELETE FROM vehicles WHERE company_id = :companyId`, { replacements: { companyId } });
    console.log('   âœ… Cleared vehicles');
    
    await sequelize.query(`DELETE FROM employees WHERE company_id = :companyId`, { replacements: { companyId } });
    console.log('   âœ… Cleared employees');
    
    // Delete employee user accounts (NOT the main demo@demo.com user)
    await sequelize.query(`DELETE FROM users WHERE company_id = :companyId AND email != 'demo@demo.com'`, { replacements: { companyId } });
    console.log('   âœ… Cleared employee users');

    console.log('\nâœ… OLD DATA CLEARED!\n');

    // ============================================
    // STEP 2: CREATE NEW SEED DATA
    // ============================================
    
    // 1. CREATE EMPLOYEES
    console.log('ðŸ‘¥ Creating employees...');
    
    const employeeRoles = [
      {
        name: 'Sarah Manager',
        email: 'sarah@demo.com',
        userRole: 'manager',          // users.role
        employeeRole: 'manager',      // employees.role
        position: 'Fleet Manager',
        department: 'fleet'
      },
      {
        name: 'John Sales',
        email: 'john@demo.com',
        userRole: 'staff',
        employeeRole: 'sales_agent',
        position: 'Sales Agent',
        department: 'sales'
      },
      {
        name: 'Emily Reception',
        email: 'emily@demo.com',
        userRole: 'staff',
        employeeRole: 'receptionist',
        position: 'Receptionist',
        department: 'customer_service'
      },
      {
        name: 'Mike Fleet',
        email: 'mike@demo.com',
        userRole: 'staff',
        employeeRole: 'fleet_coordinator',
        position: 'Fleet Coordinator',
        department: 'fleet'
      },
      {
        name: 'Lisa Accountant',
        email: 'lisa@demo.com',
        userRole: 'admin',
        employeeRole: 'accountant',
        position: 'Senior Accountant',
        department: 'finance'
      },
    ];

    const employeeIds = [];

    for (const emp of employeeRoles) {
      const passwordHash = await bcrypt.hash('password123', 10);
      
      const userResult = await sequelize.query(`
        INSERT INTO users (id, company_id, full_name, email, password_hash, role, is_active, created_at, updated_at)
        VALUES (gen_random_uuid(), :companyId, :name, :email, :passwordHash, :userRole, true, NOW(), NOW())
        RETURNING id
      `, {
        replacements: { companyId, name: emp.name, email: emp.email, passwordHash, userRole: emp.userRole },
        type: sequelize.QueryTypes.INSERT
      });

      const empUserId = userResult[0][0].id;

      const empResult = await sequelize.query(`
        INSERT INTO employees (
          id, company_id, user_id, full_name, email, phone, position, department, role,
          salary_type, salary, hire_date, status, created_at, updated_at
        )
        VALUES (
          gen_random_uuid(), :companyId, :userId, :name, :email, :phone, :position, :department, :employeeRole,
          'monthly', :salary, :hireDate, 'active', NOW(), NOW()
        )
        RETURNING id
      `, {
        replacements: {
          companyId,
          userId: empUserId,
          name: emp.name,
          email: emp.email,
          phone: `+213 ${randomInt(500, 799)} ${randomInt(100, 999)} ${randomInt(100, 999)}`,
          position: emp.position,
          department: emp.department,
          employeeRole: emp.employeeRole,
          salary: randomInt(40000, 80000),
          hireDate: randomDate(new Date(2023, 0, 1), new Date(2024, 11, 31))
        },
        type: sequelize.QueryTypes.INSERT
      });

      employeeIds.push(empResult[0][0].id);
    }

    console.log(`âœ… Created ${employeeIds.length} employees`);

    // 2. CREATE VEHICLES
    console.log('ðŸš— Creating vehicles...');
    
    const vehicleData = [
      { brand: 'Toyota', model: 'Corolla', year: 2023, dailyRate: 4500 },
      { brand: 'Toyota', model: 'Yaris', year: 2024, dailyRate: 3500 },
      { brand: 'Hyundai', model: 'i20', year: 2023, dailyRate: 3200 },
      { brand: 'Renault', model: 'Clio', year: 2024, dailyRate: 3000 },
      { brand: 'Peugeot', model: '208', year: 2023, dailyRate: 3200 },
      { brand: 'Toyota', model: 'Hilux', year: 2024, dailyRate: 8500 },
      { brand: 'Hyundai', model: 'Tucson', year: 2023, dailyRate: 6500 },
      { brand: 'Kia', model: 'Sportage', year: 2024, dailyRate: 6800 },
      { brand: 'Nissan', model: 'Qashqai', year: 2023, dailyRate: 6000 },
      { brand: 'Ford', model: 'EcoSport', year: 2023, dailyRate: 5500 },
      { brand: 'Mercedes', model: 'C-Class', year: 2024, dailyRate: 12000 },
      { brand: 'BMW', model: '3 Series', year: 2023, dailyRate: 11500 },
      { brand: 'Audi', model: 'A4', year: 2024, dailyRate: 11000 },
      { brand: 'Volkswagen', model: 'Passat', year: 2023, dailyRate: 5500 },
      { brand: 'Seat', model: 'Ibiza', year: 2024, dailyRate: 2800 },
    ];

    const vehicleIds = [];
    const statuses = ['available', 'available', 'available', 'rented', 'available', 'rented', 'available', 'maintenance'];

    for (const v of vehicleData) {
      const regNumber = `${randomInt(10, 99)}-${randomInt(100, 999)}-${randomInt(10, 99)}`;
      const status = randomElement(statuses);
      const mileage = randomInt(5000, 80000);
      const lastMaintenance = mileage - randomInt(1000, 4500);
      
      const result = await sequelize.query(`
        INSERT INTO vehicles (
          id, company_id, brand, model, year, registration_number, color, transmission,
          fuel_type, seats, daily_rate, status, mileage, last_maintenance_mileage,
          next_maintenance_mileage, maintenance_interval_km, maintenance_alert_threshold,
          last_maintenance_alert_mileage, purchase_price, purchase_date, created_at, updated_at
        )
        VALUES (
          gen_random_uuid(), :companyId, :brand, :model, :year, :regNumber, :color, :transmission,
          :fuelType, 5, :dailyRate, :status, :mileage, :lastMaintenance,
          :nextMaintenance, 5000, 100, :lastMaintenance, :purchasePrice, :purchaseDate, NOW(), NOW()
        )
        RETURNING id
      `, {
        replacements: {
          companyId,
          brand: v.brand,
          model: v.model,
          year: v.year,
          regNumber,
          color: randomElement(['White', 'Black', 'Silver', 'Blue', 'Red', 'Gray']),
          transmission: randomElement(['automatic', 'manual']),
          fuelType: randomElement(['diesel', 'petrol']),
          dailyRate: v.dailyRate,
          status,
          mileage,
          lastMaintenance,
          nextMaintenance: lastMaintenance + 5000,
          purchasePrice: v.dailyRate * 365 * 2,
          purchaseDate: randomDate(new Date(2022, 0, 1), new Date(2023, 11, 31))
        },
        type: sequelize.QueryTypes.INSERT
      });

      vehicleIds.push(result[0][0].id);
    }

    console.log(`âœ… Created ${vehicleIds.length} vehicles`);

    // 3. CREATE CUSTOMERS
    console.log('ðŸ‘¤ Creating customers...');
    
    const firstNames = ['Ahmed', 'Fatima', 'Mohamed', 'Amina', 'Youssef', 'Samira', 'Karim', 'Leila', 'Omar', 'Nadia'];
    const lastNames = ['Benali', 'Bouazza', 'Cherif', 'Djelloul', 'Farid', 'Gharbi', 'Hamdi', 'Ibrahim', 'Khelifa', 'Larbi'];
    
    const customerIds = [];

    for (let i = 0; i < 20; i++) {
      const fullName = `${randomElement(firstNames)} ${randomElement(lastNames)}`;
      const email = fullName.toLowerCase().replace(/\s+/g, '.') + '@example.dz';
      const totalRentals = randomInt(0, 25);
      const lifetimeValue = totalRentals * randomInt(5000, 15000);

      const result = await sequelize.query(`
        INSERT INTO customers (
          id, company_id, customer_type, full_name, email, phone, address, city,
          drivers_license_number, total_rentals, lifetime_value, is_blacklisted,
          apply_tier_discount, created_at, updated_at
        )
        VALUES (
          gen_random_uuid(), :companyId, 'individual', :fullName, :email, :phone, :address, :city,
          :licenseNumber, :totalRentals, :lifetimeValue, false, true, :createdAt, NOW()
        )
        RETURNING id
      `, {
        replacements: {
          companyId,
          fullName,
          email,
          phone: `+213 ${randomInt(500, 799)} ${randomInt(100, 999)} ${randomInt(100, 999)}`,
          address: `${randomInt(1, 999)} Rue de la LibertÃ©`,
          city: randomElement(['Algiers', 'Oran', 'Constantine', 'Annaba', 'Blida']),
          licenseNumber: `DL${randomInt(100000, 999999)}`,
          totalRentals,
          lifetimeValue,
          createdAt: randomDate(new Date(2023, 0, 1), new Date(2025, 11, 31))
        },
        type: sequelize.QueryTypes.INSERT
      });

      customerIds.push(result[0][0].id);
    }

    console.log(`âœ… Created ${customerIds.length} customers`);

    // 4. CREATE CONTRACTS
    console.log('ðŸ“„ Creating contracts...');
    
    for (let i = 0; i < 30; i++) {
      const vehicleId = randomElement(vehicleIds);
      const customerId = randomElement(customerIds);
      const status = randomElement(['active', 'completed', 'completed', 'completed']);
      const contractNumber = `RENT-2026-${String(i + 1).padStart(4, '0')}`;
      
      const startDate = randomDate(new Date(2026, 0, 1), new Date(2026, 1, 10));
      const totalDays = randomInt(3, 14);
      const endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + totalDays);
      
      const dailyRate = randomInt(3000, 12000);
      const baseAmount = dailyRate * totalDays;
      const totalAmount = baseAmount * 1.19;
      
      const startMileage = randomInt(10000, 80000);
      let endMileage = null;
      let actualKmDriven = 0;

      if (status === 'completed') {
        actualKmDriven = randomInt(totalDays * 200, totalDays * 400);
        endMileage = startMileage + actualKmDriven;
      }

      await sequelize.query(`
        INSERT INTO contracts (
          id, contract_number, company_id, customer_id, vehicle_id, created_by,
          start_date, end_date, daily_rate, total_days, base_amount, total_amount,
          start_mileage, end_mileage, actual_km_driven, daily_km_limit, status,
          deposit_amount, deposit_returned, created_at, updated_at
        )
        VALUES (
          gen_random_uuid(), :contractNumber, :companyId, :customerId, :vehicleId, :userId,
          :startDate, :endDate, :dailyRate, :totalDays, :baseAmount, :totalAmount,
          :startMileage, :endMileage, :actualKmDriven, 300, :status,
          :depositAmount, :depositReturned, NOW(), NOW()
        )
      `, {
        replacements: {
          contractNumber,
          companyId,
          customerId,
          vehicleId,
          userId,
          startDate,
          endDate,
          dailyRate,
          totalDays,
          baseAmount,
          totalAmount,
          startMileage,
          endMileage,
          actualKmDriven,
          status,
          depositAmount: dailyRate * 2,
          depositReturned: status === 'completed'
        }
      });
    }

    console.log(`âœ… Created 30 contracts`);

    // 5. CREATE NOTIFICATIONS
    console.log('ðŸ”” Creating notifications...');
    
    const notifications = [
      {
        type: 'vehicle_maintenance',
        priority: 'high',
        title: 'âš ï¸ Maintenance Due',
        message: 'Toyota Hilux requires maintenance at 78,500 km'
      },
      {
        type: 'km_limit_warning',
        priority: 'medium',
        title: 'âš ï¸ KM Limit Warning',
        message: 'Contract RENT-2026-0015: Vehicle has 250km remaining'
      },
      {
        type: 'payment_due',
        priority: 'high',
        title: 'ðŸ’° Payment Pending',
        message: 'Outstanding payment of 12,500 DA for Contract RENT-2026-0020'
      }
    ];

    for (const notif of notifications) {
      await sequelize.query(`
        INSERT INTO notifications (
          id, company_id, type, priority, title, message, is_read, created_at, updated_at
        )
        VALUES (
          gen_random_uuid(), :companyId, :type, :priority, :title, :message, false, NOW(), NOW()
        )
      `, {
        replacements: {
          companyId,
          type: notif.type,
          priority: notif.priority,
          title: notif.title,
          message: notif.message
        }
      });
    }

    console.log(`âœ… Created ${notifications.length} notifications`);

    // ============================================
    // SUMMARY
    // ============================================
    console.log('\nâœ… DATABASE RESET AND SEEDING COMPLETED!\n');
    console.log('ðŸ“Š Summary:');
    console.log(`   - Employees: ${employeeIds.length}`);
    console.log(`   - Vehicles: ${vehicleIds.length}`);
    console.log(`   - Customers: ${customerIds.length}`);
    console.log(`   - Contracts: 30`);
    console.log(`   - Notifications: ${notifications.length}`);
    console.log('\nðŸŽ‰ Your demo database is ready!');
    console.log('\nðŸ”‘ Login credentials:');
    console.log('   Email: demo@demo.com');
    console.log('   Password: demo123');
    console.log('\nðŸ“ Employee accounts:');
    console.log('   - sarah@demo.com / password123 (Manager)');
    console.log('   - john@demo.com / password123 (Sales Agent)');
    console.log('   - emily@demo.com / password123 (Receptionist)');
    console.log('   - mike@demo.com / password123 (Fleet Coordinator)');
    console.log('   - lisa@demo.com / password123 (Accountant)');

  } catch (error) {
    console.error('âŒ Error:', error.message);
    throw error;
  } finally {
    await sequelize.close();
  }
}

resetAndSeed()
  .then(() => {
    console.log('\nðŸ‘‹ Complete!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('ðŸ’¥ Fatal error:', error);
    process.exit(1);
  });

// C:\Users\kebic\OneDrive\Documents\car-rental-rahim\car-rental-backend\server.js
// server.js (UPDATED)
const app = require('./src/app');
const { sequelize, testConnection } = require('./src/config/database');
const { scheduleVehicleLimitCheck } = require('./src/jobs/vehicleLimitMonitoring.job');
const { scheduleMaintenanceMonitoring } = require('./src/jobs/vehicleMaintenanceMonitoring.job');
const { scheduleKmLimitMonitoring } = require('./src/jobs/kmLimitMonitoring.job');

const PORT = process.env.PORT || 5000;

const startServer = async () => {
  try {
    // 1. Test DB connection
    await testConnection();
    console.log('âœ… Database connected');

    // IMPORTANT: Only sync in development, NEVER in production
    if (process.env.NODE_ENV === 'development') {
      await sequelize.sync({ alter: false });
      console.log('âœ… Database synced');
    }

    // 3. Start cron jobs
    console.log('â° Starting scheduled jobs...');
    scheduleVehicleLimitCheck();        // Daily at 9 AM
    scheduleMaintenanceMonitoring();    // Every 6 hours + daily at 8 AM
    scheduleKmLimitMonitoring();        // Every 4 hours
    console.log('âœ… All cron jobs scheduled');

    // 4. Start the server
    app.listen(PORT, () => {
      console.log(`ðŸš€ Server running on port ${PORT}`);
      console.log(`ðŸ“ Environment: ${process.env.NODE_ENV || 'development'}`);
      console.log(`ðŸŒ API Base URL: http://localhost:${PORT}/api`);
    });

  } catch (error) {
    console.error('âŒ Server startup failed:', error);
    process.exit(1);
  }
};

// Handle graceful shutdown
process.on('SIGTERM', () => {
  console.log('ðŸ‘‹ SIGTERM signal received: closing server gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('ðŸ‘‹ SIGINT signal received: closing server gracefully');
  process.exit(0);
});

startServer();